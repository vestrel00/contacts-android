{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Android Contacts, Reborn","text":"<p>Written with \u2665\ufe0f and \ud83d\udd25 since December 2018. Open sourced since October 2021. </p> <p></p> <p> </p> <p> </p> <p>This library provides a complete set of APIs to do everything you need with Contacts in Android.  You no longer have to deal with the Contacts Provider, database operations,  and cursors. </p> <p>Whether you just need to get all or some Contacts for a small part of your app (written in Kotlin or Java), or you are looking to create your own full-fledged Contacts app with the same capabilities as the AOSP Android Contacts app and Google Contacts app, this library is for you!</p> <p>Please help support this project \ud83d\ude4f\u2764\ufe0f\u2b50\ufe0f</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>\ud83d\udcdc Documentation</li> <li>\ud83d\ude89 Current Release - 0.3.2</li> <li>\ud83d\ude82 Upcoming Release - 0.4.0</li> <li>\u2139\ufe0f Project Status</li> <li>\ud83d\uddfa Project Roadmap</li> <li>\ud83d\udc8c Why use this library?</li> </ul>"},{"location":"#features","title":"Features","text":"<p>The <code>core</code> module provides,</p> <ul> <li>\u2705 All data kinds in the Contacts Provider;   address, email, event, group membership, IM, name, nickname, note, organization, phone, photo, relation, SIP address, and website</li> <li>\u2705 Custom data integration</li> <li>\u2705 Broad queries and advanced queries of Contacts and RawContacts from zero or more Accounts and/or Groups</li> <li>\u2705 Queries using lookup keys</li> <li>\u2705 Phone lookup queries for specialized matching of phone or SIP</li> <li>\u2705 Include only desired fields in read/write operations to optimize CPU and memory</li> <li>\u2705 Powerful, type-safe query DSL</li> <li>\u2705 Pagination using order by, limit, and offset database functions.</li> <li>\u2705 Insert one or more RawContacts with an associated Account,   causing automatic insertion of a new Contact subject to automatic aggregation by the Contacts Provider</li> <li>\u2705 Update one or more Contacts, RawContacts, and Data</li> <li>\u2705 Delete one or more Contacts, RawContacts, and Data</li> <li>\u2705 Query, insert,   update, and delete Profile (device owner) Contact, RawContact, and Data</li> <li>\u2705 Query, insert,   update, and delete Groups</li> <li>\u2705 Query, insert update, and delete specific kinds of data</li> <li>\u2705 Query, insert,    update, and delete custom data</li> <li>\u2705 Query, insert,   and delete Blocked Numbers</li> <li>\u2705 Query, insert,   update, and delete SIM card contacts</li> <li>\u2705 Query for Accounts in the system or RawContacts table</li> <li>\u2705 Query for just RawContacts</li> <li>\u2705 Move RawContacts across Accounts</li> <li>\u2705 Link/unlink two or more Contacts</li> <li>\u2705 Get/set contact options;   starred (favorite), custom ringtone, send to voicemail</li> <li>\u2705 Get/set Contacts/RawContact photo and thumbnail</li> <li>\u2705 Get/set default (primary) Contact Data   (e.g. default/primary phone number, email, etc)</li> <li>\u2705 Share contacts via vCard (.VCF)</li> <li>\u2705 Convenience functions</li> <li>\u2705 Contact data is synced automatically across devices</li> <li>\u2705 Support for logging API input and output</li> <li>\u2705 Redactable entities and API input and output   for production-safe logging that upholds user data privacy laws to meet GDPR guidelines    (this is not legal advice)</li> <li>\u2705 Full in-depth documentation/guides.</li> <li>\u2705 Full Java interoperability</li> <li>\u2705 Core APIs have zero dependency</li> <li>\u2705 Clean separation between Contacts vs RawContacts</li> <li>\u2705 Clear distinction between truly deeply immutable, mutable, new, and existing entities allowing for thread safety and JetPack compose optimizations</li> </ul> <p>There are also extensions that add functionality to every core function,</p> <ul> <li>\ud83e\uddf0 Asynchronous work using Kotlin Coroutines</li> <li>\ud83e\uddf0 Permissions request/handling using Kotlin Coroutines</li> <li>\ud83d\udd1c Kotlin Flow extensions</li> <li>\ud83d\udd1c RxJava extensions</li> </ul> <p>Also included are some pre-baked goodies to be used as is or just for reference,</p> <ul> <li>\ud83c\udf6c Gender custom data</li> <li>\ud83c\udf6c Google Contacts custom data</li> <li>\ud83c\udf6c Handle name custom data</li> <li>\ud83c\udf6c Pokemon custom data</li> <li>\ud83c\udf6c Role Playing Game (RPG) custom data</li> <li>\ud83c\udf6c Rudimentary contacts-integrated UI components</li> <li>\ud83c\udf6c Debug functions to aid in development</li> </ul> <p>There are also more features that are on the way!</p> <ol> <li>\u2622\ufe0f Work profile contacts</li> <li>\u2622\ufe0f Dynamically integrate custom data from other apps</li> <li>\u2622\ufe0f Auto-generated custom data using annotations</li> <li>\u2622\ufe0f Read/write from/to .VCF file</li> <li>\u2622\ufe0f Multi-SIM card support</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>\u2139\ufe0f This library is a multi-module project published with JitPack </p> <p>First, include JitPack in the repositories list,</p> <pre><code>repositories {\n    maven { url \"https://jitpack.io\" }\n}\n</code></pre> <p>To install individual modules,</p> <pre><code>dependencies {\n    implementation 'com.github.vestrel00.contacts-android:core:0.3.2'\n\n    implementation 'com.github.vestrel00.contacts-android:async:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:customdata-gender:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:customdata-googlecontacts:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:customdata-handlename:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:customdata-pokemon:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:customdata-rpg:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:debug:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:permissions:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:test:0.3.2'\n    implementation 'com.github.vestrel00.contacts-android:ui:0.3.2'\n    // Notice that when importing specific modules/subprojects, the first \":\" comes after \"contacts-android\".\n}\n</code></pre> <p>The <code>core</code> module is really all you need. All other modules are optional.</p> <p>To install all modules in a single line,</p> <pre><code>dependencies {\n    implementation 'com.github.vestrel00:contacts-android:0.3.2'\n    // Notice that when importing all modules, the first \":\" comes after \"vestrel00\".\n}\n</code></pre> <p>\u26a0\ufe0f Starting with version 0.2.0, installing all modules in a single line is only supported when  using the <code>dependencyResolutionManagement</code> in <code>settings.gradle</code>. You are still able to install all modules by specifying them individually. </p> <p>For more info about the different modules and dependency resolution management,  read the Installation guide.</p>"},{"location":"#setup","title":"Setup","text":"<p>There is no setup required. It's up to you how you want to create and retain instances of the <code>contacts.core.Contacts(context)</code> API. For more info, read Contacts API Setup.</p> <p>It is also useful to read about API Entities.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To retrieve all contacts containing all available contact data,</p> <pre><code>val contacts = Contacts(context).query().find()\n</code></pre> <p>To simply search for Contacts, yielding the exact same results as the AOSP Contacts app,</p> <pre><code>val contacts = Contacts(context)\n    .broadQuery()\n    .wherePartiallyMatches(searchText)\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts.</p> <p>Something a bit more advanced...</p> <p>To retrieve the first 5 contacts (including only the contact id, display name, and phone numbers in the results) ordered by display name in descending order, matching ALL of these rules; - a first name starting with \"leo\" - has emails from gmail or hotmail - lives in the US - has been born prior to making this query - is favorited (starred) - has a nickname of \"DarEdEvil\" (case sensitive) - works for Facebook - has a note - belongs to the account of \"john.doe@gmail.com\" or \"john.doe@myspace.com\"</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    .where {\n        (Name.GivenName startsWith \"leo\") and\n        (Email.Address { endsWith(\"gmail.com\") or endsWith(\"hotmail.com\") }) and\n        (Address.Country equalToIgnoreCase \"us\") and\n        (Event { (Date lessThan Date().toWhereString()) and (Type equalTo EventEntity.Type.BIRTHDAY) }) and\n        (Contact.Options.Starred equalTo true) and\n        (Nickname.Name equalTo \"DarEdEvil\") and\n        (Organization.Company `in` listOf(\"facebook\", \"FB\")) and\n        (Note.Note.isNotNullOrEmpty())\n    }\n    .accounts(\n        Account(\"john.doe@gmail.com\", \"com.google\"),\n        Account(\"john.doe@myspace.com\", \"com.myspace\"),\n    )\n    .include { setOf(\n        Contact.Id,\n        Contact.DisplayNamePrimary,\n        Phone.Number\n    ) }\n    .orderBy(ContactsFields.DisplayNamePrimary.desc())\n    .offset(0)\n    .limit(5)\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Once you have the contacts, you now have access to all of their data!</p> <pre><code>val contact: Contact\nLog.d(\n    \"Contact\",\n    \"\"\"\n        ID: ${contact.id}\n        Lookup Key: ${contact.lookupKey}\n\n        Display name: ${contact.displayNamePrimary}\n        Display name alt: ${contact.displayNameAlt}\n\n        Photo Uri: ${contact.photoUri}\n        Thumbnail Uri: ${contact.photoThumbnailUri}\n\n        Last updated: ${contact.lastUpdatedTimestamp}\n\n        Starred?: ${contact.options?.starred}\n        Send to voicemail?: ${contact.options?.sendToVoicemail}\n        Ringtone: ${contact.options?.customRingtone}\n\n        Aggregate data from all RawContacts of the contact\n        -----------------------------------\n        Addresses: ${contact.addressList()}\n        Emails: ${contact.emailList()}\n        Events: ${contact.eventList()}\n        Group memberships: ${contact.groupMembershipList()}\n        IMs: ${contact.imList()}\n        Names: ${contact.nameList()}\n        Nicknames: ${contact.nicknameList()}\n        Notes: ${contact.noteList()}\n        Organizations: ${contact.organizationList()}\n        Phones: ${contact.phoneList()}\n        Relations: ${contact.relationList()}\n        SipAddresses: ${contact.sipAddressList()}\n        Websites: ${contact.websiteList()}\n        -----------------------------------\n    \"\"\".trimIndent()\n    // There are also aggregate data functions that return a sequence instead of a list.\n)\n</code></pre> <p>\u2139\ufe0f For more info, read about API Entities.</p>"},{"location":"#more-than-enough-apis-that-will-allow-you-to-build-your-own-contacts-app","title":"More than enough APIs that will allow you to build your own contacts app!","text":"<p>This library is capable of doing more than just querying contacts. Actually, you can build your own full-fledged contacts app with it!</p> <p>Let's take a look at a few other APIs this library provides...</p> <p>To get the first 20 gmail emails ordered by email address in descending order,</p> <pre><code>val emails = Contacts(context)\n    .data()\n    .query()\n    .emails()\n    .where { Email.Address endsWith \"gmail.com\" }\n    .orderBy(Fields.Email.Address.desc(ignoreCase = true))\n    .offset(0)\n    .limit(20)\n    .find()\n</code></pre> <p>It's not just for emails. It's for all data kinds (including custom data).</p> <p>\u2139\ufe0f For more info, read Query specific data kinds.</p> <p>To CREATE/INSERT a contact with a name of \"John Doe\" who works at Amazon with a work email of \"john.doe@amazon.com\" (in Kotlin),</p> <pre><code>val insertResult = Contacts(context)\n    .insert()\n    .rawContacts(NewRawContact().apply {\n        name = NewName().apply {\n            givenName = \"John\"\n            familyName = \"Doe\"\n        }\n        organization = NewOrganization().apply {\n            company = \"Amazon\"\n            title = \"Superstar\"\n        }\n        emails.add(NewEmail().apply {\n            address = \"john.doe@amazon.com\"\n            type = EmailEntity.Type.WORK\n        })\n    })\n    .commit()\n</code></pre> <p>Or alternatively, in a more Kotlinized style using named arguments,</p> <pre><code>val insertResult = Contacts(context)\n    .insert()\n    .rawContacts(NewRawContact(\n        name = NewName(\n            givenName = \"John\",\n            familyName = \"Doe\"\n        ),\n        organization = NewOrganization(\n            company = \"Amazon\",\n            title = \"Superstar\"\n        ),\n        emails = mutableListOf(NewEmail(\n            address = \"john.doe@amazon.com\",\n            type = EmailEntity.Type.WORK\n        ))\n    ))\n    .commit()\n</code></pre> <p>Or alternatively, using extension functions,</p> <pre><code>val insertResult = Contacts(context)\n    .insert()\n    .rawContact {\n        setName {\n            givenName = \"John\"\n            familyName = \"Doe\"\n        }\n        setOrganization {\n            company = \"Amazon\"\n            title = \"Superstar\"\n        }\n        addEmail {\n            address = \"john.doe@amazon.com\"\n            type = EmailEntity.Type.WORK\n        }\n    }\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Insert contacts.</p> <p>If John Doe switches jobs and heads over to Microsoft, we can UPDATE his data,</p> <pre><code>Contacts(context)\n    .update()\n    .contacts(johnDoe.mutableCopy {\n        setOrganization {\n            company = \"Microsoft\"\n            title = \"Newb\"\n        }\n        emails().first().apply {\n            address = \"john.doe@microsoft.com\"\n        }\n    })\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Update contacts.</p> <p>If we no longer like John Doe, we can DELETE him from our life,</p> <pre><code>Contacts(context)\n    .delete()\n    .contacts(johnDoe)\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Delete Contacts.</p>"},{"location":"#threading-and-permissions","title":"Threading and permissions","text":"<p>This library provides Kotlin coroutine extensions in the <code>permissions</code> module for all API functions to handle permissions and <code>async</code> module for executing work in background threads.</p> <pre><code>launch {\n    val contacts = Contacts(context)\n        .queryWithPermission()\n        ...\n        .findWithContext()\n\n    val deferredResult = Contacts(context)\n        .insertWithPermission()\n        ...\n        .commitAsync()\n    val result = deferredResult.await()\n}\n</code></pre> <p>\u2139\ufe0f For more info, read Permissions handling using coroutines and Execute work outside of the UI thread using coroutines.</p> <p>So, if we call the above function and we don't yet have permission. The user will be prompted to give the appropriate permissions before the query proceeds. Then, the work is done in the coroutine context of choice (default is Dispatchers.IO). If the user does not give permission, the query will return no results.</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for  listening to Contacts database changes.</p>"},{"location":"#full-documentation-guides-and-samples","title":"Full documentation, guides, and samples","text":"<p>The above examples barely scratches the surface of what this library provides. For more in-depth documentation, visit the GitHub Pages. For a sample app reference, take a look at  and run the <code>sample</code> module.</p>"},{"location":"#all-apis-in-the-library-are-optimized","title":"All APIs in the library are optimized!","text":"<p>Some other APIs or util functions out there typically perform one internal database query per  contact returned. They do this to fetch the data per contact. This means that if there are  1,000 matching contacts, then an extra 1,000 internal database queries are performed!  This is not cool!</p> <p>To address this issue, the query APIs provided in the Contacts, Reborn library, perform only at  least two internal database queries no matter how many contacts are matched! Even if there are  10,000 contacts matched, the library will only perform two internal database queries (depending on  your query parameters). Fetch 10,000 contacts as fast as 99 milliseconds (varies per device)!</p> <p>\u2139\ufe0f For more info, read Optimizing queries.</p> <p>Of course, if you don't want to fetch all hundreds of thousands of contacts, the query APIs support  pagination with <code>limit</code> and <code>offset</code> functions!</p> <p>Cancellations are also supported! To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The find function optionally takes in a function that, if it returns true, will cancel query  processing as soon as possible. The function is called numerous times during query processing to  check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently  used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is  cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n    // Or, using the coroutine extensions in the async module...\n    val contacts = query.findWithContext()\n}\n</code></pre>"},{"location":"#all-core-apis-are-framework-agnostic-and-works-well-with-java-and-kotlin","title":"All core APIs are framework-agnostic and works well with Java and Kotlin","text":"<p>The API does not and will not force you to use any frameworks (e.g. RxJava or Coroutines/Flow)! All core functions of the API live in the <code>core</code> module, which you can import to your project all by itself. Don't believe me? Take a look at the dependencies in the <code>core/build.gradle</code> :D </p> <p>So, feel free to use the core API however you want with whatever libraries or frameworks you want,  such as Reactive, Coroutines/Flow, AsyncTask (hope not), WorkManager, and whatever permissions  handling APIs you want to use.</p> <p>All other modules in this library are optional and are just there for your convenience or for reference.</p> <p>I also made sure that all core functions and entities are interoperable with Java. So, if  you were wondering why I\u2019m using a semi-builder pattern instead of using named arguments with  default values, that is why. I\u2019ve also made some other intentional decisions about API design to  ensure the best possible experience for both Kotlin and Java consumers without sacrificing Kotlin  language standards. It is Kotlin-first, Java-second (with love and care).</p> <p>\u26a0\ufe0f Modules other than the core module are not guaranteed to be compatible with Java.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Min SDK 19+</li> </ul>"},{"location":"#proguard","title":"Proguard","text":"<p>If you use Proguard and the <code>async</code> and/or <code>permissions</code> modules, then you may need to add rules for Coroutines.</p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2023 Contacts Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"cheatsheet/","title":"Android Contacts, Reborn (CHEATSHEET)","text":"<p>This page gives you basic sample copy-paste code showcasing how to use all of the core APIs provided in this library in both Kotlin and Java!</p> <p>The examples provided here show the most basic usage of each <code>core</code> API. Click on the section heading explore each API in full detail. You may also find these samples in the <code>sample</code> module's <code>contacts.sample.cheatsheet</code> package.</p> <p>\u26a0\ufe0f Executing <code>find()</code> and <code>commit()</code> functions in the UI thread may result in choppy UI. Those should be invoked in background threads instead. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>\u2139\ufe0f This is the only documentation page that contains Java samples. I want to keep the rest of the documentation Kotlin-only in order to keep the markdown files clean and free of non-markdown  markups from MkDocs. Also, most of the code is the same so it would just add clutter.</p>"},{"location":"cheatsheet/#basics","title":"Basics","text":""},{"location":"cheatsheet/#query-contacts","title":"Query contacts","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.Contact\n\nclass QueryContactsActivity : Activity() {\n\n    fun getAllContacts(): List&lt;Contact&gt; = Contacts(this).broadQuery().find()\n\n    fun getAllContactsWithFavoritesFirstOrderedByDisplayName(): List&lt;Contact&gt; = Contacts(this)\n        .broadQuery()\n        .orderBy(\n            ContactsFields.Options.Starred.desc(),\n            ContactsFields.DisplayNamePrimary.asc(ignoreCase = true)\n        )\n        .find()\n\n    fun getContactsWithEmailOrDisplayNameThatPartiallyMatches(text: String?): List&lt;Contact&gt; =\n        Contacts(this)\n            .broadQuery()\n            .match(BroadQuery.Match.EMAIL)\n            .wherePartiallyMatches(text)\n            .find()\n\n    fun getContactsWithPhoneOrDisplayNameThatPartiallyMatches(text: String?): List&lt;Contact&gt; =\n        Contacts(this)\n            .broadQuery()\n            .match(BroadQuery.Match.PHONE)\n            .wherePartiallyMatches(text)\n            .find()\n\n    fun getAllContactsIncludingOnlyDisplayNameAndEmailAddresses(): List&lt;Contact&gt; = Contacts(this)\n        .broadQuery()\n        .include(\n            Fields.Contact.DisplayNamePrimary,\n            Fields.Email.Address\n        )\n        .find()\n\n    fun get25Contacts(): List&lt;Contact&gt; = Contacts(this)\n        .broadQuery()\n        .limit(25)\n        .find()\n\n    fun get25ContactsSkippingTheFirst25(): List&lt;Contact&gt; = Contacts(this)\n        .broadQuery()\n        .offset(25)\n        .limit(25)\n        .find()\n}\n</code></pre> <pre><code>import static contacts.core.OrderByKt.*;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.BroadQuery;\nimport contacts.core.ContactsFactory;\nimport contacts.core.ContactsFields;\nimport contacts.core.Fields;\nimport contacts.core.entities.Contact;\n\npublic class QueryContactsActivity extends Activity {\n\n    List&lt;Contact&gt; getAllContacts() {\n        return ContactsFactory.create(this).broadQuery().find();\n    }\n\n    List&lt;Contact&gt; getAllContactsWithFavoritesFirstOrderedByDisplayName() {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .orderBy(\n                        desc(ContactsFields.Options.Starred),\n                        asc(ContactsFields.DisplayNamePrimary, true)\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithAnyDataThatPartiallyMatches(String text) {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .match(BroadQuery.Match.ANY)\n                .wherePartiallyMatches(text)\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithEmailOrDisplayNameThatPartiallyMatches(String text) {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .match(BroadQuery.Match.EMAIL)\n                .wherePartiallyMatches(text)\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithPhoneOrDisplayNameThatPartiallyMatches(String text) {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .match(BroadQuery.Match.PHONE)\n                .wherePartiallyMatches(text)\n                .find();\n    }\n\n    List&lt;Contact&gt; getAllContactsIncludingOnlyDisplayNameAndEmailAddresses() {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .include(\n                        Fields.Contact.DisplayNamePrimary,\n                        Fields.Email.Address\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; get25Contacts() {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .limit(25)\n                .find();\n    }\n\n    List&lt;Contact&gt; get25ContactsSkippingTheFirst25() {\n        return ContactsFactory.create(this)\n                .broadQuery()\n                .offset(25)\n                .limit(25)\n                .find();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#query-contacts-advanced","title":"Query contacts (advanced)","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.Contact\nimport contacts.core.util.lookupKeyIn\n\nclass QueryContactsAdvancedActivity : Activity() {\n\n    fun getContactById(contactId: Long): Contact? = Contacts(this)\n        .query()\n        .where { Contact.Id equalTo contactId }\n        .find()\n        .firstOrNull()\n\n    fun getContactByLookupKey(lookupKey: String, contactId: Long): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .where { Contact.lookupKeyIn(lookupKey)?.or(Contact.Id equalTo contactId) }\n        .find()\n\n    fun getAllContactsForAGoogleAccount(): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .accounts(Account(\"email@gmail.com\", \"com.google\"))\n        .find()\n\n    fun getOnlyFavoriteContacts(): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .where {\n            Contact.Options.Starred equalTo true\n        }\n        .find()\n\n    fun getContactsPartiallyMatchingDisplayName(): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .where {\n            Contact.DisplayNamePrimary contains \"alex\"\n        }\n        .find()\n\n    fun getContactsWithAtLeastOneGmailEmail(): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .where {\n            Email.Address endsWith \"@gmail.com\"\n        }\n        .find()\n\n    fun getContactsWithAtLeastOnePhoneNumber(): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .where {\n            Contact.HasPhoneNumber equalTo true\n            // Phone.Number.isNotNullOrEmpty() this works too but the above is more optimized\n        }\n        .find()\n\n    fun getContactsWithAtLeastOnePhoneNumberAndEmail(): List&lt;Contact&gt; = Contacts(this)\n        .query()\n        .where {\n            Phone.Number.isNotNullOrEmpty() and Email.Address.isNotNullOrEmpty()\n            // or Contact.HasPhoneNumber equalTo true and Email.Address.isNotNullOrEmpty()\n        }\n        .find()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\nimport static contacts.core.util.ContactLookupKeyKt.lookupKeyIn;\n\nimport android.accounts.Account;\nimport android.app.Activity;\n\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Fields;\nimport contacts.core.Query;\nimport contacts.core.entities.Contact;\n\npublic class QueryContactsAdvancedActivity extends Activity {\n\n    @Nullable\n    Contact getContactById(Long contactId) {\n        Query.Result result = ContactsFactory.create(this)\n                .query()\n                .where(equalTo(Fields.Contact.Id, contactId))\n                .find();\n        return !result.isEmpty() ? result.get(0) : null;\n    }\n\n    List&lt;Contact&gt; getContactByLookupKey(String lookupKey, long contactId) {\n        return ContactsFactory.create(this)\n                .query()\n                .where(\n                        or(\n                                equalTo(Fields.Contact.Id, contactId),\n                                lookupKeyIn(Fields.Contact, lookupKey)\n                        )\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; getAllContactsForAGoogleAccount() {\n        return ContactsFactory.create(this)\n                .query()\n                .accounts(new Account(\"email@gmail.com\", \"com.google\"))\n                .find();\n    }\n\n    List&lt;Contact&gt; getOnlyFavoriteContacts() {\n        return ContactsFactory.create(this)\n                .query()\n                .where(\n                        equalTo(Fields.Contact.Options.Starred, true)\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsPartiallyMatchingDisplayName() {\n        return ContactsFactory.create(this)\n                .query()\n                .where(\n                        contains(Fields.Contact.DisplayNamePrimary, \"alex\")\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithAtLeastOneGmailEmail() {\n        return ContactsFactory.create(this)\n                .query()\n                .where(\n                        endsWith(Fields.Email.Address, \"@gmail.com\")\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithAtLeastOnePhoneNumber() {\n        return ContactsFactory.create(this)\n                .query()\n                .where(\n                        equalTo(Fields.Contact.HasPhoneNumber, true)\n                        // isNotNullOrEmpty(Fields.Phone.Number) this works too but the above is more optimized\n                )\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithAtLeastOnePhoneNumberAndEmail() {\n        return ContactsFactory.create(this)\n                .query()\n                .where(\n                        and(\n                                isNotNullOrEmpty(Fields.Phone.Number),\n                                // or equalTo(Fields.Contact.HasPhoneNumber, true),\n                                isNotNullOrEmpty(Fields.Email.Address)\n                        )\n                )\n                .find();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#query-contacts-by-lookup-key","title":"Query contacts by lookup key","text":"KotlinJava <pre><code>package contacts.sample.cheatsheet.basics.kotlin\n\nimport android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.LookupQuery\nimport contacts.core.entities.Contact\n\nclass QueryContactsByLookupKeyActivity : Activity() {\n\n    fun getContactByLookupKey(lookupKey: String): Contact? =\n        Contacts(this)\n            .lookupQuery()\n            .whereLookupKeyMatches(lookupKey)\n            .find()\n            .firstOrNull()\n\n    fun getContactByLookupKeyWithId(lookupKey: String, contactId: Long): Contact? =\n        Contacts(this)\n            .lookupQuery()\n            .whereLookupKeyWithIdMatches(LookupQuery.LookupKeyWithId(lookupKey, contactId))\n            .find()\n            .firstOrNull()\n}\n</code></pre> <pre><code>package contacts.sample.cheatsheet.basics.java;\n\nimport android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.LookupQuery;\nimport contacts.core.entities.Contact;\n\npublic class QueryContactsByLookupKeyActivity extends Activity {\n\n    Contact getContactByLookupKey(String lookupKey) {\n        LookupQuery.Result result = ContactsFactory.create(this)\n                .lookupQuery()\n                .whereLookupKeyMatches(lookupKey)\n                .find();\n        return !result.isEmpty() ? result.get(0) : null;\n    }\n\n    Contact getContactByLookupKeyWithId(String lookupKey, long contactId) {\n        LookupQuery.Result result = ContactsFactory.create(this)\n                .lookupQuery()\n                .whereLookupKeyWithIdMatches(new LookupQuery.LookupKeyWithId(lookupKey, contactId))\n                .find();\n        return !result.isEmpty() ? result.get(0) : null;\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#query-contacts-by-phone-or-sip","title":"Query contacts by phone or SIP","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.Contact\n\nclass QueryContactsByPhoneOrSipActivity : Activity() {\n\n    fun getContactsWithPhoneNumberThatExactlyMatches(text: String?): List&lt;Contact&gt; =\n        Contacts(this)\n            .phoneLookupQuery()\n            .match(PhoneLookupQuery.Match.PHONE)\n            .whereExactlyMatches(text)\n            .find()\n\n    fun getContactsWithSipAddressThatExactlyMatches(text: String?): List&lt;Contact&gt; =\n        Contacts(this)\n            .phoneLookupQuery()\n            .match(PhoneLookupQuery.Match.SIP)\n            .whereExactlyMatches(text)\n            .find()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.PhoneLookupQuery;\nimport contacts.core.entities.Contact;\n\npublic class QueryContactsByPhoneOrSipActivity extends Activity {\n\n    List&lt;Contact&gt; getContactsWithPhoneNumberThatExactlyMatches(String text) {\n        return ContactsFactory.create(this)\n                .phoneLookupQuery()\n                .match(PhoneLookupQuery.Match.PHONE)\n                .whereExactlyMatches(text)\n                .find();\n    }\n\n    List&lt;Contact&gt; getContactsWithEmailOrDisplayNameThatPartiallyMatches(String text) {\n        return ContactsFactory.create(this)\n                .phoneLookupQuery()\n                .match(PhoneLookupQuery.Match.SIP)\n                .whereExactlyMatches(text)\n                .find();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#query-for-rawcontacts","title":"Query for RawContacts","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.RawContactsFields\nimport contacts.core.entities.RawContact\nimport contacts.core.equalTo\nimport contacts.core.isNotNullOrEmpty\n\nclass QueryRawContactsActivity : Activity() {\n\n    fun getAllRawContacts(): List&lt;RawContact&gt; = Contacts(this).rawContactsQuery().find()\n\n    fun getAllFavoriteRawContacts(): List&lt;RawContact&gt; = Contacts(this)\n        .rawContactsQuery()\n        .rawContactsWhere(emptyList(), RawContactsFields.Options.Starred equalTo true)\n        .find()\n\n    fun getRawContactsForAccount(account: Account): List&lt;RawContact&gt; =\n        Contacts(this)\n            .rawContactsQuery()\n            .rawContactsWhere(listOf(account), null)\n            .find()\n\n    fun getRawContactsForAllGoogleAccounts(): List&lt;RawContact&gt; =\n        Contacts(this)\n            .rawContactsQuery()\n            .rawContactsWhere(emptyList(), RawContactsFields.AccountType equalTo \"com.google\")\n            .find()\n\n    fun getRawContactsThatHasANote(): List&lt;RawContact&gt; =\n        Contacts(this)\n            .rawContactsQuery()\n            .where { Note.Note.isNotNullOrEmpty() }\n            .find()\n\n    fun getRawContactById(rawContactId: Long): RawContact? =\n        Contacts(this)\n            .rawContactsQuery()\n            .rawContactsWhere(emptyList(), RawContactsFields.Id equalTo rawContactId)\n            // alternatively, .where { RawContact.Id equalTo rawContactId }\n            .find()\n            .firstOrNull()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.equalTo;\nimport static contacts.core.WhereKt.isNotNullOrEmpty;\n\nimport android.accounts.Account;\nimport android.app.Activity;\n\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Fields;\nimport contacts.core.RawContactsFields;\nimport contacts.core.RawContactsQuery;\nimport contacts.core.entities.RawContact;\n\npublic class QueryRawContactsActivity extends Activity {\n\n    List&lt;RawContact&gt; getAllRawContacts() {\n        return ContactsFactory.create(this).rawContactsQuery().find();\n    }\n\n    List&lt;RawContact&gt; getAllFavoriteRawContacts() {\n        return ContactsFactory.create(this)\n                .rawContactsQuery()\n                .rawContactsWhere(\n                        new ArrayList&lt;&gt;(),\n                        equalTo(RawContactsFields.Options.Starred, true)\n                )\n                .find();\n    }\n\n    List&lt;RawContact&gt; getRawContactsForAccount(Account account) {\n        List&lt;Account&gt; accounts = new ArrayList&lt;&gt;();\n        accounts.add(account);\n        return ContactsFactory.create(this)\n                .rawContactsQuery()\n                .rawContactsWhere(accounts, null)\n                .find();\n    }\n\n    List&lt;RawContact&gt; getRawContactsForAllGoogleAccounts() {\n        return ContactsFactory.create(this)\n                .rawContactsQuery()\n                .rawContactsWhere(\n                        new ArrayList&lt;&gt;(),\n                        equalTo(RawContactsFields.AccountType, \"com.google\")\n                )\n                .find();\n    }\n\n    List&lt;RawContact&gt; getRawContactsThatHasANote() {\n        return ContactsFactory.create(this)\n                .rawContactsQuery()\n                .where(isNotNullOrEmpty(Fields.Note.Note))\n                .find();\n    }\n    @Nullable\n    RawContact getRawContactById(Long rawContactId) {\n        RawContactsQuery.Result result = ContactsFactory.create(this)\n                .rawContactsQuery()\n                .rawContactsWhere(\n                        new ArrayList&lt;&gt;(),\n                        equalTo(RawContactsFields.Id, rawContactId)\n                )\n                // alternatively, .where(equalTo(Fields.RawContact.Id, rawContactId))\n                .limit(1)\n                .find();\n        return !result.isEmpty() ? result.get(0) : null;\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#insert-contacts","title":"Insert contacts","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.Insert\nimport contacts.core.entities.*\nimport contacts.core.util.*\n\nclass InsertContactsActivity : Activity() {\n\n    fun insertContact(account: Account?, groupMembership: NewGroupMembership?): Insert.Result =\n        Contacts(this)\n            .insert()\n            .rawContact {\n                setAccount(account)\n                addAddress {\n                    street = \"123 Abc street\"\n                    city = \"Brooklyn\"\n                    region = \"New York\"\n                    postcode = \"11207\"\n                    country = \"US\"\n                    type = AddressEntity.Type.WORK\n                }\n                addEmail {\n                    address = \"123@abc.com\"\n                    type = EmailEntity.Type.WORK\n                }\n                addEvent {\n                    date = EventDate.from(1990, 0, 1)\n                    type = EventEntity.Type.BIRTHDAY\n                }\n                if (groupMembership != null) {\n                    addGroupMembership(groupMembership)\n                }\n                addIm {\n                    data = \"im@aol.com\"\n                    protocol = ImEntity.Protocol.CUSTOM\n                    customProtocol = \"AOL\"\n                }\n                setName {\n                    prefix = \"Mr.\"\n                    givenName = \"Big\"\n                    middleName = \"Bad\"\n                    familyName = \"Fox\"\n                    suffix = \"Jr\"\n                }\n                setNickname {\n                    name = \"BIG BAD FOX\"\n                }\n                setNote {\n                    note = \"This is one big bad fox!\"\n                }\n                setOrganization {\n                    company = \"Bad company\"\n                    title = \"Boss\"\n                    department = \"The bad one\"\n                    jobDescription = \"Be a big bad boss\"\n                    officeLocation = \"It's a secret\"\n                }\n                addPhone {\n                    number = \"(888) 123-4567\"\n                    type = PhoneEntity.Type.WORK\n                }\n                addRelation {\n                    name = \"Bro\"\n                    type = RelationEntity.Type.BROTHER\n                }\n                setSipAddress {\n                    sipAddress = \"sip:user@domain:port\"\n                }\n                addWebsite {\n                    url = \"www.bigbadfox.com\"\n                }\n            }\n            .commit()\n}\n</code></pre> <pre><code>import android.accounts.Account;\nimport android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Insert;\nimport contacts.core.entities.*;\n\npublic class InsertContactsActivity extends Activity {\n\n    Insert.Result insertContact(Account account, NewGroupMembership groupMembership) {\n        NewAddress address = new NewAddress();\n        address.setStreet(\"123 Abc street\");\n        address.setCity(\"Brooklyn\");\n        address.setRegion(\"New York\");\n        address.setPostcode(\"11207\");\n        address.setCountry(\"US\");\n        address.setType(AddressEntity.Type.WORK);\n\n        NewEmail email = new NewEmail();\n        email.setAddress(\"123@abc.com\");\n        email.setType(EmailEntity.Type.WORK);\n\n        NewEvent event = new NewEvent();\n        event.setDate(EventDate.from(1990, 0, 1));\n        event.setType(EventEntity.Type.BIRTHDAY);\n\n        NewIm im = new NewIm();\n        im.setData(\"im@aol.com\");\n        im.setProtocol(ImEntity.Protocol.CUSTOM);\n        im.setCustomProtocol(\"AOL\");\n\n        NewName name = new NewName();\n        name.setPrefix(\"Mr.\");\n        name.setGivenName(\"Big\");\n        name.setMiddleName(\"Bad\");\n        name.setFamilyName(\"Fox\");\n        name.setSuffix(\"Jr\");\n\n        NewNickname nickname = new NewNickname();\n        nickname.setName(\"BIG BAD FOX\");\n\n        NewNote note = new NewNote();\n        note.setNote(\"This is one big bad fox!\");\n\n        NewOrganization organization = new NewOrganization();\n        organization.setCompany(\"Bad company\");\n        organization.setTitle(\"Boss\");\n        organization.setDepartment(\"The bad one\");\n        organization.setJobDescription(\"Be a big bad boss\");\n        organization.setOfficeLocation(\"It's a secret\");\n\n        NewPhone phone = new NewPhone();\n        phone.setNumber(\"(888) 123-4567\");\n        phone.setType(PhoneEntity.Type.WORK);\n\n        NewRelation relation = new NewRelation();\n        relation.setName(\"Bro\");\n        relation.setType(RelationEntity.Type.BROTHER);\n\n        NewSipAddress sipAddress = new NewSipAddress();\n        sipAddress.setSipAddress(\"sip:user@domain:port\");\n\n        NewWebsite website = new NewWebsite();\n        website.setUrl(\"www.bigbadfox.com\");\n\n        NewRawContact rawContact = new NewRawContact();\n        rawContact.setAccount(account);\n        rawContact.getAddresses().add(address);\n        rawContact.getEmails().add(email);\n        rawContact.getEvents().add(event);\n        if (groupMembership != null) {\n            rawContact.getGroupMemberships().add(groupMembership);\n        }\n        rawContact.getIms().add(im);\n        rawContact.setName(name);\n        rawContact.setNickname(nickname);\n        rawContact.setNote(note);\n        rawContact.setOrganization(organization);\n        rawContact.getPhones().add(phone);\n        rawContact.getRelations().add(relation);\n        rawContact.setSipAddress(sipAddress);\n        rawContact.getWebsites().add(website);\n\n        return ContactsFactory.create(this)\n                .insert()\n                .rawContacts(rawContact)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#update-contacts","title":"Update contacts","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.Update\nimport contacts.core.entities.*\nimport contacts.core.util.*\n\nclass UpdateContactsActivity : Activity() {\n\n    fun addEmail(contact: Contact): Update.Result =\n        Contacts(this)\n            .update()\n            .contacts(contact.mutableCopy {\n                addEmail {\n                    address = \"321@xyz.com\"\n                    type = EmailEntity.Type.CUSTOM\n                    label = \"Personal\"\n                }\n            })\n            .commit()\n\n    fun addEmail(rawContact: RawContact): Update.Result =\n        Contacts(this)\n            .update()\n            .rawContacts(rawContact.mutableCopy {\n                addEmail {\n                    address = \"321@xyz.com\"\n                    type = EmailEntity.Type.CUSTOM\n                    label = \"Personal\"\n                }\n            })\n            .commit()\n\n    fun addAnniversary(contact: Contact): Update.Result =\n        Contacts(this)\n            .update()\n            .contacts(contact.mutableCopy {\n                addEvent {\n                    date = EventDate.from(2016, 6, 14)\n                    type = EventEntity.Type.ANNIVERSARY\n                }\n            })\n            .commit()\n\n    fun setFullName(rawContact: RawContact): Update.Result =\n        Contacts(this)\n            .update()\n            .rawContacts(rawContact.mutableCopy {\n                setName {\n                    prefix = \"Mr.\"\n                    givenName = \"Small\"\n                    middleName = \"Bald\"\n                    familyName = \"Eagle\"\n                    suffix = \"Sr\"\n                }\n            })\n            .commit()\n\n    fun setGivenName(rawContact: RawContact): Update.Result =\n        Contacts(this)\n            .update()\n            .rawContacts(rawContact.mutableCopy {\n                name = (name ?: NewName()).also { it.givenName = \"Greg\" }\n            })\n            .commit()\n\n    fun removeGmailEmails(contact: Contact): Update.Result =\n        Contacts(this)\n            .update()\n            .contacts(contact.mutableCopy {\n                emails()\n                    .filter { it.address?.endsWith(\"@gmail.com\", ignoreCase = true) == true }\n                    .forEach { removeEmail(it) }\n            })\n            .commit()\n\n    fun removeEmailsAndPhones(contact: Contact): Update.Result =\n        Contacts(this)\n            .update()\n            .contacts(contact.mutableCopy {\n                removeAllEmails()\n                removeAllPhones()\n            })\n            .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Update;\nimport contacts.core.entities.*;\nimport contacts.core.util.ContactDataKt;\n\npublic class UpdateContactsActivity extends Activity {\n\n    Update.Result addEmail(Contact contact) {\n        MutableContact mutableContact = contact.mutableCopy();\n        ContactDataKt.addEmail(mutableContact, new NewEmail(\n                EmailEntity.Type.CUSTOM,\n                \"Personal\",\n                \"321@xyz.com\"\n        ));\n\n        return ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n\n    Update.Result addEmail(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        mutableRawContact.getEmails().add(new NewEmail(\n                EmailEntity.Type.CUSTOM,\n                \"Personal\",\n                \"321@xyz.com\"\n        ));\n\n        return ContactsFactory.create(this)\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result addAnniversary(Contact contact) {\n        MutableContact mutableContact = contact.mutableCopy();\n        ContactDataKt.addEvent(mutableContact, new NewEvent(\n                EventEntity.Type.ANNIVERSARY,\n                null,\n                EventDate.from(2016, 6, 14)\n        ));\n\n        return ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n\n    Update.Result setFullName(RawContact rawContact) {\n        NewName name = new NewName();\n        name.setPrefix(\"Mr.\");\n        name.setGivenName(\"Small\");\n        name.setMiddleName(\"Bald\");\n        name.setFamilyName(\"Eagle\");\n        name.setSuffix(\"Sr\");\n\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        mutableRawContact.setName(name);\n\n        return ContactsFactory.create(this)\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result setGivenName(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        if (mutableRawContact.getName() != null) {\n            mutableRawContact.getName().setGivenName(\"Greg\");\n        } else {\n            NewName name = new NewName();\n            name.setGivenName(\"Greg\");\n            mutableRawContact.setName(name);\n        }\n\n        return ContactsFactory.create(this)\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result removeGmailEmails(Contact contact) {\n        MutableContact mutableContact = contact.mutableCopy();\n        for (MutableEmailEntity email : ContactDataKt.emailList(mutableContact)) {\n            String emailAddress = email.getAddress();\n            if (emailAddress != null &amp;&amp; emailAddress.toLowerCase().endsWith(\"@gmail.com\")) {\n                ContactDataKt.removeEmail(mutableContact, email);\n            }\n        }\n\n        return ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n\n    Update.Result removeEmailsAndPhones(Contact contact) {\n        MutableContact mutableContact = contact.mutableCopy();\n        ContactDataKt.removeAllEmails(mutableContact);\n        ContactDataKt.removeAllPhones(mutableContact);\n\n        return ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#delete-contacts","title":"Delete contacts","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.Contact\nimport contacts.core.entities.RawContact\n\nclass DeleteContactsActivity : Activity() {\n\n    fun deleteContact(contact: Contact): Delete.Result = Contacts(this)\n        .delete()\n        .contacts(contact)\n        .commit()\n\n    fun deleteContactWithId(contactId: Long): Delete.Result = Contacts(this)\n        .delete()\n        .contactsWithId(contactId)\n        .commit()\n\n    fun deleteNonFavoriteContactsThatHaveANote(): Delete.Result = Contacts(this)\n        .delete()\n        .contactsWhereData {\n            (Contact.Options.Starred equalTo false) and Note.Note.isNotNullOrEmpty()\n        }\n        .commit()\n\n    fun deleteRawContact(rawContact: RawContact): Delete.Result = Contacts(this)\n        .delete()\n        .rawContacts(rawContact)\n        .commit()\n\n    fun deleteRawContactWithId(rawContactId: Long): Delete.Result = Contacts(this)\n        .delete()\n        .rawContactsWithId(rawContactId)\n        .commit()\n\n    fun deleteRawContactsInTheSetThatHaveANote(rawContactIds: Set&lt;Long&gt;): Delete.Result =\n        Contacts(this)\n            .delete()\n            .rawContactsWhereData {\n                (RawContact.Id `in` rawContactIds) and Note.Note.isNotNullOrEmpty()\n            }\n            .commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\n\nimport android.app.Activity;\n\nimport java.util.Set;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Delete;\nimport contacts.core.Fields;\nimport contacts.core.entities.Contact;\nimport contacts.core.entities.RawContact;\n\npublic class DeleteContactsActivity extends Activity {\n\n    Delete.Result deleteContact(Contact contact) {\n        return ContactsFactory.create(this)\n                .delete()\n                .contacts(contact)\n                .commit();\n    }\n\n    Delete.Result deleteContactWithId(Long contactId) {\n        return ContactsFactory.create(this)\n                .delete()\n                .contactsWithId(contactId)\n                .commit();\n    }\n\n    Delete.Result deleteNonFavoriteContactsThatHaveANote() {\n        return ContactsFactory.create(this)\n                .delete()\n                .contactsWhereData(\n                        and(\n                                equalTo(Fields.Contact.Options.Starred, false),\n                                isNotNullOrEmpty(Fields.Note.Note)\n                        )\n                )\n                .commit();\n    }\n\n    Delete.Result deleteRawContact(RawContact rawContact) {\n        return ContactsFactory.create(this)\n                .delete()\n                .rawContacts(rawContact)\n                .commit();\n    }\n\n    Delete.Result deleteRawContactWithId(Long rawContactId) {\n        return ContactsFactory.create(this)\n                .delete()\n                .rawContactsWithId(rawContactId)\n                .commit();\n    }\n\n    Delete.Result deleteRawContactsInTheSetThatHaveANote(Set&lt;Long&gt; rawContactIds) {\n        return ContactsFactory.create(this)\n                .delete()\n                .rawContactsWhereData(\n                        and(\n                                in(Fields.RawContact.Id, rawContactIds),\n                                isNotNullOrEmpty(Fields.Note.Note)\n                        )\n                )\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#data","title":"Data","text":""},{"location":"cheatsheet/#query-specific-data-kinds","title":"Query specific data kinds","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.*\n\nclass QueryDataActivity : Activity() {\n\n    fun getAllEmails(): List&lt;Email&gt; = Contacts(this).data().query().emails().find()\n\n    fun getEmailsForAccount(account: Account): List&lt;Email&gt; =\n        Contacts(this).data().query().emails().accounts(account).find()\n\n    fun getGmailEmailsInDescendingOrder(): List&lt;Email&gt; = Contacts(this)\n        .data()\n        .query()\n        .emails()\n        .where { Email.Address endsWith \"@gmail.com\" }\n        .orderBy(Fields.Email.Address.desc(ignoreCase = true))\n        .find()\n\n    fun getWorkPhones(): List&lt;Phone&gt; = Contacts(this)\n        .data()\n        .query()\n        .phones()\n        .where { Phone.Type equalTo PhoneEntity.Type.WORK }\n        .find()\n\n    fun getUpTo10Mothers(): List&lt;Relation&gt; = Contacts(this)\n        .data()\n        .query()\n        .relations()\n        .where { Relation.Type equalTo RelationEntity.Type.MOTHER }\n        .limit(10)\n        .find()\n\n    fun getContactBirthday(contactId: Long): Event? = Contacts(this)\n        .data()\n        .query()\n        .events()\n        .where { (Contact.Id equalTo contactId) and (Event.Type equalTo EventEntity.Type.BIRTHDAY) }\n        .find()\n        .firstOrNull()\n}\n</code></pre> <pre><code>import static contacts.core.OrderByKt.desc;\nimport static contacts.core.WhereKt.*;\n\nimport android.accounts.Account;\nimport android.app.Activity;\n\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Fields;\nimport contacts.core.data.DataQuery;\nimport contacts.core.entities.*;\n\npublic class QueryDataActivity extends Activity {\n\n    List&lt;Email&gt; getAllEmails() {\n        return ContactsFactory.create(this).data().query().emails().find();\n    }\n\n    List&lt;Email&gt; getEmailsForAccount(Account account) {\n        return ContactsFactory.create(this).data().query().emails().accounts(account).find();\n    }\n\n    List&lt;Email&gt; getGmailEmailsInDescendingOrder() {\n        return ContactsFactory.create(this)\n                .data()\n                .query()\n                .emails()\n                .where(endsWith(Fields.Email.Address, \"@gmail.com\"))\n                .orderBy(desc(Fields.Email.Address, true))\n                .find();\n    }\n\n    List&lt;Phone&gt; getWorkPhones() {\n        return ContactsFactory.create(this)\n                .data()\n                .query()\n                .phones()\n                .where(equalTo(Fields.Phone.Type, PhoneEntity.Type.WORK))\n                .find();\n    }\n\n    List&lt;Relation&gt; getUpTo10Mothers() {\n        return ContactsFactory.create(this)\n                .data()\n                .query()\n                .relations()\n                .where(equalTo(Fields.Relation.Type, RelationEntity.Type.MOTHER))\n                .limit(10)\n                .find();\n    }\n\n    @Nullable\n    Event getContactBirthday(Long contactId) {\n        DataQuery.Result&lt;Event&gt; result = ContactsFactory.create(this)\n                .data()\n                .query()\n                .events()\n                .where(\n                        and(\n                                equalTo(Fields.Contact.Id, contactId),\n                                equalTo(Fields.Event.Type, EventEntity.Type.BIRTHDAY)\n                        )\n                )\n                .limit(1)\n                .find();\n        return !result.isEmpty() ? result.get(0) : null;\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#update-existing-sets-of-data","title":"Update existing sets of data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.Fields\nimport contacts.core.data.DataUpdate\nimport contacts.core.entities.*\n\nclass UpdateDataActivity : Activity() {\n\n    fun updateData(data: ExistingDataEntity): DataUpdate.Result =\n        Contacts(this).data().update().data(data).commit()\n\n    fun updateEmailAndPhone(email: Email, phone: Phone): DataUpdate.Result = Contacts(this)\n        .data()\n        .update()\n        .data(\n            email.mutableCopy {\n                address = \"myemail@email.com\"\n            },\n            phone.mutableCopy {\n                number = \"(555) 555-5555\"\n            }\n        )\n        .commit()\n\n    fun updateOnlyMiddleName(changedName: MutableName): DataUpdate.Result = Contacts(this)\n        .data()\n        .update()\n        .data(changedName)\n        .include(Fields.Name.MiddleName)\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Fields;\nimport contacts.core.data.DataUpdate;\nimport contacts.core.entities.*;\n\npublic class UpdateDataActivity extends Activity {\n\n    DataUpdate.Result updateData(ExistingDataEntity data) {\n        return ContactsFactory.create(this).data().update().data(data).commit();\n    }\n\n    DataUpdate.Result updateEmailAndPhone(Email email, Phone phone) {\n        MutableEmail mutableEmail = email.mutableCopy();\n        mutableEmail.setAddress(\"myemail@email.com\");\n\n        MutablePhone mutablePhone = phone.mutableCopy();\n        mutablePhone.setNumber(\"(555) 555-5555\");\n\n        return ContactsFactory.create(this)\n                .data()\n                .update()\n                .data(mutableEmail, mutablePhone)\n                .commit();\n    }\n\n    DataUpdate.Result updateOnlyMiddleName(MutableName changedName) {\n        return ContactsFactory.create(this)\n                .data()\n                .update()\n                .data(changedName)\n                .include(Fields.Name.MiddleName)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#delete-existing-sets-of-data","title":"Delete existing sets of data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.data.DataDelete\nimport contacts.core.entities.*\nimport contacts.core.equalTo\n\nclass DeleteDataActivity : Activity() {\n\n    fun deleteData(data: ExistingDataEntity): DataDelete.Result =\n        Contacts(this).data().delete().data(data).commit()\n\n    fun deleteEmailsAndPhones(emails: Set&lt;Email&gt;, phones: Set&lt;Phone&gt;): DataDelete.Result =\n        Contacts(this)\n            .data()\n            .delete()\n            .data(emails + phones)\n            .commit()\n\n    fun deleteDataWithId(dataId: Long): DataDelete.Result =\n        Contacts(this).data().delete().dataWithId(dataId).commit()\n\n    fun deleteAllWorkEmails(): DataDelete.Result =\n        Contacts(this)\n            .data()\n            .delete()\n            .dataWhere {\n                Email.Type equalTo EmailEntity.Type.WORK\n            }\n            .commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.equalTo;\n\nimport android.app.Activity;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Fields;\nimport contacts.core.data.DataDelete;\nimport contacts.core.entities.*;\n\npublic class DeleteActivity extends Activity {\n\n    DataDelete.Result deleteData(ExistingDataEntity data) {\n        return ContactsFactory.create(this).data().delete().data(data).commit();\n    }\n\n    DataDelete.Result deleteEmailsAndPhones(List&lt;Email&gt; emails, List&lt;Phone&gt; phones) {\n        List&lt;ExistingDataEntity&gt; dataSet = new ArrayList&lt;&gt;();\n        dataSet.addAll(emails);\n        dataSet.addAll(phones);\n\n        return ContactsFactory.create(this)\n                .data()\n                .delete()\n                .data(dataSet)\n                .commit();\n    }\n\n    DataDelete.Result deleteDataWithId(Long dataId) {\n        return ContactsFactory.create(this).data().delete().dataWithId(dataId).commit();\n    }\n\n    DataDelete.Result deleteAllWorkEmails() {\n        return ContactsFactory.create(this)\n                .data()\n                .delete()\n                .dataWhere(\n                        equalTo(Fields.Email.Type, EmailEntity.Type.WORK)\n                )\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#custom-data","title":"Custom data","text":""},{"location":"cheatsheet/#integrate-the-google-contacts-custom-data","title":"Integrate the Google Contacts custom data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.data.*\nimport contacts.core.entities.*\nimport contacts.core.entities.custom.CustomDataRegistry\nimport contacts.entities.custom.googlecontacts.*\nimport contacts.entities.custom.googlecontacts.fileas.*\nimport contacts.entities.custom.googlecontacts.userdefined.*\n\nclass IntegrateGoogleContactsCustomDataActivity : Activity() {\n\n    val contacts = Contacts(this, false, CustomDataRegistry().register(GoogleContactsRegistration()))\n\n    fun getContactsWithGoogleContactsCustomData(): List&lt;Contact&gt; = contacts\n        .query()\n        .where {\n            GoogleContactsFields.FileAs.Name.isNotNull()\n                .or(GoogleContactsFields.UserDefined.Field.isNotNull())\n        }\n        .find()\n\n    fun insertRawContactWithGoogleContactsCustomData(): Insert.Result = contacts\n        .insert()\n        .rawContact {\n            setFileAs(contacts) {\n                name = \"Lucky\"\n            }\n            addUserDefined(contacts) {\n                field = \"Lucky Field\"\n                label = \"Lucky Label\"\n            }\n        }\n        .commit()\n\n    fun updateRawContactGoogleContactsCustomData(rawContact: RawContact): Update.Result = contacts\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                fileAs(contacts)?.name = \"Unfortunate\"\n                userDefined(contacts).firstOrNull()?.apply {\n                    field = \"Unfortunate Field\"\n                    label = \"Unfortunate Label\"\n                }\n            }\n        )\n        .commit()\n\n    fun deleteGoogleContactsCustomDataFromRawContact(rawContact: RawContact): Update.Result =\n        contacts\n            .update()\n            .rawContacts(\n                rawContact.mutableCopy {\n                    setFileAs(contacts, null)\n                    removeAllUserDefined(contacts)\n                }\n            )\n            .commit()\n\n    fun getAllFileAs(): List&lt;FileAs&gt; = contacts.data().query().fileAs().find()\n\n    fun getAllUserDefined(): List&lt;UserDefined&gt; = contacts.data().query().userDefined().find()\n\n    fun updateFileAsAndUserDefined(\n        fileAs: MutableFileAs, userDefined: MutableUserDefined\n    ): DataUpdate.Result = contacts.data().update().data(fileAs, userDefined).commit()\n\n    fun deleteFileAsAndUserDefined(fileAs: FileAs, userDefined: UserDefined): DataDelete.Result =\n        contacts.data().delete().data(fileAs, userDefined).commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.data.*;\nimport contacts.core.entities.*;\nimport contacts.core.entities.custom.CustomDataRegistry;\nimport contacts.entities.custom.googlecontacts.*;\nimport contacts.entities.custom.googlecontacts.fileas.*;\nimport contacts.entities.custom.googlecontacts.userdefined.*;\n\npublic class IntegrateGoogleContactsCustomDataActivity extends Activity {\n\n    Contacts contacts = ContactsFactory.create(\n            this, false, new CustomDataRegistry().register(new GoogleContactsRegistration())\n    );\n\n    List&lt;Contact&gt; getContactsWithGoogleContactsCustomData() {\n        return contacts\n                .query()\n                .where(\n                        or(\n                                isNotNull(GoogleContactsFields.FileAs.Name),\n                                isNotNull(GoogleContactsFields.UserDefined.Field)\n                        )\n                )\n                .find();\n    }\n\n    Insert.Result insertRawContactWithGoogleContactsCustomData() {\n        NewFileAs newFileAs = new NewFileAs(\"Lucky\");\n        NewUserDefined newUserDefined = new NewUserDefined(\"Lucky Field\", \"Lucky Label\");\n\n        NewRawContact newRawContact = new NewRawContact();\n        RawContactFileAsKt.setFileAs(newRawContact, contacts, newFileAs);\n        RawContactUserDefinedKt.addUserDefined(newRawContact, contacts, newUserDefined);\n\n        return contacts\n                .insert()\n                .rawContacts(newRawContact)\n                .commit();\n    }\n\n    Update.Result updateRawContactGoogleContactsCustomData(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        MutableFileAsEntity mutableFileAs = RawContactFileAsKt.fileAs(mutableRawContact, contacts);\n        MutableUserDefinedEntity mutableUserDefined = \n                RawContactUserDefinedKt.userDefinedList(mutableRawContact, contacts).get(0);\n\n        if (mutableFileAs != null) {\n            mutableFileAs.setName(\"Unfortunate\");\n        }\n        if (mutableUserDefined != null) {\n            mutableUserDefined.setField(\"Unfortunate Field\");\n            mutableUserDefined.setLabel(\"Unfortunate Label\");\n        }\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result deleteGoogleContactsCustomDataFromRawContact(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactFileAsKt.setFileAs(mutableRawContact, contacts, (MutableFileAsEntity) null);\n        RawContactUserDefinedKt.removeAllUserDefined(mutableRawContact, contacts);\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    List&lt;FileAs&gt; getAllFileAs() {\n        return FileAsDataQueryKt.fileAs(contacts.data().query()).find();\n    }\n\n    List&lt;UserDefined&gt; getAllUserDefined() {\n        return UserDefinedDataQueryKt.userDefined(contacts.data().query()).find();\n    }\n\n    DataUpdate.Result updateFileAsAndUserDefined(\n            MutableFileAs fileAs, MutableUserDefined userDefined\n    ) {\n        return contacts.data().update().data(fileAs, userDefined).commit();\n    }\n\n    DataDelete.Result deleteFileAsAndUserDefined(\n            FileAs fileAs, UserDefined userDefined\n    ) {\n        return contacts.data().delete().data(fileAs, userDefined).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#integrate-the-gender-custom-data","title":"Integrate the Gender custom data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.data.*\nimport contacts.core.entities.*\nimport contacts.core.entities.custom.CustomDataRegistry\nimport contacts.entities.custom.gender.*\n\nclass IntegrateGenderCustomDataActivity : Activity() {\n\n    val contacts = Contacts(this, false, CustomDataRegistry().register(GenderRegistration()))\n\n    fun getContactsWithGenderCustomData(): List&lt;Contact&gt; = contacts\n        .query()\n        .where { GenderFields.Type.isNotNull() }\n        .find()\n\n    fun insertRawContactWithGenderCustomData(): Insert.Result = contacts\n        .insert()\n        .rawContact {\n            setGender(contacts) {\n                type = GenderEntity.Type.MALE\n            }\n        }\n        .commit()\n\n    fun updateRawContactGenderCustomData(rawContact: RawContact): Update.Result = contacts\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                gender(contacts)?.type = GenderEntity.Type.FEMALE\n            }\n        )\n        .commit()\n\n    fun deleteGenderCustomDataFromRawContact(rawContact: RawContact): Update.Result =\n        contacts\n            .update()\n            .rawContacts(\n                rawContact.mutableCopy {\n                    setGender(contacts, null)\n                }\n            )\n            .commit()\n\n    fun getAllGender(): List&lt;Gender&gt; = contacts.data().query().genders().find()\n\n    fun updateGender(gender: MutableGender): DataUpdate.Result =\n        contacts.data().update().data(gender).commit()\n\n    fun deleteGender(gender: Gender): DataDelete.Result =\n        contacts.data().delete().data(gender).commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.isNotNull;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.data.*;\nimport contacts.core.entities.*;\nimport contacts.core.entities.custom.CustomDataRegistry;\nimport contacts.entities.custom.gender.*;\n\npublic class IntegrateGenderCustomDataActivity extends Activity {\n\n    Contacts contacts = ContactsFactory.create(\n            this, false, new CustomDataRegistry().register(new GenderRegistration())\n    );\n\n    List&lt;Contact&gt; getContactsWithGenderCustomData() {\n        return contacts\n                .query()\n                .where(isNotNull(GenderFields.Type))\n                .find();\n    }\n\n    Insert.Result insertRawContactWithGenderCustomData() {\n        NewGender newGender = new NewGender(GenderEntity.Type.MALE);\n\n        NewRawContact newRawContact = new NewRawContact();\n        RawContactGenderKt.setGender(newRawContact, contacts, newGender);\n\n        return contacts\n                .insert()\n                .rawContacts(newRawContact)\n                .commit();\n    }\n\n    Update.Result updateRawContactGenderCustomData(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        MutableGenderEntity mutableGender = RawContactGenderKt.gender(mutableRawContact, contacts);\n        if (mutableGender != null) {\n            mutableGender.setType(GenderEntity.Type.FEMALE);\n        }\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result deleteGenderCustomDataFromRawContact(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactGenderKt.setGender(mutableRawContact, contacts, (MutableGenderEntity) null);\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    List&lt;Gender&gt; getAllGenders() {\n        return GenderDataQueryKt.genders(contacts.data().query()).find();\n    }\n\n    DataUpdate.Result updateGender(MutableGender gender) {\n        return contacts.data().update().data(gender).commit();\n    }\n\n    DataDelete.Result deleteGender(Gender gender) {\n        return contacts.data().delete().data(gender).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#integrate-the-handle-name-custom-data","title":"Integrate the Handle Name custom data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.data.*\nimport contacts.core.entities.*\nimport contacts.core.entities.custom.CustomDataRegistry\nimport contacts.entities.custom.handlename.*\n\nclass IntegrateHandleNameCustomDataActivity : Activity() {\n\n    val contacts = Contacts(this, false, CustomDataRegistry().register(HandleNameRegistration()))\n\n    fun getContactsWithHandleNameCustomData(): List&lt;Contact&gt; = contacts\n        .query()\n        .where { HandleNameFields.Handle.isNotNull() }\n        .find()\n\n    fun insertRawContactWithHandleNameCustomData(): Insert.Result = contacts\n        .insert()\n        .rawContact {\n            addHandleName(contacts) {\n                handle = \"The Beauty\"\n            }\n        }\n        .commit()\n\n    fun updateRawContactHandleNameCustomData(rawContact: RawContact): Update.Result = contacts\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                handleNames(contacts).firstOrNull()?.handle = \"The Beast\"\n            }\n        )\n        .commit()\n\n    fun deleteHandleNameCustomDataFromRawContact(rawContact: RawContact): Update.Result =\n        contacts\n            .update()\n            .rawContacts(\n                rawContact.mutableCopy {\n                    removeAllHandleNames(contacts)\n                }\n            )\n            .commit()\n\n    fun getAllHandleName(): List&lt;HandleName&gt; = contacts.data().query().handleNames().find()\n\n    fun updateHandleName(handleName: MutableHandleName): DataUpdate.Result =\n        contacts.data().update().data(handleName).commit()\n\n    fun deleteHandleName(handleName: HandleName): DataDelete.Result =\n        contacts.data().delete().data(handleName).commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.isNotNull;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.data.*;\nimport contacts.core.entities.*;\nimport contacts.core.entities.custom.CustomDataRegistry;\nimport contacts.entities.custom.handlename.*;\n\npublic class IntegrateHandleNameCustomDataActivity extends Activity {\n\n    Contacts contacts = ContactsFactory.create(\n            this, false, new CustomDataRegistry().register(new HandleNameRegistration())\n    );\n\n    List&lt;Contact&gt; getContactsWithHandleNameCustomData() {\n        return contacts\n                .query()\n                .where(isNotNull(HandleNameFields.Handle))\n                .find();\n    }\n\n    Insert.Result insertRawContactWithHandleNameCustomData() {\n        NewHandleName newHandleName = new NewHandleName(\"The Beauty\");\n\n        NewRawContact newRawContact = new NewRawContact();\n        RawContactHandleNameKt.addHandleName(newRawContact, contacts, newHandleName);\n\n        return contacts\n                .insert()\n                .rawContacts(newRawContact)\n                .commit();\n    }\n\n    Update.Result updateRawContactHandleNameCustomData(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        MutableHandleNameEntity mutableHandleName =\n                RawContactHandleNameKt.handleNameList(mutableRawContact, contacts).get(0);\n        if (mutableHandleName != null) {\n            mutableHandleName.setHandle(\"The Beast\");\n        }\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result deleteHandleNameCustomDataFromRawContact(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactHandleNameKt.removeAllHandleNames(mutableRawContact, contacts);\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    List&lt;HandleName&gt; getAllHandleNames() {\n        return HandleNameDataQueryKt.handleNames(contacts.data().query()).find();\n    }\n\n    DataUpdate.Result updateHandleName(MutableHandleName handleName) {\n        return contacts.data().update().data(handleName).commit();\n    }\n\n    DataDelete.Result deleteHandleName(HandleName handleName) {\n        return contacts.data().delete().data(handleName).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#integrate-the-pokemon-custom-data","title":"Integrate the Pokemon custom data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.data.*\nimport contacts.core.entities.*\nimport contacts.core.entities.custom.CustomDataRegistry\nimport contacts.entities.custom.pokemon.*\n\nclass IntegratePokemonCustomDataActivity : Activity() {\n\n    val contacts = Contacts(this, false, CustomDataRegistry().register(PokemonRegistration()))\n\n    fun getContactsWithPokemonCustomData(): List&lt;Contact&gt; = contacts\n        .query()\n        .where { PokemonFields.Name.isNotNull() or PokemonFields.PokeApiId.isNotNull() }\n        .find()\n\n    fun insertRawContactWithPokemonCustomData(): Insert.Result = contacts\n        .insert()\n        .rawContact {\n            addPokemon(contacts) {\n                name = \"ditto\"\n                nickname = \"copy-cat\"\n                level = 24\n                pokeApiId = 132\n            }\n        }\n        .commit()\n\n    fun updateRawContactPokemonCustomData(rawContact: RawContact): Update.Result = contacts\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                pokemons(contacts).firstOrNull()?.apply {\n                    nickname = \"OP\"\n                    level = 99\n                }\n            }\n        )\n        .commit()\n\n    fun deletePokemonCustomDataFromRawContact(rawContact: RawContact): Update.Result =\n        contacts\n            .update()\n            .rawContacts(\n                rawContact.mutableCopy {\n                    removeAllPokemons(contacts)\n                }\n            )\n            .commit()\n\n    fun getAllPokemon(): List&lt;Pokemon&gt; = contacts.data().query().pokemons().find()\n\n    fun updatePokemon(pokemon: MutablePokemon): DataUpdate.Result =\n        contacts.data().update().data(pokemon).commit()\n\n    fun deletePokemon(pokemon: Pokemon): DataDelete.Result =\n        contacts.data().delete().data(pokemon).commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.data.*;\nimport contacts.core.entities.*;\nimport contacts.core.entities.custom.CustomDataRegistry;\nimport contacts.entities.custom.pokemon.*;\n\npublic class IntegratePokemonCustomDataActivity extends Activity {\n\n    Contacts contacts = ContactsFactory.create(\n            this, false, new CustomDataRegistry().register(new PokemonRegistration())\n    );\n\n    List&lt;Contact&gt; getContactsWithPokemonCustomData() {\n        return contacts\n                .query()\n                .where(or(isNotNull(PokemonFields.Name), isNotNull(PokemonFields.PokeApiId)))\n                .find();\n    }\n\n    Insert.Result insertRawContactWithPokemonCustomData() {\n        NewPokemon newPokemon = new NewPokemon();\n        newPokemon.setName(\"ditto\");\n        newPokemon.setNickname(\"copy-cat\");\n        newPokemon.setLevel(24);\n        newPokemon.setPokeApiId(132);\n\n        NewRawContact newRawContact = new NewRawContact();\n        RawContactPokemonKt.addPokemon(newRawContact, contacts, newPokemon);\n\n        return contacts\n                .insert()\n                .rawContacts(newRawContact)\n                .commit();\n    }\n\n    Update.Result updateRawContactPokemonCustomData(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        MutablePokemonEntity mutablePokemon =\n                RawContactPokemonKt.pokemonList(mutableRawContact, contacts).get(0);\n        if (mutablePokemon != null) {\n            mutablePokemon.setNickname(\"OP\");\n            mutablePokemon.setLevel(99);\n        }\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result deletePokemonCustomDataFromRawContact(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactPokemonKt.removeAllPokemons(mutableRawContact, contacts);\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    List&lt;Pokemon&gt; getAllPokemons() {\n        return PokemonDataQueryKt.pokemons(contacts.data().query()).find();\n    }\n\n    DataUpdate.Result updatePokemon(MutablePokemon pokemon) {\n        return contacts.data().update().data(pokemon).commit();\n    }\n\n    DataDelete.Result deletePokemon(Pokemon pokemon) {\n        return contacts.data().delete().data(pokemon).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#integrate-the-rpg-custom-data","title":"Integrate the RPG custom data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.data.*\nimport contacts.core.entities.*\nimport contacts.core.entities.custom.CustomDataRegistry\nimport contacts.entities.custom.rpg.*\nimport contacts.entities.custom.rpg.profession.*\nimport contacts.entities.custom.rpg.stats.*\n\nclass IntegrateRpgCustomDataActivity : Activity() {\n\n    val contacts = Contacts(this, false, CustomDataRegistry().register(RpgRegistration()))\n\n    fun getContactsWithRpgCustomData(): List&lt;Contact&gt; = contacts\n        .query()\n        .where {\n            RpgFields.Profession.Title.isNotNull() or RpgFields.Stats.Level.isNotNull()\n        }\n        .find()\n\n    fun insertRawContactWithRpgCustomData(): Insert.Result = contacts\n        .insert()\n        .rawContact {\n            setRpgProfession(contacts) {\n                title = \"Berserker\"\n            }\n            setRpgStats(contacts) {\n                level = 78\n                speed = 500\n                strength = 789\n                intelligence = 123\n                luck = 369\n            }\n        }\n        .commit()\n\n    fun updateRawContactRpgCustomData(rawContact: RawContact): Update.Result = contacts\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                rpgProfession(contacts)?.title = \"Mage\"\n                rpgStats(contacts)?.apply {\n                    speed = 250\n                    strength = 69\n                    intelligence = 863\n                }\n            }\n        )\n        .commit()\n\n    fun deleteRpgCustomDataFromRawContact(rawContact: RawContact): Update.Result =\n        contacts\n            .update()\n            .rawContacts(\n                rawContact.mutableCopy {\n                    setRpgProfession(contacts, null)\n                    setRpgStats(contacts, null)\n                }\n            )\n            .commit()\n\n    fun getAllRpgProfessions(): List&lt;RpgProfession&gt; = contacts.data().query().rpgProfession().find()\n\n    fun getAllRpgStats(): List&lt;RpgStats&gt; = contacts.data().query().rpgStats().find()\n\n    fun updateRpgProfessionAndStats(\n        profession: RpgProfession, rpgStats: RpgStats\n    ): DataUpdate.Result = contacts.data().update().data(profession, rpgStats).commit()\n\n    fun deleteFileAsAndUserDefined(\n        profession: RpgProfession, rpgStats: RpgStats\n    ): DataDelete.Result = contacts.data().delete().data(profession, rpgStats).commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.data.*;\nimport contacts.core.entities.*;\nimport contacts.core.entities.custom.CustomDataRegistry;\nimport contacts.entities.custom.rpg.*;\nimport contacts.entities.custom.rpg.profession.*;\nimport contacts.entities.custom.rpg.stats.*;\n\npublic class IntegrateRpgCustomDataActivity extends Activity {\n\n    Contacts contacts = ContactsFactory.create(\n            this, false, new CustomDataRegistry().register(new RpgRegistration())\n    );\n\n    List&lt;Contact&gt; getContactsWithRpgCustomData() {\n        return contacts\n                .query()\n                .where(or(isNotNull(RpgFields.Profession.Title), isNotNull(RpgFields.Stats.Level)))\n                .find();\n    }\n\n    Insert.Result insertRawContactWithRpgCustomData() {\n        NewRpgProfession newRpgProfession = new NewRpgProfession(\"Berserker\");\n        NewRpgStats newRpgStats = new NewRpgStats();\n        newRpgStats.setLevel(78);\n        newRpgStats.setSpeed(500);\n        newRpgStats.setStrength(789);\n        newRpgStats.setIntelligence(123);\n        newRpgStats.setLuck(369);\n\n        NewRawContact newRawContact = new NewRawContact();\n        RawContactRpgProfessionKt.setRpgProfession(newRawContact, contacts, newRpgProfession);\n        RawContactRpgStatsKt.setRpgStats(newRawContact, contacts, newRpgStats);\n\n        return contacts\n                .insert()\n                .rawContacts(newRawContact)\n                .commit();\n    }\n\n    Update.Result updateRawContactRpgCustomData(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        MutableRpgProfessionEntity mutableRpgProfession =\n                RawContactRpgProfessionKt.rpgProfession(mutableRawContact, contacts);\n        MutableRpgStatsEntity mutableRpgStats =\n                RawContactRpgStatsKt.rpgStats(mutableRawContact, contacts);\n\n        if (mutableRpgProfession != null) {\n            mutableRpgProfession.setTitle(\"Mage\");\n        }\n        if (mutableRpgStats != null) {\n            mutableRpgStats.setSpeed(250);\n            mutableRpgStats.setStrength(69);\n            mutableRpgStats.setIntelligence(863);\n        }\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result deleteRpgCustomDataFromRawContact(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactRpgProfessionKt.setRpgProfession(mutableRawContact, contacts, (MutableRpgProfession) null);\n        RawContactRpgStatsKt.setRpgStats(mutableRawContact, contacts, (MutableRpgStats) null);\n\n        return contacts\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    List&lt;RpgProfession&gt; getAllRpgProfessions() {\n        return RpgProfessionDataQueryKt.rpgProfession(contacts.data().query()).find();\n    }\n\n    List&lt;RpgStats&gt; getAllRpgStats() {\n        return RpgStatsDataQueryKt.rpgStats(contacts.data().query()).find();\n    }\n\n    DataUpdate.Result updateRpgProfessionAndRpgStats(\n            MutableRpgProfession rpgProfession, MutableRpgStats rpgStats\n    ) {\n        return contacts.data().update().data(rpgProfession, rpgStats).commit();\n    }\n\n    DataDelete.Result deleteRpgProfessionAndRpgStats(\n            RpgProfession rpgProfession, RpgStats rpgStats\n    ) {\n        return contacts.data().delete().data(rpgProfession, rpgStats).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#groups","title":"Groups","text":""},{"location":"cheatsheet/#query-groups","title":"Query groups","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.*\n\nclass QueryGroupsActivity : Activity() {\n\n    fun getAllGroupsFromAllAccounts(): List&lt;Group&gt; = Contacts(this).groups().query().find()\n\n    fun getGroupsFromAccount(account: Account?): List&lt;Group&gt; =\n        Contacts(this).groups().query().accounts(account).find()\n\n    fun getGroupsById(groupsIds: List&lt;Long&gt;): List&lt;Group&gt; = Contacts(this)\n        .groups()\n        .query()\n        .where { Id `in` groupsIds }\n        .find()\n\n    fun getGroupsByTitle(title: String): List&lt;Group&gt; = Contacts(this)\n        .groups()\n        .query()\n        .where { Title contains title }\n        .find()\n\n    fun getGroupsOfGroupMemberships(groupMemberships: List&lt;GroupMembership&gt;): List&lt;Group&gt; =\n        Contacts(this)\n            .groups()\n            .query()\n            .where { Id `in` groupMemberships.mapNotNull { it.groupId } }\n            .find()\n\n    fun getSystemGroups(account: Account): List&lt;Group&gt; = Contacts(this)\n        .groups()\n        .query()\n        .accounts(account)\n        .where { SystemId.isNotNull() }\n        .find()\n\n    fun getUserCreatedGroups(account: Account): List&lt;Group&gt; = Contacts(this)\n        .groups()\n        .query()\n        .accounts(account)\n        .find()\n        .filter { !it.isSystemGroup }\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\n\nimport android.accounts.Account;\nimport android.app.Activity;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.entities.*;\n\npublic class QueryGroupsActivity extends Activity {\n\n    List&lt;Group&gt; getAllGroupsFromAllAccounts() {\n        return ContactsFactory.create(this).groups().query().find();\n    }\n\n    List&lt;Group&gt; getGroupsFromAccount(Account account) {\n        return ContactsFactory.create(this).groups().query().accounts(account).find();\n    }\n\n    List&lt;Group&gt; getGroupsById(List&lt;Long&gt; groupsIds) {\n        return ContactsFactory.create(this)\n                .groups()\n                .query()\n                .where(in(GroupsFields.Id, groupsIds))\n                .find();\n    }\n\n    List&lt;Group&gt; getGroupsByTitle(String title) {\n        return ContactsFactory.create(this)\n                .groups()\n                .query()\n                .where(contains(GroupsFields.Title, title))\n                .find();\n    }\n\n    List&lt;Group&gt; getGroupsByGroupMembership(List&lt;GroupMembership&gt; groupMemberships) {\n        List&lt;Long&gt; groupsIds = new ArrayList&lt;&gt;();\n        for (GroupMembership groupMembership : groupMemberships) {\n            if (groupMembership.getGroupId() != null) {\n                groupsIds.add(groupMembership.getGroupId());\n            }\n        }\n\n        return ContactsFactory.create(this)\n                .groups()\n                .query()\n                .where(in(GroupsFields.Id, groupsIds))\n                .find();\n    }\n\n    List&lt;Group&gt; getSystemGroups(Account account) {\n        return ContactsFactory.create(this)\n                .groups()\n                .query()\n                .accounts(account)\n                .where(isNotNull(GroupsFields.SystemId))\n                .find();\n    }\n\n    List&lt;Group&gt; getUserCreatedGroups(Account account) {\n        List&lt;Group&gt; groups = ContactsFactory.create(this)\n                .groups()\n                .query()\n                .accounts(account)\n                .find();\n\n        List&lt;Group&gt; userCreatedGroups = new ArrayList&lt;&gt;();\n        for (Group group : groups) {\n            if (!group.isSystemGroup()) {\n                userCreatedGroups.add(group);\n            }\n        }\n\n        return userCreatedGroups;\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#insert-groups","title":"Insert groups","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.NewGroup\nimport contacts.core.groups.GroupsInsert\n\nclass InsertGroupsActivity : Activity() {\n\n    fun insertGroup(title: String, account: Account): GroupsInsert.Result =\n        Contacts(this).groups().insert().group(title, account).commit()\n\n    fun insertGroups(groups: List&lt;NewGroup&gt;): GroupsInsert.Result =\n        Contacts(this).groups().insert().groups(groups).commit()\n}\n</code></pre> <pre><code>import contacts.core.ContactsFactory;\nimport contacts.core.entities.NewGroup;\nimport contacts.core.groups.GroupsInsert;\n\npublic class InsertGroupsActivity extends Activity {\n\n    GroupsInsert.Result insertGroup(String title, Account account) {\n        return ContactsFactory.create(this).groups().insert().group(title, account).commit();\n    }\n\n    GroupsInsert.Result insertGroups(List&lt;NewGroup&gt; groups) {\n        return ContactsFactory.create(this).groups().insert().groups(groups).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#update-groups","title":"Update groups","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.Group\nimport contacts.core.groups.GroupsUpdate\n\nclass UpdateGroupsActivity : Activity() {\n\n    fun updateGroup(group: Group): GroupsUpdate.Result = Contacts(this)\n        .groups()\n        .update()\n        .groups(\n            group.mutableCopy {\n                title = \"Bad love\"\n            }\n        )\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.*;\nimport contacts.core.groups.GroupsUpdate;\n\npublic class UpdateGroupsActivity extends Activity {\n\n    GroupsUpdate.Result updateGroup(Group group) {\n        MutableGroup mutableGroup = group.mutableCopy();\n        mutableGroup.setTitle(\"Bad love\");\n\n        return ContactsFactory.create(this)\n                .groups()\n                .update()\n                .groups(mutableGroup)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#delete-groups","title":"Delete groups","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.Group\nimport contacts.core.groups.GroupsDelete\n\nclass DeleteGroupsActivity : Activity() {\n\n    fun deleteGroups(groups: List&lt;Group&gt;): GroupsDelete.Result =\n        Contacts(this).groups().delete().groups(groups).commit()\n\n    fun deleteGroupWithId(groupId: Long): GroupsDelete.Result =\n        Contacts(this).groups().delete().groupsWithId(groupId).commit()\n\n    fun deleteUserCreatedGroupFromAllGoogleAccounts(): GroupsDelete.Result = Contacts(this)\n        .groups()\n        .delete()\n        .groupsWhere { AccountType equalTo \"com.google\" }\n        .commit()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.equalTo;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.GroupsFields;\nimport contacts.core.entities.Group;\nimport contacts.core.groups.GroupsDelete;\n\npublic class DeleteGroupsActivity extends Activity {\n\n    GroupsDelete.Result deleteGroups(List&lt;Group&gt; groups) {\n        return ContactsFactory.create(this).groups().delete().groups(groups).commit();\n    }\n\n    GroupsDelete.Result deleteGroupWithId(long groupId) {\n        return ContactsFactory.create(this).groups().delete().groupsWithId(groupId).commit();\n    }\n\n    GroupsDelete.Result deleteUserCreatedGroupFromAllGoogleAccounts() {\n        return ContactsFactory.create(this)\n                .groups()\n                .delete()\n                .groupsWhere(equalTo(GroupsFields.AccountType, \"com.google\"))\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#profile","title":"Profile","text":""},{"location":"cheatsheet/#query-device-owner-contact-profile","title":"Query device owner Contact profile","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.Contact\n\nclass QueryProfileActivity : Activity() {\n\n    fun getProfile(): Contact? = Contacts(this).profile().query().find().contact\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.Contact;\n\npublic class QueryProfileActivity extends Activity {\n\n    Contact getProfile() {\n        return ContactsFactory.create(this).profile().query().find().getContact();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#insert-device-owner-contact-profile","title":"Insert device owner Contact profile","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.*\nimport contacts.core.profile.ProfileInsert\nimport contacts.core.util.*\n\nclass InsertProfileActivity : Activity() {\n\n    fun insertProfile(): ProfileInsert.Result = Contacts(this)\n        .profile()\n        .insert()\n        .rawContact {\n            addAddress {\n                street = \"321 Xyz street\"\n                city = \"Brooklyn\"\n                region = \"New York\"\n                postcode = \"11207\"\n                country = \"US\"\n                type = AddressEntity.Type.WORK\n            }\n            addEmail {\n                address = \"321@xyz.com\"\n                type = EmailEntity.Type.WORK\n            }\n            addEvent {\n                date = EventDate.from(1990, 0, 1)\n                type = EventEntity.Type.BIRTHDAY\n            }\n            addIm {\n                data = \"im@aol.com\"\n                protocol = ImEntity.Protocol.CUSTOM\n                customProtocol = \"AOL\"\n            }\n            setName {\n                prefix = \"Mr.\"\n                givenName = \"Small\"\n                middleName = \"Goody\"\n                familyName = \"Dog\"\n                suffix = \"Jr\"\n            }\n            setNickname {\n                name = \"TINY DOMESTICATED ANIMAL\"\n            }\n            setNote {\n                note = \"This is one furry friend!\"\n            }\n            setOrganization {\n                company = \"Good company\"\n                title = \"Teammate\"\n                department = \"The good one\"\n                jobDescription = \"Be a good citizen\"\n                officeLocation = \"It's public\"\n            }\n            addPhone {\n                number = \"(888) 321-7654\"\n                type = PhoneEntity.Type.WORK\n            }\n            addRelation {\n                name = \"Bro\"\n                type = RelationEntity.Type.BROTHER\n            }\n            setSipAddress {\n                sipAddress = \"sip:user@domain:port\"\n            }\n            addWebsite {\n                url = \"www.smalltinycompany.com\"\n            }\n        }\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.*;\nimport contacts.core.profile.ProfileInsert;\n\npublic class InsertProfileActivity extends Activity {\n\n    ProfileInsert.Result insertProfile() {\n        NewAddress address = new NewAddress();\n        address.setStreet(\"Xyz Abc street\");\n        address.setCity(\"Brooklyn\");\n        address.setRegion(\"New York\");\n        address.setPostcode(\"11207\");\n        address.setCountry(\"US\");\n        address.setType(AddressEntity.Type.WORK);\n\n        NewEmail email = new NewEmail();\n        email.setAddress(\"321@xyz.com\");\n        email.setType(EmailEntity.Type.WORK);\n\n        NewEvent event = new NewEvent();\n        event.setDate(EventDate.from(1990, 0, 1));\n        event.setType(EventEntity.Type.BIRTHDAY);\n\n        NewIm im = new NewIm();\n        im.setData(\"im@aol.com\");\n        im.setProtocol(ImEntity.Protocol.CUSTOM);\n        im.setCustomProtocol(\"AOL\");\n\n        NewName name = new NewName();\n        name.setPrefix(\"Mr.\");\n        name.setGivenName(\"Small\");\n        name.setMiddleName(\"Goody\");\n        name.setFamilyName(\"Dog\");\n        name.setSuffix(\"Jr\");\n\n        NewNickname nickname = new NewNickname();\n        nickname.setName(\"TINY DOMESTICATED ANIMAL\");\n\n        NewNote note = new NewNote();\n        note.setNote(\"This is one furry friend!\");\n\n        NewOrganization organization = new NewOrganization();\n        organization.setCompany(\"Good company\");\n        organization.setTitle(\"Teammate\");\n        organization.setDepartment(\"The good one\");\n        organization.setJobDescription(\"Be a good citizen\");\n        organization.setOfficeLocation(\"It's public\");\n\n        NewPhone phone = new NewPhone();\n        phone.setNumber(\"(888) 321-7654\");\n        phone.setType(PhoneEntity.Type.WORK);\n\n        NewRelation relation = new NewRelation();\n        relation.setName(\"Bro\");\n        relation.setType(RelationEntity.Type.BROTHER);\n\n        NewSipAddress sipAddress = new NewSipAddress();\n        sipAddress.setSipAddress(\"sip:user@domain:port\");\n\n        NewWebsite website = new NewWebsite();\n        website.setUrl(\"www.smalltinycompany.com\");\n\n        NewRawContact rawContact = new NewRawContact();\n        rawContact.getAddresses().add(address);\n        rawContact.getEmails().add(email);\n        rawContact.getEvents().add(event);\n        rawContact.getIms().add(im);\n        rawContact.setName(name);\n        rawContact.setNickname(nickname);\n        rawContact.setNote(note);\n        rawContact.setOrganization(organization);\n        rawContact.getPhones().add(phone);\n        rawContact.getRelations().add(relation);\n        rawContact.setSipAddress(sipAddress);\n        rawContact.getWebsites().add(website);\n\n        return ContactsFactory.create(this)\n                .profile()\n                .insert()\n                .rawContact(rawContact)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#update-device-owner-contact-profile","title":"Update device owner Contact profile","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.*\nimport contacts.core.profile.ProfileUpdate\nimport contacts.core.util.*\n\nclass UpdateProfileActivity : Activity() {\n\n    fun updateProfile(profile: Contact): ProfileUpdate.Result = Contacts(this)\n        .profile()\n        .update()\n        .contact(profile.mutableCopy {\n            setName {\n                displayName = \"I am the phone owner\"\n            }\n            addEmail {\n                type = EmailEntity.Type.CUSTOM\n                label = \"Profile Email\"\n                address = \"phone@owner.com\"\n            }\n            removeAllPhones()\n            setOrganization(null)\n        })\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.*;\nimport contacts.core.profile.ProfileUpdate;\nimport contacts.core.util.ContactDataKt;\n\npublic class UpdateProfileActivity extends Activity {\n\n    ProfileUpdate.Result updateProfile(Contact profile) {\n        MutableContact mutableProfile = profile.mutableCopy();\n        ContactDataKt.setName(mutableProfile, new NewName(\"I am the phone owner\"));\n        ContactDataKt.addEmail(mutableProfile, new NewEmail(\n                EmailEntity.Type.CUSTOM,\n                \"Profile Email\",\n                \"phone@owner.com\"\n        ));\n        ContactDataKt.removeAllPhones(mutableProfile);\n        ContactDataKt.setOrganization(mutableProfile, (MutableOrganizationEntity) null);\n\n        return ContactsFactory.create(this)\n                .profile()\n                .update()\n                .contact(mutableProfile)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#delete-device-owner-contact-profile","title":"Delete device owner Contact profile","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.profile.ProfileDelete\n\nclass DeleteProfileActivity : Activity() {\n\n    fun deleteProfile(): ProfileDelete.Result = Contacts(this).profile().delete().contact().commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.profile.ProfileDelete;\n\npublic class DeleteProfileActivity extends Activity {\n\n    ProfileDelete.Result deleteProfile() {\n        return ContactsFactory.create(this).profile().delete().contact().commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#accounts","title":"Accounts","text":""},{"location":"cheatsheet/#query-for-accounts","title":"Query for Accounts","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.Contacts\n\nclass QueryAccountsActivity : Activity() {\n\n    fun getAllAccounts(): List&lt;Account&gt; = Contacts(this).accounts().query().find()\n\n    fun getAllGoogleAccounts(): List&lt;Account&gt; = Contacts(this)\n        .accounts()\n        .query()\n        .withTypes(\"com.google\")\n        .find()\n}\n</code></pre> <pre><code>import android.accounts.Account;\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\n\npublic class QueryAccountsActivity extends Activity {\n\n    List&lt;Account&gt; getAllAccounts() {\n        return ContactsFactory.create(this).accounts().query().find();\n    }\n\n    List&lt;Account&gt; getAllGoogleAccounts() {\n        return ContactsFactory.create(this)\n                .accounts()\n                .query()\n                .withTypes(\"com.google\")\n                .find();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#move-rawcontacts-across-accounts","title":"Move RawContacts across Accounts","text":"KotlinJava <pre><code>import android.accounts.Account\nimport android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.accounts.MoveRawContactsToAccounts\nimport contacts.core.entities.RawContact\n\nclass MoveRawContactsAcrossAccountsActivity : Activity() {\n\n    fun moveRawContactToAccount(\n        rawContact: RawContact, account: Account\n    ): MoveRawContactsToAccounts.Result = Contacts(this)\n        .accounts()\n        .move()\n        .rawContactsTo(account, rawContact)\n        .commit()\n}\n</code></pre> <pre><code>import android.accounts.Account;\nimport android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.accounts.MoveRawContactsToAccounts;\nimport contacts.core.entities.RawContact;\n\npublic class MoveRawContactsAcrossAccountsActivity extends Activity {\n\n    MoveRawContactsToAccounts.Result moveRawContactToAccount(\n            RawContact rawContact, Account account\n    ) {\n        return ContactsFactory.create(this)\n                .accounts()\n                .move()\n                .rawContactsTo(account, rawContact)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#sim-card","title":"SIM card","text":""},{"location":"cheatsheet/#query-contacts-in-sim-card","title":"Query contacts in SIM card","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.SimContact\n\nclass QuerySimContactsActivity : Activity() {\n\n    fun getAllSimContacts(): List&lt;SimContact&gt; = Contacts(this).sim().query().find()\n\n    fun getAllSimContactsWithPhoneNumber(): List&lt;SimContact&gt; = Contacts(this)\n        .sim()\n        .query()\n        .find()\n        .filter { !it.number.isNullOrEmpty() }\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.SimContact;\n\npublic class QuerySimContactsActivity extends Activity {\n\n    List&lt;SimContact&gt; getAllSimContacts() {\n        return ContactsFactory.create(this).sim().query().find();\n    }\n\n    List&lt;SimContact&gt; getAllSimContactsWithPhoneNumber() {\n        List&lt;SimContact&gt; simContacts = ContactsFactory.create(this).sim().query().find();\n        List&lt;SimContact&gt; simContactsWithPhoneNumber = new ArrayList&lt;&gt;();\n        for (SimContact simContact : simContacts) {\n            if (simContact.getNumber() != null &amp;&amp; !simContact.getNumber().isEmpty()) {\n                simContactsWithPhoneNumber.add(simContact);\n            }\n        }\n        return simContactsWithPhoneNumber;\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#insert-contacts-into-sim-card","title":"Insert contacts into SIM card","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.sim.SimContactsInsert\n\nclass InsertSimContactsActivity : Activity() {\n\n    fun insertSimContact(): SimContactsInsert.Result = Contacts(this)\n        .sim()\n        .insert()\n        .simContact {\n            name = \"Mr. Joe\"\n            number = \"5555555555\"\n        }\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.NewSimContact;\nimport contacts.core.sim.SimContactsInsert;\n\npublic class InsertSimContactsActivity extends Activity {\n\n    SimContactsInsert.Result insertSimContact() {\n        return ContactsFactory.create(this)\n                .sim()\n                .insert()\n                .simContacts(new NewSimContact(\"Mr. Joe\", \"5555555555\"))\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#update-contacts-in-sim-card","title":"Update contacts in SIM card","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.SimContact\nimport contacts.core.sim.SimContactsUpdate\n\nclass UpdateSimContactsActivity : Activity() {\n\n    fun updateSimContact(simContact: SimContact): SimContactsUpdate.Result = Contacts(this)\n        .sim()\n        .update()\n        .simContact(simContact, simContact.mutableCopy {\n            name = \"Vandolf\"\n            number = \"1234567890\"\n        })\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.*;\nimport contacts.core.sim.SimContactsUpdate;\n\npublic class UpdateSimContactsActivity extends Activity {\n\n    SimContactsUpdate.Result updateSimContact(SimContact simContact) {\n        MutableSimContact mutableSimContact = simContact.mutableCopy();\n        mutableSimContact.setName(\"Vandolf\");\n        mutableSimContact.setNumber(\"1234567890\");\n\n        return ContactsFactory.create(this)\n                .sim()\n                .update()\n                .simContact(simContact, mutableSimContact)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#delete-contacts-from-sim-card","title":"Delete contacts from SIM card","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.SimContact\nimport contacts.core.sim.SimContactsDelete\n\nclass DeleteSimContactsActivity : Activity() {\n\n    fun deleteSimContact(simContact: SimContact): SimContactsDelete.Result =\n        Contacts(this).sim().delete().simContacts(simContact).commit()\n\n    fun deleteSimContactWithNameAndNumber(name: String?, number: String?): SimContactsDelete.Result =\n        Contacts(this).sim().delete().simContact(name, number).commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.SimContact;\nimport contacts.core.sim.SimContactsDelete;\n\npublic class DeleteSimContactsActivity extends Activity {\n\n    SimContactsDelete.Result deleteSimContact(SimContact simContact) {\n        return ContactsFactory.create(this).sim().delete().simContacts(simContact).commit();\n    }\n\n    SimContactsDelete.Result deleteSimContactWithNameAndNumber(String name, String number) {\n        return ContactsFactory.create(this).sim().delete().simContact(name, number).commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#blocked-numbers","title":"Blocked numbers","text":""},{"location":"cheatsheet/#query-blocked-numbers","title":"Query blocked numbers","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.BlockedNumber\n\nclass QueryBlockedNumbersActivity : Activity() {\n\n    fun getAllBlockedNumbers(): List&lt;BlockedNumber&gt; =\n        Contacts(this).blockedNumbers().query().find()\n\n    fun getBlockedNumbersContainingNumber(number: String): List&lt;BlockedNumber&gt; = Contacts(this)\n        .blockedNumbers()\n        .query()\n        .where { (Number contains number) or (NormalizedNumber contains number) }\n        .find()\n}\n</code></pre> <pre><code>import static contacts.core.WhereKt.*;\n\nimport android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.*;\nimport contacts.core.entities.BlockedNumber;\n\npublic class QueryBlockedNumbersActivity extends Activity {\n\n    List&lt;BlockedNumber&gt; getAllBlockedNumbers() {\n        return ContactsFactory.create(this).blockedNumbers().query().find();\n    }\n\n    List&lt;BlockedNumber&gt; getBlockedNumbersContainingNumber(String number) {\n        return ContactsFactory.create(this)\n                .blockedNumbers()\n                .query()\n                .where(\n                        or(\n                                contains(BlockedNumbersFields.Number, number),\n                                contains(BlockedNumbersFields.NormalizedNumber, number)\n                        )\n                )\n                .find();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#insert-blocked-numbers","title":"Insert blocked numbers","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.blockednumbers.BlockedNumbersInsert\n\nclass InsertBlockedNumbersActivity : Activity() {\n\n    fun insertBlockedNumber(): BlockedNumbersInsert.Result = Contacts(this)\n        .blockedNumbers()\n        .insert()\n        .blockedNumber {\n            number = \"555-555-5555\"\n        }\n        .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.blockednumbers.BlockedNumbersInsert;\nimport contacts.core.entities.NewBlockedNumber;\n\npublic class InsertBlockedNumbersActivity extends Activity {\n\n    BlockedNumbersInsert.Result insertBlockedNumber() {\n        return ContactsFactory.create(this)\n                .blockedNumbers()\n                .insert()\n                .blockedNumbers(new NewBlockedNumber(\"555-555-5555\"))\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#delete-blocked-numbers","title":"Delete blocked numbers","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.blockednumbers.BlockedNumbersDelete\nimport contacts.core.entities.BlockedNumber\n\nclass DeleteBlockedNumbersActivity : Activity() {\n\n    fun deleteBlockedNumber(blockedNumber: BlockedNumber): BlockedNumbersDelete.Result =\n        Contacts(this)\n            .blockedNumbers()\n            .delete()\n            .blockedNumbers(blockedNumber)\n            .commit()\n\n    fun deleteBlockedNumberWithId(blockedNumberId: Long): BlockedNumbersDelete.Result =\n        Contacts(this)\n            .blockedNumbers()\n            .delete()\n            .blockedNumbersWithId(blockedNumberId)\n            .commit()\n\n    fun deleteBlockedNumbersContaining555(): BlockedNumbersDelete.Result =\n        Contacts(this)\n            .blockedNumbers()\n            .delete()\n            .blockedNumbersWhere { Number contains \"555\" }\n            .commit()\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.blockednumbers.BlockedNumbersDelete;\nimport contacts.core.entities.BlockedNumber;\n\npublic class DeleteBlockedNumbersActivity extends Activity {\n\n    BlockedNumbersDelete.Result deleteBlockedNumber(BlockedNumber blockedNumber) {\n        return ContactsFactory.create(this)\n                .blockedNumbers()\n                .delete()\n                .blockedNumbers(blockedNumber)\n                .commit();\n    }\n\n    BlockedNumbersDelete.Result deleteBlockedNumberWithId(Long blockedNumberId) {\n        return ContactsFactory.create(this)\n                .blockedNumbers()\n                .delete()\n                .blockedNumbersWithId(blockedNumberId)\n                .commit();\n    }\n\n    BlockedNumbersDelete.Result deleteBlockedNumbersContaining555() {\n        return ContactsFactory.create(this)\n                .blockedNumbers()\n                .delete()\n                .blockedNumbersWhere(contains(BlockedNumbersFields.Number, \"555\"))\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#other","title":"Other","text":""},{"location":"cheatsheet/#get-set-remove-full-sized-and-thumbnail-contact-photos","title":"Get set remove full-sized and thumbnail contact photos","text":"KotlinJava <pre><code>import android.app.Activity\nimport android.graphics.Bitmap\nimport android.net.Uri\nimport contacts.core.Contacts\nimport contacts.core.Insert\nimport contacts.core.Update\nimport contacts.core.entities.Contact\nimport contacts.core.entities.RawContact\nimport contacts.core.util.*\n\nclass ContactAndRawContactPhotosActivity : Activity() {\n\n    fun getContactPhotoUri(contact: Contact): Uri? = contact.photoUri\n\n    fun getContactThumbnailPhotoUri(contact: Contact): Uri? = contact.photoThumbnailUri\n\n    fun getContactPhoto(contact: Contact): Bitmap? = contact.photoBitmap(Contacts(this))\n\n    fun getContactPhotoThumbnail(contact: Contact): Bitmap? =\n        contact.photoThumbnailBitmap(Contacts(this))\n\n    fun getRawContactPhoto(rawContact: RawContact): Bitmap? = rawContact.photoBitmap(Contacts(this))\n\n    fun getRawContactPhotoThumbnail(rawContact: RawContact): Bitmap? =\n        rawContact.photoThumbnailBitmap(Contacts(this))\n\n\n    fun insertNewRawContactWithPhoto(bitmap: Bitmap): Insert.Result = Contacts(this)\n        .insert()\n        .rawContact {\n            setPhoto(PhotoData.from(bitmap))\n        }\n        .commit()\n\n    fun setContactPhoto(contact: Contact, bitmap: Bitmap): Update.Result = Contacts(this)\n        .update()\n        .contacts(\n            contact.mutableCopy {\n                setPhoto(PhotoData.from(bitmap))\n            }\n        )\n        .commit()\n\n    fun setRawContactPhoto(rawContact: RawContact, bitmap: Bitmap): Update.Result = Contacts(this)\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                setPhoto(PhotoData.from(bitmap))\n            }\n        )\n        .commit()\n\n    fun removeContactPhoto(contact: Contact): Update.Result = Contacts(this)\n        .update()\n        .contacts(\n            contact.mutableCopy {\n                removePhoto()\n            }\n        )\n        .commit()\n\n    fun removeRawContactPhoto(rawContact: RawContact): Update.Result = Contacts(this)\n        .update()\n        .rawContacts(\n            rawContact.mutableCopy {\n                removePhoto()\n            }\n        )\n        .commit()\n\n    fun setContactPhotoDirect(contact: Contact, bitmap: Bitmap): Boolean =\n        contact.setPhotoDirect(Contacts(this), PhotoData.from(bitmap))\n\n    fun setRawContactPhotoDirect(rawContact: RawContact, bitmap: Bitmap): Boolean =\n        rawContact.setPhotoDirect(Contacts(this), PhotoData.from(bitmap))\n\n    fun removeContactPhotoDirect(contact: Contact): Boolean =\n        contact.removePhotoDirect(Contacts(this))\n\n    fun removeRawContactPhotoDirect(rawContact: RawContact): Boolean =\n        rawContact.removePhotoDirect(Contacts(this))\n}\n</code></pre> <pre><code>import android.app.Activity;\nimport android.graphics.Bitmap;\nimport android.net.Uri;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.Insert;\nimport contacts.core.Update;\nimport contacts.core.entities.Contact;\nimport contacts.core.entities.MutableContact;\nimport contacts.core.entities.MutableRawContact;\nimport contacts.core.entities.NewRawContact;\nimport contacts.core.entities.RawContact;\nimport contacts.core.util.ContactPhotoKt;\nimport contacts.core.util.PhotoData;\nimport contacts.core.util.RawContactPhotoKt;\n\npublic class ContactAndRawContactPhotosActivity extends Activity {\n\n    Uri getContactPhotoUri(Contact contact) {\n        return contact.getPhotoUri();\n    }\n\n    Uri getContactThumbnailPhotoUri(Contact contact) {\n        return contact.getPhotoThumbnailUri();\n    }\n\n    Bitmap getContactPhoto(Contact contact) {\n        return ContactPhotoKt.photoBitmap(contact, ContactsFactory.create(this));\n    }\n\n    Bitmap getContactPhotoThumbnail(Contact contact) {\n        return ContactPhotoKt.photoThumbnailBitmap(contact, ContactsFactory.create(this));\n    }\n\n    Bitmap getRawContactPhoto(RawContact rawContact) {\n        return RawContactPhotoKt.photoBitmap(rawContact, ContactsFactory.create(this));\n    }\n\n    Bitmap getRawContactPhotoThumbnail(RawContact rawContact) {\n        return RawContactPhotoKt.photoThumbnailBitmap(rawContact, ContactsFactory.create(this));\n    }\n\n    Insert.Result insertNewRawContactWithPhoto(Bitmap bitmap) {\n        NewRawContact rawContact = new NewRawContact();\n        RawContactPhotoKt.setPhoto(rawContact, PhotoData.from(bitmap));\n\n        return ContactsFactory.create(this)\n                .insert()\n                .rawContacts(rawContact)\n                .commit();\n    }\n\n    Update.Result setContactPhoto(Contact contact, Bitmap bitmap) {\n        MutableContact mutableContact = contact.mutableCopy();\n        ContactPhotoKt.setPhoto(mutableContact, PhotoData.from(bitmap));\n\n        return ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n\n    Update.Result setRawContactPhoto(RawContact rawContact, Bitmap bitmap) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactPhotoKt.setPhoto(mutableRawContact, PhotoData.from(bitmap));\n\n        return ContactsFactory.create(this)\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Update.Result removeContactPhoto(Contact contact) {\n        MutableContact mutableContact = contact.mutableCopy();\n        ContactPhotoKt.removePhoto(mutableContact);\n\n        return ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n\n    Update.Result removeRawContactPhoto(RawContact rawContact) {\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n        RawContactPhotoKt.removePhoto(mutableRawContact);\n\n        return ContactsFactory.create(this)\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    Boolean setContactPhotoDirect(Contact contact, Bitmap bitmap) {\n        return ContactPhotoKt.setPhotoDirect(contact, ContactsFactory.create(this), PhotoData.from(bitmap));\n    }\n\n    Boolean setRawContactPhotoDirect(RawContact rawContact, Bitmap bitmap) {\n        return RawContactPhotoKt.setPhotoDirect(rawContact, ContactsFactory.create(this), PhotoData.from(bitmap));\n    }\n\n    Boolean removeContactPhotoDirect(Contact contact) {\n        return ContactPhotoKt.removePhotoDirect(contact, ContactsFactory.create(this));\n    }\n\n    Boolean removeRawContactPhotoDirect(RawContact rawContact) {\n        return RawContactPhotoKt.removePhotoDirect(rawContact, ContactsFactory.create(this));\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#get-set-contact-options","title":"Get set contact options","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.*\nimport contacts.core.util.*\n\nclass ContactAndRawContactOptionsActivity : Activity() {\n\n    fun getContactOptions(contact: Contact): Options? = contact.options\n\n    fun setContactOptions(contact: Contact) {\n        Contacts(this)\n            .update()\n            .contacts(\n                contact.mutableCopy {\n                    setOptions {\n                        starred = true\n                        customRingtone = null\n                        sendToVoicemail = false\n\n                    }\n                }\n            )\n            .commit()\n    }\n\n    fun getRawContactOptions(rawContact: RawContact): Options? = rawContact.options\n\n    fun setRawContactOptions(rawContact: RawContact) {\n        Contacts(this)\n            .update()\n            .rawContacts(\n                rawContact.mutableCopy {\n                    setOptions {\n                        starred = true\n                        customRingtone = null\n                        sendToVoicemail = false\n\n                    }\n                }\n            )\n            .commit()\n    }\n\n    fun insertNewRawContactWithOptions() {\n        Contacts(this)\n            .insert()\n            .rawContact {\n                setOptions { starred = true }\n                setNickname { name = \"Favorite friend\" }\n            }\n            .commit()\n    }\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.*;\nimport contacts.core.util.*;\n\npublic class ContactAndRawContactOptionsActivity extends Activity {\n\n    Options getContactOptions(Contact contact) {\n        return contact.getOptions();\n    }\n\n    void setContactOptions(Contact contact) {\n        NewOptions newOptions = new NewOptions();\n        newOptions.setStarred(true);\n        newOptions.setCustomRingtone(null);\n        newOptions.setSendToVoicemail(false);\n\n        MutableContact mutableContact = contact.mutableCopy();\n\n        ContactDataKt.setOptions(mutableContact, newOptions);\n\n        ContactsFactory.create(this)\n                .update()\n                .contacts(mutableContact)\n                .commit();\n    }\n\n    Options getRawContactOptions(RawContact rawContact) {\n        return rawContact.getOptions();\n    }\n\n    void setRawContactOptions(RawContact rawContact) {\n        NewOptions newOptions = new NewOptions();\n        newOptions.setStarred(true);\n        newOptions.setCustomRingtone(null);\n        newOptions.setSendToVoicemail(false);\n\n        MutableRawContact mutableRawContact = rawContact.mutableCopy();\n\n        MutableRawContactDataKt.setOptions(mutableRawContact, newOptions);\n\n        ContactsFactory.create(this)\n                .update()\n                .rawContacts(mutableRawContact)\n                .commit();\n    }\n\n    void insertNewRawContactWithOptions() {\n        NewOptions newOptions = new NewOptions();\n        newOptions.setStarred(true);\n\n        NewNickname newNickname = new NewNickname();\n        newNickname.setName(\"Favorite friend\");\n\n        NewRawContact newRawContact = new NewRawContact();\n\n        NewRawContactDataKt.setOptions(newRawContact, newOptions);\n\n        ContactsFactory.create(this)\n                .insert()\n                .rawContacts(newRawContact)\n                .commit();\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#get-set-clear-default-contact-data","title":"Get set clear default Contact data","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.entities.Phone\nimport contacts.core.util.*\n\nclass ContactDefaultDataActivity : Activity() {\n\n    fun isPhoneTheDefaultPhone(phone: Phone): Boolean = phone.isDefault\n\n    fun setPhoneAsDefault(phone: Phone): Boolean = phone.setAsDefault(Contacts(this))\n\n    fun clearDefaultPhone(phone: Phone): Boolean = phone.clearDefault(Contacts(this))\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.entities.Phone;\nimport contacts.core.util.DefaultContactDataKt;\n\npublic class ContactDefaultDataActivity extends Activity {\n\n    Boolean isPhoneTheDefaultPhone(Phone phone) {\n        return phone.isDefault();\n    }\n\n    Boolean setPhoneAsDefault(Phone phone) {\n        return DefaultContactDataKt.setAsDefault(phone, ContactsFactory.create(this));\n    }\n\n    Boolean clearDefaultPhone(Phone phone) {\n        return DefaultContactDataKt.clearDefault(phone, ContactsFactory.create(this));\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#link-unlink-contacts","title":"Link unlink Contacts","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.aggregationexceptions.ContactLink\nimport contacts.core.aggregationexceptions.ContactUnlink\nimport contacts.core.entities.Contact\nimport contacts.core.util.linkDirect\nimport contacts.core.util.unlinkDirect\n\nclass ContactLinksActivity : Activity() {\n\n    fun link(contacts: List&lt;Contact&gt;): ContactLink.Result = Contacts(this)\n        .aggregationExceptions()\n        .link()\n        .contacts(contacts)\n        .commit()\n\n    fun unlink(contact: Contact): ContactUnlink.Result = Contacts(this)\n        .aggregationExceptions()\n        .unlink()\n        .contact(contact)\n        .commit()\n\n    fun linkDirect(contacts: List&lt;Contact&gt;): ContactLink.Result =\n        contacts.linkDirect(Contacts(this))\n\n    fun unlinkDirect(contact: Contact): ContactUnlink.Result =\n        contact.unlinkDirect(Contacts(this))\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport java.util.List;\n\nimport contacts.core.ContactsFactory;\nimport contacts.core.aggregationexceptions.ContactLink;\nimport contacts.core.aggregationexceptions.ContactUnlink;\nimport contacts.core.entities.Contact;\nimport contacts.core.util.ContactLinksKt;\n\npublic class ContactLinksActivity extends Activity {\n\n    ContactLink.Result link(List&lt;Contact&gt; contacts) {\n        return ContactsFactory\n                .create(this)\n                .aggregationExceptions()\n                .link()\n                .contacts(contacts)\n                .commit();\n    }\n\n    ContactUnlink.Result unlink(Contact contact) {\n        return ContactsFactory\n                .create(this)\n                .aggregationExceptions()\n                .unlink()\n                .contact(contact)\n                .commit();\n    }\n\n    ContactLink.Result linkDirect(List&lt;Contact&gt; contacts) {\n        return ContactLinksKt.linkDirect(contacts, ContactsFactory.create(this));\n    }\n\n    ContactUnlink.Result unlinkDirect(Contact contact) {\n        return ContactLinksKt.unlinkDirect(contact, ContactsFactory.create(this));\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#share-contacts-vcard-vcf","title":"Share Contacts vCard (.VCF)","text":"KotlinJava <pre><code>import android.app.Activity\nimport android.content.Intent\nimport contacts.core.entities.Contact\nimport contacts.core.util.*\n\nclass ContactShareActivity : Activity() {\n\n    fun shareContact(contact: Contact) {\n        val shareIntent = contact.shareVCardIntent()\n        if (shareIntent != null) {\n            startActivity(Intent.createChooser(shareIntent, null))\n        }\n    }\n\n    fun shareContacts(contacts: List&lt;Contact&gt;) {\n        val shareIntent = contacts.shareMultiVCardIntent()\n        if (shareIntent != null) {\n            startActivity(Intent.createChooser(shareIntent, null))\n        }\n    }\n}\n</code></pre> <pre><code>import android.app.Activity;\nimport android.content.Intent;\n\nimport java.util.List;\n\nimport contacts.core.entities.Contact;\nimport contacts.core.util.ContactShareKt;\n\npublic class ContactShareActivity extends Activity {\n\n    void shareContact(Contact contact) {\n        Intent shareIntent = ContactShareKt.shareVCardIntent(contact);\n        if (shareIntent != null) {\n            startActivity(Intent.createChooser(shareIntent, null));\n        }\n    }\n\n    void shareContacts(List&lt;Contact&gt; contacts) {\n        Intent shareIntent = ContactShareKt.shareMultiVCardIntent(contacts);\n        if (shareIntent != null) {\n            startActivity(Intent.createChooser(shareIntent, null));\n        }\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#convenience-functions","title":"Convenience functions","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.*\nimport contacts.core.entities.*\nimport contacts.core.util.*\n\nclass ConvenienceFunctionsActivity : Activity() {\n\n    fun getSetRawContactDataThroughContact(contact: Contact) {\n        contact.mutableCopy().addEmail(NewEmail().apply {\n            address = \"test@email.com\"\n            type = EmailEntity.Type.WORK\n        })\n    }\n\n    fun setDataUsingExtensions(mutableRawContact: MutableRawContact) {\n        mutableRawContact.addEmail {\n            address = \"test@email.com\"\n            type = EmailEntity.Type.WORK\n        }\n    }\n\n    fun getParentContactOfRawContact(rawContact: RawContact): Contact? =\n        rawContact.contact(Contacts(this))\n\n    fun getParentContactOfData(data: ExistingDataEntity): Contact? = data.contact(Contacts(this))\n\n    fun getParentRawContactOfData(data: ExistingDataEntity): RawContact? =\n        data.rawContact(Contacts(this))\n\n    fun refreshContact(contact: Contact): Contact? = contact.refresh(Contacts(this))\n\n    fun refreshRawContact(rawContact: RawContact): RawContact? = rawContact.refresh(Contacts(this))\n\n    fun refreshData(data: ExistingDataEntity): ExistingDataEntity? = data.refresh(Contacts(this))\n\n    fun isDataReadOnly(data: ExistingDataEntity): Boolean = data.isReadOnly(Contacts(this))\n\n    fun isDataReadOnlyMap(data: Collection&lt;ExistingDataEntity&gt;): Map&lt;Long, Boolean&gt; =\n        data.isReadOnlyMap(Contacts(this))\n\n    fun sortContactsUsingDataTableFields(contacts: List&lt;Contact&gt;) =\n        contacts.sortedWith(\n            setOf(\n                Fields.Contact.Options.Starred.desc(),\n                Fields.Email.Type.asc()\n            ).contactsComparator()\n        )\n\n    fun getGroupOfGroupMemberships(groupMemberships: List&lt;GroupMembership&gt;): List&lt;Group&gt; =\n        groupMemberships.groups(Contacts(this))\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport java.util.*;\n\nimport contacts.core.*;\nimport contacts.core.entities.*;\nimport contacts.core.util.*;\n\npublic class ConvenienceFunctionsActivity extends Activity {\n\n    void getSetRawContactDataThroughContact(Contact contact) {\n        NewEmail newEmail = new NewEmail();\n        newEmail.setAddress(\"test@email.com\");\n        newEmail.setType(EmailEntity.Type.WORK);\n        ContactDataKt.addEmail(contact.mutableCopy(), newEmail);\n    }\n\n    void setDataUsingExtensions(MutableRawContact mutableRawContact) {\n        NewEmail newEmail = new NewEmail();\n        newEmail.setAddress(\"test@email.com\");\n        newEmail.setType(EmailEntity.Type.WORK);\n        MutableRawContactDataKt.addEmail(mutableRawContact, newEmail);\n    }\n\n    Contact getParentContactOfRawContact(RawContact rawContact) {\n        return RawContactContactKt.contact(rawContact, ContactsFactory.create(this));\n    }\n\n    Contact getParentContactOfData(ExistingDataEntity data) {\n        return DataContactKt.contact(data, ContactsFactory.create(this));\n    }\n\n    RawContact getParentRawContactOfData(ExistingDataEntity data) {\n        return DataRawContactKt.rawContact(data, ContactsFactory.create(this));\n    }\n\n    Contact refreshContact(Contact contact) {\n        return ContactRefreshKt.refresh(contact, ContactsFactory.create(this));\n    }\n\n    RawContact refreshRawContact(RawContact rawContact) {\n        return RawContactRefreshKt.refresh(rawContact, ContactsFactory.create(this));\n    }\n\n    ExistingDataEntity refreshData(ExistingDataEntity data) {\n        return DataRefreshKt.refresh(data, ContactsFactory.create(this));\n    }\n\n    boolean isDataReadOnly(ExistingDataEntity data) {\n        return DataIsReadOnlyKt.isReadOnly(data, ContactsFactory.create(this));\n    }\n\n    Map&lt;Long, Boolean&gt; isDataReadOnlyMap(Collection&lt;ExistingDataEntity&gt; data) {\n        return DataIsReadOnlyKt.isReadOnlyMap(data, ContactsFactory.create(this));\n    }\n\n    List&lt;Contact&gt; sortContactsUsingDataTableFields(List&lt;Contact&gt; contacts) {\n        List&lt;OrderBy&lt;AbstractDataField&gt;&gt; orderByFields = new ArrayList&lt;&gt;();\n        orderByFields.add(OrderByKt.desc(Fields.Contact.Options.Starred));\n        orderByFields.add(OrderByKt.asc(Fields.Email.Type));\n\n        List&lt;Contact&gt; sortedContacts = new ArrayList&lt;&gt;(contacts);\n        Collections.sort(sortedContacts, ContactsComparatorKt.contactsComparator(orderByFields));\n        return sortedContacts;\n    }\n\n    List&lt;Group&gt; getGroupOfGroupMemberships(List&lt;GroupMembership&gt; groupMemberships) {\n        return GroupMembershipGroupKt.groups(groupMemberships, ContactsFactory.create(this));\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#logging","title":"Logging","text":""},{"location":"cheatsheet/#log-api-input-and-output","title":"Log API input and output","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.core.Contacts\nimport contacts.core.log.AndroidLogger\n\nclass LogContactsApiActivity : Activity() {\n\n    fun createContactsApiWithLoggingEnabled(redactLogMessages: Boolean): Contacts = Contacts(\n        this, false, logger = AndroidLogger(redactMessages = redactLogMessages)\n    )\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.core.*;\nimport contacts.core.entities.custom.CustomDataRegistry;\nimport contacts.core.log.AndroidLogger;\n\npublic class LogContactsApiActivity extends Activity {\n\n    Contacts createContactsApiWithLoggingEnabled(Boolean redactLogMessages) {\n        return ContactsFactory.create(\n                this, false, new CustomDataRegistry(), new AndroidLogger(redactLogMessages)\n        );\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#testing","title":"Testing","text":""},{"location":"cheatsheet/#contacts-api-testing","title":"Contacts API Testing","text":"<p>Coming \"soon\"!</p> <ul> <li>https://github.com/vestrel00/contacts-android/issues/46</li> <li>https://github.com/vestrel00/contacts-android/issues/47</li> </ul>"},{"location":"cheatsheet/#debug","title":"Debug","text":""},{"location":"cheatsheet/#debug-the-contacts-provider-tables","title":"Debug the Contacts Provider tables","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.debug.*\n\nclass DebugContactsProviderTablesActivity : Activity() {\n\n    fun debugContactsProviderTables() {\n        logGroupsTable()\n        logAggregationExceptionsTable()\n        logProfile()\n        logContactsTable()\n        logRawContactsTable()\n        logDataTable()\n    }\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.debug.*;\n\npublic class DebugContactsProviderTablesActivity extends Activity {\n\n    void debugContactsProviderTables() {\n        LogGroupsTableKt.logGroupsTable(this);\n        LogAggregationExceptionsTableKt.logAggregationExceptionsTable(this);\n        LogProfileKt.logProfile(this);\n        LogContactsTableKt.logContactsTable(this);\n        LogRawContactsTableKt.logRawContactsTable(this);\n        LogDataTableKt.logDataTable(this);\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#debug-the-blockednumber-provider-tables","title":"Debug the BlockedNumber Provider tables","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.debug.logBlockedNumbersTable\n\nclass DebugBlockedNumberProviderTablesActivity : Activity() {\n\n    fun debugBlockedNumberProviderTables() {\n        logBlockedNumbersTable()\n    }\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.debug.LogBlockedNumbersKt;\n\npublic class DebugBlockedNumberProviderTablesActivity extends Activity {\n\n    void debugBlockedNumberProviderTables() {\n        LogBlockedNumbersKt.logBlockedNumbersTable(this);\n    }\n}\n</code></pre>"},{"location":"cheatsheet/#debug-the-sim-contacts-table","title":"Debug the Sim Contacts table","text":"KotlinJava <pre><code>import android.app.Activity\nimport contacts.debug.logSimContactsTable\n\nclass DebugSimContactsTablesActivity : Activity() {\n\n    fun debugSimContactsTables() {\n        logSimContactsTable()\n    }\n}\n</code></pre> <pre><code>import android.app.Activity;\n\nimport contacts.debug.LogSimContactsTableKt;\n\npublic class DebugSimContactsTablesActivity extends Activity {\n\n    void debugSimContactsTables() {\n        LogSimContactsTableKt.logSimContactsTable(this);\n    }\n}\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>There are only a few loose guidelines to follow. Read the Setup and Guidelines sections.</p>"},{"location":"contributing/#setup","title":"Setup","text":"<p>To open, build, and run this project, you will need to use  Android Studio Ladybug | 2024.2.1 Patch 3 and later versions.</p> <p>If you run into any build issues, open up Android Studio preferences and make sure the following is  set correctly...</p> <ul> <li>Build, Execution, Deployment -&gt; Build Tools -&gt; Gradle</li> <li>Use Gradle from: 'gradlew-wrapper.properties' file</li> </ul> <p>Restart Android Studio, clean, build, and invalidate caches &amp; restart.</p>"},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ol> <li>Simple is better.<ul> <li>Over-engineering is not welcome here. Don't over complicate function implementations   unnecessarily, especially the public API.</li> </ul> </li> <li>Less is more.<ul> <li>If you have not noticed yet, the dependency list of this project is almost non-existent. The   core module only depends on Kotlin's standard library. Not even the support annotations are   included (though this is questionable and may change quickly). All modules only have   dependencies on essentials. Nice-to-haves are excluded.</li> <li>Contacts have been here since API 1. In that spirit, we should not need to import tons of   unnecessary dependencies to deliver the most basic Android API.</li> </ul> </li> <li>Java compatibility is a must.<ul> <li>Java is not dead even in Android, though it may seem like it. There are still probably a lot of   people that have not migrated over to Kotlin. This is especially true for larger organizations   with large code bases and unable to afford migrating to Kotlin. The API must be usable in Java,   with exceptions to Kotlin-specific modules (e.g. async, permissions).</li> </ul> </li> <li>Be patient.<ul> <li>Early on, I (Vandolf) will be the only one to approve incoming code. It may take a few days for   me to review code and decline/approve. I have a full time job after all =) As time passes, I'm   hoping to give the power of approvals to others in the community.</li> </ul> </li> <li>Uphold the spirit of Contacts, Reborn!<ul> <li>Don't deviate from the existing API design. New code should follow existing API design to   promote uniformity. It'll be easier to maintain and cross-pollinate.</li> </ul> </li> </ol>"},{"location":"dev-notes/","title":"Developer Notes","text":"<p>This document contains useful developer notes that should be kept in mind during development. It  serves as a memory of all the quirks and gotcha's of things like Android's <code>ContactsContract</code>.</p> <p>This is only meant to be read by contributors of this library, not consumers!</p>"},{"location":"dev-notes/#contacts-provider-contactscontract","title":"Contacts Provider / ContactsContract","text":"<p>It is important to know about the ins and outs of Android's Contacts Provider. After all, this API  is just a wrapper around it. </p> <p>It is important to get familiar with the official documentation of the Contact's Provider.</p> <p>Here is a summary;</p> <p>There are 3 main database tables used in dealing with contacts;</p> <ol> <li>Contacts</li> <li>RawContacts</li> <li>Data</li> </ol> <p>\u2139\ufe0f There are more but that is covered later.</p> <p>All of these tables and their fields are enumerated and documented in <code>android.provider.ContactsContract</code>. </p> <p>Each table serves a different purpose;</p> <ol> <li>Contacts<ul> <li>Rows representing different people.</li> </ul> </li> <li>RawContacts<ul> <li>Rows that link Contacts rows to specific Accounts.</li> </ul> </li> <li>Data<ul> <li>Rows containing data (e.g. name, email) for a RawContacts row.</li> </ul> </li> </ol> <p>These tables contain the following (notable) information (columns);</p> <ol> <li><code>Contacts</code><ul> <li><code>_ID</code></li> <li><code>DISPLAY_NAME_PRIMARY</code></li> </ul> </li> <li><code>RawContacts</code><ul> <li><code>_ID</code>: the <code>Contacts._ID</code></li> <li><code>ACCOUNT_NAME</code>: the <code>Account.name</code></li> <li><code>ACCOUNT_TYPE</code> the <code>Account.type</code></li> </ul> </li> <li><code>Data</code><ul> <li><code>RAW_CONTACT_ID</code>: the <code>RawContacts._ID</code></li> <li><code>CONTACT_ID</code>: the <code>Contacts._ID</code></li> <li><code>DATA_1</code> to <code>DATA_15</code>: contains a piece of contact data    (e.g. first and last name, email address and type) determined by    the <code>MIMETYPE</code></li> <li><code>MIMETYPE</code>: the type of data that this row's <code>DATA_X</code> columns contain   (e.g. name and email data)</li> </ul> </li> </ol> <p>The tables are connected the following way;</p> <ul> <li>RawContacts contains a reference to the Contacts row Id.</li> <li>Data contains a reference to the RawContacts row Id and Contacts row Id. </li> </ul>"},{"location":"dev-notes/#contacts-display-name","title":"Contacts; Display Name","text":"<p>The <code>Contacts.DISPLAY_NAME</code> name may be different than the Data <code>StructuredName</code> display name! If a structured name in the Data table is not provided, then other kinds of data will be used as the  <code>Contacts</code> row display name. For example, if an email is provided but no structured name then the display name will be the email. When a structured name is inserted, the Contacts Provider  automatically updates the Contacts row display name.</p> <p>\u2139\ufe0f In the case of <code>StructuredName</code>, the <code>Contacts.DISPLAY_NAME</code> is made up of the prefix, given, middle, family name, and suffix and not the unstructured display name.</p> <p>If no data rows suitable to be a display name are available, then the Contacts row display name will be null. Data suitable to be a Contacts row display name are enumerated in <code>DisplayNameSources</code>;</p> <ul> <li>email</li> <li>nickname</li> <li>organization</li> <li>phone number</li> <li>structured name</li> </ul> <p>Data not suitable to be display names are;</p> <ul> <li>address</li> <li>event</li> <li>group</li> <li>im</li> <li>note</li> <li>relation</li> <li>sip</li> <li>website</li> </ul> <p>The kind of data used as the display for the Contact is set in <code>ContactNameColumns.DISPLAY_NAME_SOURCE</code>.</p> <p>A note about <code>StructuredName</code></p> <p>There may be a scenario where the unstructured <code>StructuredName.DISPLAY_NAME</code> does not match the structured components. Such scenarios are possible but is considered incorrect. For example, it is possible to programmatically set the display name to \"Ice Cold\" but set the given and family name to \"Hot Fire\". The <code>Contacts.DISPLAY_NAME</code> is made up of the prefix, given, middle, family name, and suffix (\"Hot Fire\") and not the unstructured display name.</p> <p>The Contacts Provider's general matching algorithm does not include the <code>Contacts.DISPLAY_NAME</code>. However, the <code>StructuredName.DISPLAY_NAME</code> is included in the matching process but not the rest of the structured components (e.g. given and family name).</p> <p>The AOSP Contacts app displays the <code>Contacts.DISPLAY_NAME</code>. So, here comes the unusual scenario that looks like a bug. The general matching algorithm will match the text \"Ice\" or \"Cold\" but not \"Hot\" or \"Fire\". The end result is that searching for the Contact \"Ice Cold\" will show a Contact called \"Hot Fire\"!</p>"},{"location":"dev-notes/#contact-display-name-and-default-name-rows","title":"Contact Display Name and Default Name Rows","text":"<p>If available, the \"default\" (isPrimary and isSuperPrimary set to 1) name row for a Contact is  automatically set as the Contact display name by the Contacts Provider. Otherwise, the Contacts Provider chooses from any of the other suitable data from the aggregate Contact.</p> <p>\u2139\ufe0f The <code>ContactsColumns.NAME_RAW_CONTACT_ID</code> is automatically updated by the Contacts Provider along with the display name.</p> <p>The default status of other sources (e.g. email) does not affect the Contact display name.</p> <p>The AOSP Contacts app also sets the most recently updated name as the default at every update.  This results in the Contact display name changing to the most recently updated name from one of the associated RawContacts. The \"most recently updated name\" is the name field that was last updated by the user when editing in the Contacts app, which is irrelevant to its value. It does not matter if the user deleted the last character of the name, added the same character back, and then saved.  It still counts as the most recently updated. </p> <p>All of the above only applies to API 21 and above.</p> <p>Display name resolution is different for APIs below 21 (pre-Lollipop)!</p> <p>The <code>ContactsColumns.NAME_RAW_CONTACT_ID</code> was added in API 21. It changed the way display names are resolved for Contacts with more than one constituent RawContacts, which is what has been  described so far.</p> <p>Before this change (APIs 20 and below), the AOSP Contacts app is still able to set the Contact display name somehow. I'm not sure how. If someone figures it out, please let me know. I tried  updating the Contact <code>DISPLAY_NAME</code> directly but it does not work. Setting a name row as default  also does not affect the Contact <code>DISPLAY_NAME</code>.</p>"},{"location":"dev-notes/#contacts-id-vs-lookup_key","title":"Contacts; ID vs LOOKUP_KEY","text":"<p>The <code>Contacts._ID</code> is the unique identifier for the row in the Contacts table. The <code>Contacts.LOOKUP_KEY</code> is the unique identifier for an aggregate Contact (a person). The <code>_ID</code> may change due to aggregation and sync. The same goes for the <code>LOOKUP_KEY</code> but unlike the <code>ID</code> it may still be used to find the aggregate contact.</p> <p>Unlike the Contact ID, the lookup key is the same across devices (for contacts that are associated with an Account and are synced).</p> <p>\u2139\ufe0f I did the following investigation with a much larger data set. I simplified it here for brevity.</p> <p>Let's take a look at the following Contacts and RawContacts table rows,</p> <pre><code>#### Contacts table\nContact id: 55, lookupKey: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50, displayNamePrimary: Contact With Local RawContact\nContact id: 56, lookupKey: 2059i6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n#### RawContacts table\nRawContact id: 55, contactId: 55, sourceId: null, displayNamePrimary: Contact With Local RawContact\nRawContact id: 56, contactId: 56, sourceId: 6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n</code></pre> <p>There are two Contacts each having one RawContact.</p> <p>Notice that the lookup keys are a bit different.</p> <ul> <li>Contact With Local RawContact: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50</li> <li>Contact With Synced RawContact: 2059i6f5de8460f7f227e</li> </ul> <p>The Contact with synced RawContact uses the RawContact's <code>SOURCE_ID</code> as part of its lookup key. Notice that the <code>sourceId</code> value (i.e. 6f5de8460f7f227e) is NOT exactly the same as the <code>lookupKey</code> (i.e. 2059i6f5de8460f7f227e)!</p> <p>The Contact with unsynced, device-only, local RawContact has a much longer (or shorter e.g. 0r62-2A2C2E) lookup key and starts with \"0r-\" and all characters after it are in uppercase. The  other thing to notice is that the \"55\" in \"0r55-\" seems to be the same as the RawContact ID (I did  a bit more experiments than what is written in these notes to confirm that it is indeed the  RawContact ID and not the Contact ID). We probably don't need to worry about these details though  the Contacts Provider probably uses these things internally. We also should not rely on it.  <p>However, it may be safe to assume that the Contact lookup key is a reference to a RawContact  (or reference to more than one constituent RawContact when multiple RawContacts are linked). Again, an internal Contacts Provider detail we should not rely on BUT is probably relevant when implementing sync adapters.</p> <p>When we link the two, we get...</p> <pre><code>Contact id: 55, lookupKey: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50.2059i6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n#### RawContacts table\nRawContact id: 55, contactId: 55, sorceId: null, displayNamePrimary: Contact With Local RawContact\nRawContact id: 56, contactId: 55, sourceId: 6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n</code></pre> <p>Notice,</p> <ul> <li>Contact with ID 56 has been deleted.</li> <li>Contact with ID 55 still exist with the lookup keys of both Contact 55 and 56 combined separated by a \".\". <ul> <li>This holds true in cases where two or more local-only or non-local-only RawContacts are linked.</li> </ul> </li> <li>RawContacts remain unchanged except reference to Contact 56 has been replaced with 55.</li> <li>The primary display name of Contact 55 came from RawContact 55 prior to the link and now comes   from RawContact 56 after the link.</li> <li>This primary name resolution is probably irrelevant so pay no attention to it.</li> </ul> <p>The most important part to notice is that the lookup keys get combined.</p> <p>Given that the lookup key of the deleted Contact 56 still lives on, it is possible to get  the linked Contact 55 using the lookup key of Contact 56 using our standard query APIs!</p> <pre><code>.where { Contact.LookupKey contains lookupKey }\n</code></pre> <p>The above is correct as long as these assumptions hold true;</p> <ul> <li>the lookup key is unique </li> <li>there is no lookup key that can contain a shorter lookup key<ul> <li>the Contact ID fails this test because a smaller number is contained in a larger number</li> <li>synced contacts have shorter lookup keys than local contacts. However, local contacts'    lookup keys are capitalized whereas synced contact are not. Also, there seems to be other   differences in pattern between long and short lookup keys. It should be safe to make this   assumption.</li> </ul> </li> </ul> <p>Until the community finds that this assumption is flawed, we'll assume that it is true!</p> <p>When we unlink, we get...</p> <pre><code>#### Contacts table\nContact id: 55, lookupKey: 2059i6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\nContact id: 58, lookupKey: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50, displayNamePrimary: Contact With Local RawContact\n#### RawContacts table\nRawContact id: 55, contactId: 58, sourceId: null, displayNamePrimary: Contact With Local RawContact\nRawContact id: 56, contactId: 55, sourceId: 6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n</code></pre> <p>Notice,</p> <ul> <li>A new Contact row with ID of 58 is created.</li> <li>The lookup keys are separated and distributed between Contact 55 and 58.</li> <li>RawContact 55 Contact reference has been set to Contact 58.</li> </ul> <p>Let's compare the Contact-RawContact relationship before and after linking and then unlinking.</p> Contact ID Lookup Key RawContact.Contact ID Before 55,56 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50,2059i6f5de8460f7f227e 55,56 After 55,58 2059i6f5de8460f7f227e,0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50 58,55 <p>Notice,</p> <ul> <li>Contact ID 55 swapped lookup keys with the former Contact 56 (now 58).</li> <li>RawContact ID 55 swapped Contact reference with RawContact 56.</li> </ul> <p>The Contact IDs and lookup keys got shuffled BUT the Contact-RawContact relationship remains the  same if using the lookup keys as point of reference! Here is another way to look at the table, using the lookup key as the constant...</p> Lookup Key Before After 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50 Contact 55,RawContact 55 Contact 58,RawContact 55 2059i6f5de8460f7f227e Contact 56,RawContact 56 Contact 55,RawContact 56 <p>Notice that the indirect relationship between the lookup key and RawContacts remains the same  before and after the link-unlink even though the Contact IDs changed.</p> <p>\u2139\ufe0f As mentioned earlier in this section, the \"55\" in \"0r55-\" seems to be referencing the  RawContact ID. In other words, since local RawContacts are not synced or tracked in a remote  database where Contacts -&gt; RawContacts mappings exist, the Contacts Provider most likely uses this  \"0r-\" pattern to make the connection. This is not really relevant for us as we are not relying on this mechanism. I'm just pointing out my observations, which could be incorrect. <p>This means that...</p> <ul> <li>If users of this library saved a reference Contact ID 55, then a link-unlink (or sync adapter    functions) occur. <ul> <li>Getting Contact by ID 55 will result in the RawContact-Data of the former Contact 56 to be    returned. This is a bug! Same goes if users saved a reference to Contact ID 56.</li> </ul> </li> <li>If users of this library saved a reference to the lookup keys, then a link-unlink (or sync adapter   functions) occur.<ul> <li>Getting Contact by lookup key will result in the correct RawContact-Data to be returned.</li> </ul> </li> </ul> <p>So when to use Contact ID vs lookup key?</p> <ul> <li>Lookup key: for a reference to a Contact that needs to be loaded after some period of time.<ul> <li>Creating and loading shortcuts.</li> <li>Saving/restoring activity/fragment instance state.</li> <li>Saving to an external database, preferences, or files.</li> </ul> </li> <li>ID: for everything else.<ul> <li>Performing read/write operations in the same function call or session in your app.</li> <li>Performing read/write operations that require ID (e.g. Contact photo and options).</li> </ul> </li> </ul> <p>Another thing to check is what happens when associating a local RawContact to an Account (move from device to Account) and vice versa. Is the lookup key of the Contact affected? Yes. The Contact,  RawContacts, and Data rows have been deleted and new rows have been created to replace them! This  means that all IDs have changed. The Contact lookup key and the RawContacts source ID also changed.</p> <p>Local contact's lookup key may change but row ID remain the same!</p> <p>The ContactsProvider may assign a different value to the Contact lookup key if it's constituent RawContacts that are not associated with an Account (local, unsynced, source id is null) gets its primary display name source updated. Display name sources are specified in <code>ContactsContract.DisplayNameSources</code>. In order of increasing priority; email, phone, organization, nickname, and name.</p> <p>This suggests that the lookup key for local contacts depends on the primary display name. It probably uses its hashed value as the value of the lookup key or something like that.</p> <p>To account for this scenario, ContactsContract provides <code>Contacts.CONTENT_LOOKUP_URI</code> and <code>getLookupUri</code>...</p> <pre><code>/**\n * A content:// style URI for this table that should be used to create\n * shortcuts or otherwise create long-term links to contacts. This URI\n * should always be followed by a \"/\" and the contact's {@link #LOOKUP_KEY}.\n * It can optionally also have a \"/\" and last known contact ID appended after\n * that. This \"complete\" format is an important optimization and is highly recommended.\n * &lt;p&gt;\n * As long as the contact's row ID remains the same, this URI is\n * equivalent to {@link #CONTENT_URI}. If the contact's row ID changes\n * as a result of a sync or aggregation, this URI will look up the\n * contact using indirect information (sync IDs or constituent raw\n * contacts).\n * &lt;p&gt;\n * Lookup key should be appended unencoded - it is stored in the encoded\n * form, ready for use in a URI.\n */\npublic static final Uri CONTENT_LOOKUP_URI = Uri.withAppendedPath(CONTENT_URI, \"lookup\");\n\n/**\n * Build a {@link #CONTENT_LOOKUP_URI} lookup {@link Uri} using the\n * given {@link ContactsContract.Contacts#_ID} and {@link #LOOKUP_KEY}.\n * &lt;p&gt;\n * Returns null if unable to construct a valid lookup URI from the\n * provided parameters.\n */\npublic static Uri getLookupUri(long contactId, String lookupKey) {\n    if (TextUtils.isEmpty(lookupKey)) {\n        return null;\n    }\n    return ContentUris.withAppendedId(Uri.withAppendedPath(Contacts.CONTENT_LOOKUP_URI, lookupKey), contactId);\n}\n</code></pre>"},{"location":"dev-notes/#rawcontacts-accounts-contacts","title":"RawContacts; Accounts + Contacts","text":"<p>The RawContacts table associates a person to an <code>android.accounts.Account</code> that it belongs to. </p> <p>Each new RawContacts row created results in;</p> <ul> <li>a new row in the Contacts table (unless the RawContact is associated to another existing Contact)</li> <li>a new row in the RawContacts with account name and type set to null</li> <li>0 or more rows in the Data table with a reference to the new Contacts and RawContacts Ids</li> </ul> <p>\u2139\ufe0f It is possible to create RawContacts without any rows in the Data table. See the  Data required section for more details.</p> <p>For example, creating 4 new contacts using the AOSP Android Contacts app results in;</p> <pre><code>Contact id: 4, displayName: First Local Contact\nContact id: 5, displayName: Second Local Contact\nContact id: 6, displayName: Third Local Contact\nContact id: 7, displayName: Third Local Contact\nRawContact id: 4, accountName: null, accountType: null\nRawContact id: 5, accountName: null, accountType: null\nRawContact id: 6, accountName: null, accountType: null\nRawContact id: 7, accountName: null, accountType: null\nData id: 15, rawContactId: 4, contactId: 4, data: First Local Contact\nData id: 16, rawContactId: 5, contactId: 5, data: Second Local Contact\nData id: 17, rawContactId: 6, contactId: 6, data: Third Local Contact\nData id: 18, rawContactId: 7, contactId: 7, data: Third Local Contact\n</code></pre> <p>Local Contacts / RawContacts</p> <p>RawContacts inserted without an associated account are considered local or device-only raw contacts, which are not synced.</p> <p>The AOSP Contacts app hides the following UI fields when inserting or updating local raw contacts;</p> <ul> <li>Event</li> <li>Relation</li> <li>Group memberships</li> </ul> <p>However, the Google Contacts app does not hide any of the above for local raw contacts. Actually, the Contacts Provider does not set any account restrictions with the above data kinds.</p> <p>Lollipop (API 22) and below</p> <p>When an Account is added, from a state where no accounts have yet been added to the system, the Contacts Provider automatically sets all of the null <code>accountName</code> and <code>accountType</code> in the RawContacts table to that Account's name and type;</p> <pre><code>RawContact id: 4, accountName: vestrel00@gmail.com, accountType: com.google\nRawContact id: 5, accountName: vestrel00@gmail.com, accountType: com.google\nRawContact id: 6, accountName: vestrel00@gmail.com, accountType: com.google\nRawContact id: 7, accountName: vestrel00@gmail.com, accountType: com.google\n</code></pre> <p>RawContacts inserted without an associated account will automatically get assigned to an account if there are any available. This may take a few seconds, whenever the Contacts Provider decides to do it. Dissociating RawContacts from Accounts will result in the Contacts Provider associating those back to an Account.</p> <p>Marshmallow (API 23) and above</p> <p>The Contacts Provider no longer associates local contacts to an account when an account is or becomes available. Local contacts remain local.</p> <p>Account removal</p> <p>Removing the Account will remove all of the associated rows in the local RawContact, Data, and  Groups tables. This includes user Profile data in those tables.</p> <p>SyncColumns modifications</p> <p>This library supports modifying the <code>SyncColumns.ACCOUNT_NAME</code> and <code>SyncColumns.ACCOUNT_TYPE</code> of the RawContacts table in some cases only. In some cases does not work as intended and produces unwanted side-effects. It probably has something to do with syncing with remote servers and local Account / sync data not matching up similar to errors on network requests if the system time does not match network time.</p> <p>The motivation behind changing the Account columns of the RawContacts table rows is that it would allow users to;</p> <ul> <li>Associate local RawContacts (those that are not associated with an Account) to an Account,   allowing syncing between devices.</li> <li>Dissociate RawContacts from their Account such that they remain local to the device and not synced   between devices.</li> <li>Transfer RawContacts from one Account to another.</li> </ul> <p>When modifying the SyncColumns directly, the first works as intended. The second works with some unwanted side-effects. The third does not work at all and produces unwanted side-effects.</p> <p>These are the behaviors that I have found;</p> <ol> <li>Associating local RawContact A to Account X.<ul> <li>Works as intended.</li> <li>RawContact A is now associated with Account X and is synced across devices.</li> </ul> </li> <li>Dissociating RawContact A (setting the SyncColumns' Account name and type to null) from Account X.<ul> <li>Partially works with some unwanted-side effects.</li> <li>Dissociates RawContact A from the device but not other devices.</li> <li>RawContact A is no longer visible in the AOSP Contacts app UNLESS it retains the group   membership to at least the default group from an Account.</li> <li>At this point, RawContact A is a local contact. Changes to this local RawContact A will not be   synced across devices.</li> <li>If RawContact A is updated in another device and synced up to the server, then a syncing   side-effect occurs because the RawContact A in the device is different from the RawContact A   in the server. This causes the Contacts Provider to create another RawContact, resulting in a   \"duplicate\". The two RawContact As may get aggregated to the same Contact depending on how   similar they are.</li> <li>If local RawContact A is re-associated back to Account X, it will still no longer be synced.</li> </ul> </li> <li>Associating RawContact A from original Account X to Account Y.<ul> <li>Does not work and have bad side-effects.</li> <li>No change in other devices.</li> <li>For Lollipop (API 22) and below, RawContact A is no longer visible in the AOSP Contacts app   and syncing Account Y in system settings fails.</li> <li>For Marshmallow (API 23) and above, RawContact A is no longer visible in the AOSP Contacts   app. RawContact A is automatically deleted locally at some point by the Contacts Provider.   Syncing Account Y in system settings succeeds.</li> </ul> </li> </ol> <p>Given that associating originally local RawContacts to an Account is the only thing that actually works, it is the only function that will be exposed to consumers.</p> <p>If consumers want to transfer RawContacts from one Account to another, they can create a copy of a RawContact associated with the desired Account and then delete the original RawContact. Same idea can be used to transform an Account-associated RawContact to a local RawContact. Perhaps we can implement some functions in this library that does these things? We won't for now because the AOSP Contacts app does not support these functions anyways. It can always be implemented later if the community really wants. </p> <p>Here are some other things to note.</p> <ul> <li>The Contacts Provider automatically creates a group membership to the default group (if exist)    of the target Account when the account changes. </li> <li>The Contacts Provider DOES NOT delete existing group memberships when the account changes.</li> </ul> <p>UPDATE: My hunch for insert copies then deleting non-null account-associated RawContacts turns  to perform an \"account move operation\" turned out to be correct (case 2 and 3). This is what apps  like the Google Contacts app does. Actually, Google Contacts app takes it even further by performing  insert-delete operation regardless of whether the RawContact is associated to an account or not (cases 1, 2, 3). It does not modify the <code>SyncColumns.ACCOUNT_NAME</code> and <code>SyncColumns.ACCOUNT_TYPE</code> even though case 1 seems to be supported (for now). We should follow what Google Contacts is doing. https://github.com/vestrel00/contacts-android/issues/168</p>"},{"location":"dev-notes/#rawcontacts-deletion","title":"RawContacts; Deletion","text":"<p>Deleting a contact's Contacts row, RawContacts row(s), and associated Data row(s) are best explained in the documentation in <code>ContactsContract.RawContacts</code>;</p> <p>When a raw contact is deleted, all of its Data rows as well as StatusUpdates, AggregationExceptions, PhoneLookup rows are deleted automatically.</p> <p>When all raw contacts associated with a Contacts row are deleted, the Contacts row itself is also deleted automatically.</p> <p>The invocation of resolver.delete(...), does not immediately delete a raw contacts row. Instead,  it sets the ContactsContract.RawContactsColumns.DELETED flag on the raw contact and removes the  raw contact from its aggregate contact. The sync adapter then deletes the raw contact from the server and finalizes phone-side deletion by calling resolver.delete(...) again and passing the  ContactsContract#CALLER_IS_SYNCADAPTER query parameter. </p> <p>Some sync adapters are read-only, meaning that they only sync server-side changes to the phone, but not the reverse. If one of those raw contacts is marked for deletion, it will remain on the phone. However it will be effectively invisible, because it will not be part of any aggregate contact.</p> <p>TLDR</p> <p>To delete a contacts and all associated rows, simply delete all RawContact rows with the desired Contacts id. Deletion of the Contacts row and associated Data row(s) will be done automatically by the Contacts Provider.</p> <p>Note that deleting a RawContacts row may not immediately delete the RawContacts row. In this case,  it is marked as deleted and its reference to a contact id is nulled. The Contact may still exist if  it still has at least one constituent RawContact that is not marked for deletion.</p> <p>\u2139\ufe0f A RawContact is marked for deletion as specified by <code>RawContactsColumns.DELETED</code>.</p> <p>Typically, deleting RawContacts immediately removes the row from the RawContacts table. However,  RawContacts row remains and is simply marked for deletion UNTIL the sync adapters syncs the changes. One of the reasons syncs do not occur is when the system sync settings are turned off for the  Account or there is no network connection.</p> <p>Such RawContacts should not be included in query results for Contacts. The AOSP and Google Contacts  app also does not show them.</p> <p>Note that local RawContacts rows (not associated with an Account) are deleted immediately as no sync needs to occur.</p>"},{"location":"dev-notes/#multiple-rawcontacts-per-contact","title":"Multiple RawContacts Per Contact","text":"<p>Each row in the Contacts table may be associated with more than one row in the RawContacts table.  The Contacts Provider may consolidate multiple contacts belonging to different accounts and combine  them into a single entry in the Contacts table whilst maintaining the separate entries in the  RawContacts table.</p> <p>A more likely scenario that causes multiple RawContacts per Contact is when two or more Contacts are \"linked\" (or \"merged\" for API 23 and below, or \"joined\" for API 22 and below).</p>"},{"location":"dev-notes/#behavior-of-linkingmergingjoining-contacts-aggregationexceptions","title":"Behavior of linking/merging/joining contacts (AggregationExceptions)","text":"<p>The AOSP Contacts app terminology has changed over time;</p> <ul> <li>API 22 and below; join / separate</li> <li>API 23; merge / unmerge</li> <li>API 24 and above; link / unlink </li> </ul> <p>However, the internals have not changed; <code>KEEP_TOGETHER</code> / <code>KEEP_SEPARATE</code>. These operations are  supported by the <code>ContactsContract.AggregationExceptions</code>.</p> <p>For example, given the following tables,</p> <pre><code>### Contacts table\nContact id: 32, displayName: X, starred: 0, timesContacted: 1, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\nContact id: 33, displayName: Y, starred: 1, timesContacted: 2, lastTimeContacted: 1573071750624, customRingtone: content://media/internal/audio/media/115, sendToVoicemail: 1\n\n### RawContacts table\nRawContact id: 30, contactId: 32, displayName: X, accountName: x@x.com, accountType: com.google, starred: 0, timesContacted: 1, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\nRawContact id: 31, contactId: 33, displayName: Y, accountName: y@y.com, accountType: com.google, starred: 1, timesContacted: 2, lastTimeContacted: 1573071750624, customRingtone: content://media/internal/audio/media/115, sendToVoicemail: 1\n\n### Data table\nData id: 57, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/group_membership, data1: 18\nData id: 58, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/name, data1: X, isPrimary: 1, isSuperPrimary: 1\nData id: 59, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: x@x.com\nData id: 60, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: xx@x.com, isPrimary: 1, isSuperPrimary: 1\nData id: 63, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/group_membership, data1: 6\nData id: 64, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/name, data1: Y, isPrimary: 1, isSuperPrimary: 1\nData id: 65, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/email_v2, data1: y@y.com\nData id: 66, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/email_v2, data1: yy@y.com, isPrimary: 1, isSuperPrimary: 1\n</code></pre> <p>When Contact X links/merges/joins Contact Y, the tables becomes;</p> <pre><code>### Contacts table\nContact id: 32, displayName: X, starred: 1, timesContacted: 2, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\n\n### RawContacts table\nRawContact id: 30, contactId: 32, displayName: X, accountName: x@x.com, accountType: com.google, starred: 0, timesContacted: 1, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\nRawContact id: 31, contactId: 32, displayName: Y, accountName: y@y.com, accountType: com.google, starred: 1, timesContacted: 2, lastTimeContacted: 1573071750624, customRingtone: content://media/internal/audio/media/115, sendToVoicemail: 1\n\n### Data table\nData id: 57, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/group_membership, data1: 18\nData id: 58, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/name, data1: X, isPrimary: 1, isSuperPrimary: 1\nData id: 59, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: x@x.com\nData id: 60, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: xx@x.com, isPrimary: 1, isSuperPrimary: 0\nData id: 63, rawContactId: 31, contactId: 32, mimeType: vnd.android.cursor.item/group_membership, data1: 6\nData id: 64, rawContactId: 31, contactId: 32, mimeType: vnd.android.cursor.item/name, data1: Y, isPrimary: 1, isSuperPrimary: 0\nData id: 65, rawContactId: 31, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: y@y.com\nData id: 66, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/email_v2, data1: yy@y.com, isPrimary: 1, isSuperPrimary: 0\n</code></pre> <p>What changed?</p> <p>Contact Y's row has been deleted and its column values have been merged into Contact X row. If the  reverse occurred (Contact Y merged with Contact X), Contact Y's row would still be deleted. The  difference is that Contact X's display name will be set to Contact Y's display name, which is done by the AOSP Contacts app manually by setting Contact Y's Data name row to be the \"default\"  (isPrimary and isSuperPrimary both set to 1).</p> <p>\u2139\ufe0f The AggregationExceptions table records the linked RawContacts' IDs in ascending order  regardless of the order used in RAW_CONTACT_ID1 and RAW_CONTACT_ID2 at the time of merging.</p> <p>The RawContacts and Data table remains the same except the joined contactId column values have now been changed to the id of Contact X. All Data rows' isSuperPrimary value has been set to 0 though  the isPrimary columns remain the same. In other words, this clears any \"default\" set before the  link. These are done automatically by the Contacts Provider during the link operation.</p> <p>What is not done automatically by the Contacts Provider is that the name row of former Contact X is set as the default. The AOSP Contacts app does this manually. The Contacts Providers automatically sets the Contact display name to whatever the default name row is for the Contact, if available. For more info on Contact display name resolution, read the Contact Display Name and Default Name Rows section.</p> <p>\u2139\ufe0f Display name resolution is different for APIs below 21 (pre-lollipop).</p> <p>The display name of the RawContacts remain the same.</p> <p>The Groups table remains unmodified.</p> <p>Options updates</p> <p>Changes to the options (starred, timesContacted, lastTimeContacted, customRingtone, and  sendToVoicemail) of a RawContact may affect the options of the parent Contact. On the other hand,  changes to the options of the parent Contact will be propagated to all child RawContact options.</p> <p>Photo updates</p> <p>A RawContact may have a full-sized photo saved as a file and a thumbnail version of that saved in the Data table in a photo mimetype row. A Contact's full-sized photo and thumbnail are simply references to the \"chosen\" RawContact's full-sized photo and thumbnail (though the URIs may differ).</p> <p>\u2139\ufe0f When removing the photo in the AOSP contacts app, the photo data row is not immediately  deleted, though the <code>PHOTO_FILE_ID</code> is immediately set to null. This may result in the <code>PHOTO_URI</code> and <code>PHOTO_THUMBNAIL_URI</code> to still have a valid image uri even though the photo has been  \"removed\". This library immediately deletes the photo data row, which seems to work perfectly.</p> <p>Data inserts</p> <p>In the AOSP Contacts app, Data inserted in combined (raw) contacts mode will be associated to the first RawContact in the list sorted by the RawContact ID. </p> <p>\u2139\ufe0f This may not be the same as the RawContact referenced by <code>ContactsColumns.NAME_RAW_CONTACT_ID</code>.</p> <p>UI changes?</p> <p>The AOSP Contacts App does not display the groups field when displaying / editing Contacts that have multiple RawContacts (linked/merged/joined) in combined mode. However, it does allow editing  individual RawContact Data rows in which case the groups field is displayed and editable.</p> <p>In the AOSP Contacts app, the name attribute used comes from the name row with IS_SUPER_PRIMARY set to true. This and all other \"unique\" mimetypes (organization) and non-unique mimetypes (email) per RawContact are shown only if they are not blank.</p> <p>Showing multiple RawContact's data in the same edit screen (combined mode)</p> <p>In older version of the AOSP, Android Open Source Project (AOSP) Contacts app, data from multiple RawContacts was being shown in the same edit screen. This caused a lot of confusion about which data belonged to which RawContact. Newer versions of AOSP Contacts only allow editing one RawContact at a time to avoid confusion. Though, several RawContacts' data are still shown (not-editable)  in the same screen.</p>"},{"location":"dev-notes/#aggregationexceptions-table","title":"AggregationExceptions table","text":"<p>Given the following Contacts and their RawContacts;</p> <ul> <li>Contact A<ul> <li>RawContact 1</li> </ul> </li> <li>Contact B<ul> <li>RawContact 2</li> </ul> </li> <li>Contact C<ul> <li>RawContact 3</li> </ul> </li> <li>Contact D<ul> <li>RawContact 4</li> </ul> </li> </ul> <p>Linking one by one in this order;</p> <ul> <li>Contact B link Contact A</li> <li>Contact C link Contact D</li> <li>Contact C link Contact B</li> </ul> <p>Results in the following AggregationExceptions rows respectively;</p> <pre><code>Aggregation exception id: 430, type: 1, rawContactId1: 1, rawContactId2: 2\n</code></pre> <pre><code>Aggregation exception id: 430, type: 1, rawContactId1: 1, rawContactId2: 2\nAggregation exception id: 432, type: 1, rawContactId1: 3, rawContactId2: 4\n</code></pre> <pre><code>Aggregation exception id: 436, type: 1, rawContactId1: 1, rawContactId2: 2\nAggregation exception id: 439, type: 1, rawContactId1: 1, rawContactId2: 3\nAggregation exception id: 442, type: 1, rawContactId1: 1, rawContactId2: 4\nAggregation exception id: 440, type: 1, rawContactId1: 2, rawContactId2: 3\nAggregation exception id: 443, type: 1, rawContactId1: 2, rawContactId2: 4\nAggregation exception id: 444, type: 1, rawContactId1: 3, rawContactId2: 4\n</code></pre> <p>There is a pattern here. RawContact ids are sorted in ascending order and linked from least to  greatest exhaustively but no double links (1-2 is the same as 2-1).</p> <ul> <li>RawContact 1 has a row with RawContact 2, 3, and 4.</li> <li>RawContact 2 has a row with RawContact 3 and 4.</li> <li>RawContact 3 has a row with RawContact 4.</li> </ul> <p>Linking all in one go;</p> <ul> <li>Contact C link Contact A, B, D</li> </ul> <p>Results in the same AggregationExceptions rows.</p> <p>Unlinking results in the same AggregationExceptions rows except the type is 2  (TYPE_KEEP_SEPARATE).</p>"},{"location":"dev-notes/#data-table","title":"Data Table","text":"<p>The Data table uses generic column names (e.g. \"data1\", \"data2\", ...) using the column \"mimetype\" to distinguish the type of data in that generic column. For example, the column name of  <code>StructuredName.DISPLAY_NAME</code> is the same as <code>Email.ADDRESS</code>, which is \"data1\". </p> <p>Each row in the Data table consists of a piece of RawContact data (e.g. a phone number), its \"mimetype\", and the associated RawContact and Contact id. A row does not contain all of the data for a contact.</p> <p>RawContacts may only have one row of certain mimetypes and may have multiple rows of other  mimetypes. Here is the list.</p> <p>Unique mimetype per RawContact</p> <ul> <li>Name (StructuredName)</li> <li>Nickname</li> <li>Note</li> <li>Organization</li> <li>Photo</li> <li>SipAddress</li> </ul> <p>Non-unique mimetype per Raw Contact</p> <ul> <li>Address (StructuredPostal)</li> <li>Email</li> <li>Event</li> <li>GroupMembership</li> <li>Im</li> <li>Phone</li> <li>Relation</li> <li>Website</li> </ul> <p>Although some mimetypes are unique per RawContact, none of those mimetypes are unique per Contact because a Contact is an aggregate of one or more RawContacts!</p>"},{"location":"dev-notes/#data-primary-and-super-primary-rows","title":"Data Primary and Super Primary Rows","text":"<p>As per documentation, for a set of data rows with the same mimetype (e.g. a set of emails), there  should only be one primary data row (e.g. email) per RawContact and one super primary data row per Contact. Furthermore, a data row that is super primary must also be primary.</p> <p>Unfortunately, the Contacts Provider does not do any data set validation for the Data columns  <code>IS_PRIMARY</code> and <code>IS_SUPER_PRIMARY</code>. This means that it is possible to set more than one data row of the same mimetype as primary for the same RawContact and super primary for the same aggregate Contact. It is also possible to set a data row as super primary but not primary. Upholding the the contract is left to us... </p> <p>For example, given this relationship;</p> <ul> <li>Contact<ul> <li>RawContact X<ul> <li>Email A</li> <li>Email B</li> </ul> </li> <li>RawContact Y<ul> <li>Email C</li> <li>Email D</li> </ul> </li> </ul> </li> </ul> <p>When Emails A, B, C, and D are inserted with the RawContacts or after the RawContacts have been  created, we get the following state;</p> Email Primary Super Primary A 0 0 B 0 0 C 0 0 D 0 0 <p>The state does not change when RawContact X is linked with RawContact Y.</p> <p>After setting Email A as the \"default\" email, it becomes primary and super primary;</p> Email Primary Super Primary A 1 1 B 0 0 C 0 0 D 0 0 <p>Then setting Email B as the default email, it becomes primary and super primary. Email A is no longer primary or super primary.</p> Email Primary Super Primary A 0 0 B 1 1 C 0 0 D 0 0 <p>Then setting Email C as the default email, it becomes primary and super primary. Email B is still primary because it belongs to a different RawContact than Email C. However, Email B is no longer the super primary as there can only be one per aggregate Contact.</p> Email Primary Super Primary A 0 0 B 1 0 C 1 1 D 0 0 <p>Then setting Email D as the default email, it becomes primary and super primary. Email C is no  longer primary or super primary.</p> Email Primary Super Primary A 0 0 B 1 0 C 0 0 D 1 1 <p>Then clearing the default email D, removes its primary and super primary status. However, email B  remains a primary but not a super primary.</p> Email Primary Super Primary A 0 0 B 1 0 C 0 0 D 0 0 <p>The above behavior is observed from the AOSP Contacts app. The \"super primary\" data of an  aggregate Contact is referred to as the \"default\".</p> <p>\u2139\ufe0f At this point, the AOSP Contacts app still shows email B as the first email in the list even though it isn't the \"default\" (super primary) because it is still a primary. This adds a bit of confusion in my opinion, especially when more than 2, 3, or 4 RawContacts are linked. A \"fix\"  would be to only order the list of emails using \"super primary\" instead of \"super primary\" and  \"primary\". OR to remove the primary status of the data set of all linked RawContacts.</p> <p>One benefit of the AOSP Contacts implementation of this is that it retains the primary status when unlinking RawContacts. </p> <p>This library should follow what the AOSP Contacts app is doing in spirit of recreating the AOSP experience as closely as possible, even if it seems like a lesser experience.</p>"},{"location":"dev-notes/#data-table-joins","title":"Data Table Joins","text":"<p>All columns accessible via cursors returned from Data table queries are specified in <code>DataColumnsWithJoins</code>, which includes the <code>DataColumns</code>, <code>ContactsColumns</code>, and <code>ContactOptionsColumns</code>. In code, mentions of the \"Data table\" typically refers to the joined table.</p> <p>The <code>DataColumns</code> gives us access to all of the columns in the Data table. All other joined columns, including the <code>ContactsColumns</code> are appended to each row in the query. This means that the  <code>ContactsColumns</code>; <code>DISPLAY_NAME</code>, <code>PHOTO_URI</code>, and <code>PHOTO_THUMBNAIL_URI</code> are repeated for all Data rows belonging to the same Contact.</p> <p>The <code>ContactOptionsColumns</code> values joined with the Data table are the values of the Contact, not the RawContact that the Data row belongs to! The same applies to the \"display_name\".</p>"},{"location":"dev-notes/#data-updates","title":"Data Updates","text":"<p>A new row in the Data table is created for each new piece of data (e.g. email address) entered for  the contact. </p> <p>Removing a piece of existing data results in the deletion of the row in the Data table if that row no longer contains any meaningful data (no meaningful non-null \"datax\" columns left). This is the  behavior of the AOSP Android Contacts app. Therefore, querying for null fields is not possible.  For example, there may be no Data rows that exist where the email address is null. Thus, a query to  search for all contacts with null email address may return 0 contacts even if there are some contacts without email addresses.</p>"},{"location":"dev-notes/#data-required","title":"Data Required","text":"<p>Creating blank RawContacts without email address (or other fields), results in no rows in the Data table for the email address, and all other fields. There are a few exceptions. The following  Data rows are automatically created for all contacts, if not provided;</p> <ul> <li>Group membership, underlying value defaults to the account's default system group</li> <li>Name, underlying value defaults to null</li> <li>Nickname, underlying value defaults to null</li> <li>Note, underlying value defaults to null</li> </ul> <p>\u2139\ufe0f All of the above rows are only automatically created for RawContacts that are associated with an Account.</p> <p>If a valid account is provided, the default (auto add) system group membership row is automatically created immediately by the Contacts Provider at the time of contact insertion. The name, nickname, and note are automatically created at a later time.</p> <p>If a valid account is not provided, none of the above data rows are automatically created.</p> <p>Blank RawContacts</p> <p>The Contacts Providers allows for RawContacts that have no rows in the Data table (let's call them \"blanks\") to exist. The AOSP Contacts app does not allow insertion of new RawContacts without at least one data row. It also deletes blanks on update. Despite seemingly not allowing blanks, the AOSP Contacts app shows them.</p> <p>There are two scenarios where blanks may exist.</p> <ol> <li>Contact with RawContact(s) with no Data row(s).<ul> <li>In this case, the Contact is blank as well as its RawContact(s).</li> </ul> </li> <li>Contact that has RawContact with Data row(s) and a RawContact with no Data row.<ul> <li>In this case, the Contact and the RawContact with Data row(s) are not blank but the RawContact with no Data row is blank.</li> </ul> </li> </ol>"},{"location":"dev-notes/#data-structuredname","title":"Data <code>StructuredName</code>","text":"<p>The <code>DISPLAY_NAME</code> is the unstructured representation of the name. It is made up of structured components; <code>PREFIX</code>, <code>GIVEN_NAME</code>, <code>MIDDLE_NAME</code>, <code>FAMILY_NAME</code>, and <code>SUFFIX</code>.</p> <p>When updating or inserting a row;</p> <ul> <li>If the display name is null and there are non-null structured components provided (e.g. given and   family name), the Contacts Provider will automatically set the display name by combining the   structured components.</li> <li>If the display name is not null and all structured components are null, the Contacts Provider   automatically (to the best of its ability) derive the values for all the structured components.</li> <li>If the display name and structured components are not null, the Contacts Provider does nothing   automatically.</li> </ul>"},{"location":"dev-notes/#data-structuredpostal","title":"Data <code>StructuredPostal</code>","text":"<p>The <code>FORMATTED_ADDRESS</code> is the unstructured representation of the postal address. It is made up of structured components; <code>STREET</code>, <code>POBOX</code>, <code>NEIGHBORHOOD</code>, <code>CITY</code>, <code>REGION</code>, <code>POSTCODE</code>, and <code>COUNTRY</code>.</p> <p>When updating or inserting a row;</p> <ul> <li>If the formatted address is null and there are non-null structured components provided (e.g.   street and city), the Contacts Provider will automatically set the formatted address by combining   the structured components.</li> <li>If the formatted address is not null and all structured components are null, the Contacts Provider   automatically sets the street value to the formatted address.</li> <li>If the formatted address and structured components are not null, the Contacts Provider does   nothing automatically.</li> </ul>"},{"location":"dev-notes/#groups-table-accounts","title":"Groups Table &amp; Accounts","text":"<p>Contacts are assigned to one or more groups via the <code>GroupMembership</code>. It typically looks like this;</p> <pre><code>Group id: 1, systemId: Contacts, isReadOnly: 1, title: My Contacts, favorites: 0, autoAdd: 1, accountName: vestrel00@gmail.com, accountType: com.google\nGroup id: 2, systemId: null, isReadOnly: 1, title: Starred in Android, favorites: 1, autoAdd: 0, accountName: vestrel00@gmail.com, accountType: com.google\nGroup id: 3, systemId: Friends, isReadOnly: 1, title: Friends, favorites: 0, autoAdd: 0, accountName: vestrel00@gmail.com, accountType: com.google\nGroup id: 4, systemId: Family, isReadOnly: 1, title: Family, favorites: 0, autoAdd: 0, accountName: vestrel00@gmail.com, accountType: com.google\nGroup id: 5, systemId: Coworkers, isReadOnly: 1, title: Coworkers, favorites: 0, autoAdd: 0, accountName: vestrel00@gmail.com, accountType: com.google\nGroup id: 6, systemId: null, isReadOnly: 0, title: Custom Group, favorites: 0, autoAdd: 0, accountName: vestrel00@gmail.com, accountType: com.google\n</code></pre> <p>The actual groups are in a separate table; Groups. Each group is associated with an Account. The  AOSP Contacts app does not allow for Groups to exist without an Account. However, other apps such as the Google Contacts app allows for Groups with a null account. The Contacts Provider also allows this. Therefore, we will allow Group without accounts in this library and let library users decide if they want to restrict groups to non-null accounts.</p> <p>Each account will have its own set of the above system groups. This means that there may be multiple groups with the same title belonging to different accounts.</p> <p>System ids are typically Contacts, Friends, Family, and Coworkers. These ids are typically the same across all copies of Android. Notes; - The Contacts system group is the default group in which all raw contacts of an account belongs to.   Therefore, it is typically hidden when showing the list of groups in the UI. - The starred (favorites) group is not a system group as it has null system id. However, it behaves   like one in that it is read only and it comes with most (if not all) copies of the AOSP app.</p> <p>Removing the Account will delete all of the associated rows in the Groups table.</p> <p>Groups, duplicate titles</p> <p>The Contacts Provider allows multiple groups with the same title (case-sensitive comparison)  belonging to the same account to exist. In older versions of Android, the AOSP Contacts app  allows the creation of new groups with existing titles. In newer versions, duplicate titles are not  allowed. Therefore, this library does not allow for duplicate titles.</p> <p>\u2139\ufe0f In newer versions, the group with the duplicate title gets deleted either automatically by the  Contacts Provider or when viewing groups in the AOSP Contacts app. It's not an immediate failure  on insert or update. This could lead to bugs!</p>"},{"location":"dev-notes/#groups-table-groupmemberships-data-table","title":"Groups Table &amp; GroupMemberships (Data Table)","text":"<p>There may be multiple groups with the same title from different accounts. Therefore, the group membership should point to the group belonging to the same account as the raw contact. The AOSP Contacts app displays only the groups belonging to the selected account.</p> <p>Updating group memberships of existing raw contacts seem to be almost instant. All raw contacts must be a part of at least the default group (system id is \"Contacts\"). Raw contacts with no group membership will be asynchronously added to the Account's default group by the Contacts Provider.</p> <p>Membership to the default group should never be deleted!</p>"},{"location":"dev-notes/#starred-in-android-favorites","title":"Starred in Android (Favorites)","text":"<p>When the <code>ContactOptionsColumns.STARRED</code> column of a Contact in the Contacts table is set to true, the Contacts Provider automatically adds a group membership to the favorites group for all  RawContacts linked to the Contact. Setting <code>STARRED</code> to false removes all group memberships to the favorites group.</p> <p>The <code>STARRED</code> is interdependent with group memberships to the favorites group. Adding a group  membership to the favorites group results in <code>STARRED</code> being set to true. Removing the membership  sets it to false.</p> <p>Raw contacts that are not associated with an account do not have any group memberships. Even though these raw contacts may not have a membership to the favorites group, they may still be \"starred\" (favorited) via the <code>ContactOptionsColumns.STARRED</code> column in the Contacts table, which is not dependent on the existence of a favorites group membership.</p> <p>Refresh RawContact instances after changing the starred value. Otherwise, performing an update  on the RawContact with a stale set of group memberships may revert the star/unstar operation. For  example, query returns a starred RawContact -&gt; set starred to false -&gt; update RawContact (still  containing a group membership to the favorites group) -&gt; starred will be set back to true.</p>"},{"location":"dev-notes/#group-memberships-local-rawcontacts","title":"Group memberships &amp; Local RawContacts","text":"<p>Local RawContacts may have a group membership to the default system group of an Account without being associated with the Account...</p> <p>The AOSP Contacts app may not have an edit-RawContact option for newly inserted RawContacts that have no group membership to the default group when an Account is available. Though, edits can still be made in other ways. Instead, an option to \"Add to contacts\" is shown that adds a membership to the default group but does not associate the raw contact to the Account that owns the group. The edit UI does not show the group membership field.</p> <p>Weirdly, this only occurs when there is exactly only one Account. If there are no Accounts or there are two or more Accounts, then this does not occur. Also, this does not occur for a Contact with a RawContact that has a group membership AND a RawContact that has no group membership.</p>"},{"location":"dev-notes/#groups-deletion","title":"Groups; Deletion","text":"<p>Similar to deleting RawContacts, deleting a Groups row may not immediately delete the Groups row.  In this case, it is marked as deleted. </p> <p>\u2139\ufe0f A Group is marked for deletion as specified by <code>GroupsColumns.DELETED</code>.</p> <p>Typically, deleting Groups immediately removes the row from the Groups table. However, Groups row remains and is simply marked for deletion UNTIL the sync adapters syncs the changes. One of the reasons syncs do not occur is when the system sync settings are turned off for the Account or there is no network connection.</p> <p>Such Groups should not be included in query results for Contacts. The AOSP and Google Contacts app  also does not show them.</p> <p>Note that local Groups rows (not associated with an Account) are deleted immediately as no sync needs to occur.</p>"},{"location":"dev-notes/#groups-ui","title":"Groups; UI","text":"<p>In newer Android versions of the AOSP Contacts app, \"groups\" are now being referred to as \"labels\". However, the underlying code still uses groups. Google is probably just trying to make it more user friendly by calling it label instead of group.</p>"},{"location":"dev-notes/#user-profile","title":"User Profile","text":"<p>There exist one (profile) Contacts row that identifies the user; <code>ContactsColumns.IS_USER_PROFILE</code>. There is at least one RawContacts row that is associated with the user profile; <code>RawContactsColumns.RAW_CONTACT_IS_USER_PROFILE</code>. Associated RawContacts may or may not be associated with an Account. The RawContacts row(s) may have rows in the Data table as usual. These profile table rows have special IDs that differ from regular rows. See <code>ContactsContract.isProfileId</code>.</p> <p>\u2139\ufe0f The Contacts Provider will throw an IllegalArgument exception when attempting to include <code>ContactsColumns.IS_USER_PROFILE</code> and <code>RawContactsColumns.RAW_CONTACT_IS_USER_PROFILE</code> columns in Data table queries. I have not yet tried including these columns in the Contacts or RawContacts table queries.</p> <p>The profile Contact row may not be merged / linked with other contacts and do not belong to any group (favorites / starred).</p> <p>Profile rows in the Contacts, RawContacts, and Data table are not visible via queries in the respective tables. They will not be in the resulting cursor. To get the profile Contacts table rows, query the <code>Profile.CONTENT_URI</code>. To get profile RawContacts table rows, query the <code>Profile.CONTENT_RAW_CONTACTS_URI</code>. To get the profile Data table rows, query the <code>Profile.CONTENT_RAW_CONTACTS_URI</code> appended with the RawContact id and <code>RawContacts.Data.CONTENT_DIRECTORY</code>.</p> <p>To insert a new profile RawContact, use <code>Profile.CONTENT_RAW_CONTACTS_URI</code>. It will automatically be associated with the profile Contact. If the profile Contact does not yet exist, it will be created automatically.</p> <p>To insert a new profile Data row, either;</p> <ul> <li>insert to the <code>Profile.CONTENT_RAW_CONTACTS_URI</code> appended with the RawContact id and <code>RawContacts.Data.CONTENT_DIRECTORY</code></li> <li>insert to the Data table directly, referencing the RawContact id</li> </ul> <p>Same rules apply to all table rows. If all profile RawContacts table rows have been deleted, then associated Contacts and Data table rows will automatically be deleted.</p> <p>Profile aggregation</p> <p>The RawContacts of a (Contact) Profile are linked via the indexed rows; <code>Profile.CONTENT_RAW_CONTACTS_URI</code>. Therefore, the AggregationsExceptions table is not used here.</p> <p>Profile and users</p> <p>Note that as of Android 5 Lollipop, there may exist multiple users in a device. Each user has a separate list of accounts and contact data. This also means that each user has a separate (local) profile contact.</p> <p>Profile and Accounts</p> <p>According to the <code>Profile</code> documentation; \"... each account (including data set, if applicable) on the device may contribute a single raw contact representing the user's personal profile data from that source.\"</p> <p>In other words, one account can have one profile RawContact. Whether or not profile RawContacts associated to an Account can be carried over and synced across devices and users is up to the Contacts Provider / Sync provider for that Account.</p> <p>\u2139\ufe0f From my experience, profile RawContacts associated to an Account is not carried over / synced across devices or users.</p> <p>Despite the documentation of \"one profile RawContact per one Account\", the Contacts Provider allows for multiple RawContacts per Account, including multiple local RawContacts (no Account). Thus, we should let consumers exploit this but set defaults to be one-for-one.</p> <p>Creating / setting up the profile in the AOSP Contacts app results in the creation of a local RawContact (not associated with an Account) even if there are available Accounts.</p> <p>The Contacts Provider does not associate local contacts to an account when an account is or becomes available (regardless of API level).</p> <p>Removing the Account will delete all of the associated rows in the Contact, RawContact, Data, and Groups tables. This includes user Profile data in those tables.</p> <p>Profile permissions</p> <p>Profile permissions (READ_PROFILE and WRITE_PROFILE) have been removed since API 23. However, they are still required for API 22 and below. Reading and writing the profile is included in the Contacts permissions. There is no need to ask for profile permissions at runtime because prior to API 23, permissions in the AndroidManifest have to be accepted prior to installation.</p>"},{"location":"dev-notes/#syncing-data-sync-adapters","title":"Syncing Data / Sync Adapters","text":"<p>First, it\u2019s good to know the official documentation of sync adapters;  https://developer.android.com/guide/topics/providers/contacts-provider#SyncAdapters</p> <p>Now, let\u2019s ingest the official docs\u2026 Data belonging to a RawContact that is associated with a Google  account will be available anywhere the Google account is used; in any Android or iOS device, a web  browser, etc\u2026 Data is synced by Google\u2019s sync adapters to and from their remote servers. Syncing  depends on the account sync settings, which can be configured in the AOSP system settings app and  possibly through some remote configuration.</p> <p>This library does not provide any sync adapters. Instead, it relies on existing sync adapters to do  the syncing. Sync adapters and syncing are really out of scope of this library. Syncing is its own  thing that typically happens outside of an application UI. This library is focused on reading and  writing AOSP and custom data to and from the local database. Syncing the local database to and  from a remote service is a different story altogether =)</p>"},{"location":"dev-notes/#custom-data-mimetypes","title":"Custom Data / MimeTypes","text":"<p>First, it\u2019s good to know the official documentation of custom data rows;  https://developer.android.com/guide/topics/providers/contacts-provider#CustomData</p> <p>Now, let\u2019s ingest the official docs\u2026 Custom mimetypes do not belong to the AOSP Contacts Provider  mimetype set (e.g. address, email, phone, etc). The Contacts Provider allows for the creation of  new / custom mimetypes. This is especially useful for other apps (Google Contacts, Facebook,  Twitter, WhatsApp, etc) that want to attach extra pieces of data to a particular RawContact.</p> <p>Custom data are NOT synced, including those that belong to RawContacts that are associated with an  Account. Custom sync adapters are required to sync custom data. This library currently does NOT  provide custom sync adapters to sync custom data!</p> <p>Custom data from other apps such as Facebook, Twitter, WhatsApp, etc may or may not be synced. It  all depends on those applications and their custom sync adapters (if they have any) and sync settings.</p> <p>For insight on how aforementioned social media services may be syncing their data, read through the  official documentation; https://developer.android.com/guide/topics/providers/contacts-provider#SocialStream</p>"},{"location":"dev-notes/#unused-contactscontract-stuff","title":"Unused ContactsContract Stuff","text":"<p>We are currently not utilizing these things because I haven't found usages of them while using the AOSP Contacts app. They are probably working behind the scenes but until we find uses for these, let's leave it out because YAGNI.</p> <ul> <li><code>Settings</code>. Contacts-specific settings for various Accounts (settings for an Account).<ul> <li>Might be useful to add this for <code>SHOULD_SYNC</code> and <code>UNGROUPED_VISIBLE</code>.</li> </ul> </li> <li><code>ContactsColumns.IN_VISIBLE_GROUP</code> + <code>Groups.GROUP_VISIBLE</code>. Flag indicating if the contacts    belonging to this group should be visible in any user interface.</li> </ul>"},{"location":"dev-notes/#java-support","title":"Java Support","text":"<p>This library is intended to be Java-friendly. The policy is that we should attempt to write  Java-friendly code that does not increase lines of code by much or add external dependencies to  cater exclusively to Java users.</p>"},{"location":"dev-notes/#creating-entities-data-class","title":"Creating Entities &amp; data class","text":"<p>First, consumers are not allowed to create immutable entities. Those must come from the API itself to ensure data integrity. Whether or not we will change this in the future is debatable =)</p> <p>~~Consumers are able to set read-only and private or internal variables though because all <code>Entity</code>  implementations are data classes. Data classes provide a <code>copy</code> function that allows for setting any property no matter their visibility and even if the constructor is private. As a matter of fact,  setting the constructor of a <code>data class</code> as <code>private</code> gives this warning by Android Studio:  \"Private data class constructor is exposed via the 'copy' method.~~</p> <p>~~There is currently no way to disable the <code>copy</code> function of data classes (that I know of). The only thing we can do is to provide documentation to consumers, insisting against the use of the <code>copy</code> method as it may lead to unwanted side effects when updating and deleting contacts.~~</p> <p>~~\u2139\ufe0f We could just use regular classes instead of data classes but entities should be data classes because it is what they are (know what I mean?!). Also, I'd hate to have to generate equals and hashcode functions for them, which will make the code harder to maintain. Though, we might do this anyways at some point if we want to make it possible for a mutable entity to equal an immutable entity. Time will tell =)~~</p> <p>https://discuss.kotlinlang.org/t/data-class-copy-visibility-modifier/19746</p> <p>As of https://github.com/vestrel00/contacts-android/issues/358, the above notes that have been ~~strikethrough~~ no longer apply =) </p>"},{"location":"dev-notes/#immutable-vs-mutable-entities","title":"Immutable vs Mutable Entities","text":"<p>This library provides true immutability for immutable entities.</p> <p>Take a look at the current (simplified) hierarchy;</p> <pre><code>sealed interface ContactEntity {\n    val rawContacts: List&lt;RawContactEntity&gt;\n}\ndata class Contact(\n    override val rawContacts: List&lt;RawContact&gt;\n) : ContactEntity\ndata class MutableContact(\n    override val rawContacts: List&lt;MutableRawContact&gt;\n) : ContactEntity\n\nsealed interface RawContactEntity\ndata class RawContact(\n    val addresses: List&lt;Address&gt;\n) : RawContactEntity\ndata class MutableRawContact(\n    val addresses: MutableList&lt;MutableAddress&gt;\n) : RawContactEntity\n\ndata class Address(\n    val formattedAddress: String?\n)\ndata class MutableAddress(\n    var formattedAddress: String?\n)\n</code></pre> <p>\u2139\ufe0f The use of <code>sealed class</code> is to prevent consumers from defining their own entities. This restriction may or may not change in the future.</p> <p>Notice that there is nothing mutable in the immutable <code>Contact</code>. Everything are <code>val</code>s and the data structures used (i.e. <code>RawContact</code>, <code>Address</code>, and <code>List</code>) are all immutable. This provides consumers 100% confidence that immutable entities are not mutable. They will not change or mutate in any way. Once they are constructed, they will always remain the same.</p> <p>Why immutability is so important will not be covered in this dev notes because it would be too big (that's what she said) and there are blogs and books written about this. One of the most important advantages of immutability is that it is thread-safe. Immutable instances can be used in several different threads without the need for synchronization and worries about deadlocks. In other words, they are thread-safe and faster than the mutable version.</p> <p>The current structure also allows consumers to be able to distinguish between immutable and mutable entities exhaustively. E.G.</p> <pre><code>fun doSomethingAndReturn(contact: ContactEntity) = when (contact) {\n    is Contact -&gt; {}\n    is MutableContact -&gt; {}\n}\n</code></pre> <p>\u2139\ufe0f The mutable entities provided in this library are NOT thread-safe. Consumers will have to  perform their own synchronizations if they want to use and mutate mutable entities in multi-threaded scenarios.</p>"},{"location":"dev-notes/#the-cost-of-the-current-immutability-implementation","title":"The cost of the current immutability implementation","text":"<p>The cost of implementing true immutability is more lines of code. Notice that the <code>MutableContact</code> does not inherit from <code>Contact</code>. The same goes for the other entities. This leads to having to write seemingly duplicate code when writing functions and extensions.</p> <p>// FIXME? Furthermore, equality between immutable and mutable entities are not yet implemented. This means that <code>Contact(\"john\") == MutableContact(\"john\")</code> will return false even though their underlying contents are the same. This can be fixed by overriding the equals and hashcode functions of all entities. However, that is a lot more code that I would like to avoid, which is why I'm using <code>data class</code> for all entities in the first place! This may change in the future if the community really wants to change it =)</p> <p>On a side note, the same cost is incurred by Kotlin's standard libs. For example, notice that <code>AbstractMutableList</code> does not inherit from and is completely separate from <code>AbstractList</code>. I'm sure stdlib devs also had to write seemingly duplicate code in implementations of the <code>List</code> interface.</p>"},{"location":"dev-notes/#avoiding-the-cost-shortcuts-and-pitfalls","title":"Avoiding the cost... Shortcuts and pitfalls.","text":"<p>One thing that may come to mind in attempts to reduce lines of seemingly duplicate code is to have just a mutable implementation of an immutable declaration. For example, we can restructure the hierarchy to;</p> <pre><code>sealed interface Contact {\n    val rawContacts: List&lt;RawContact&gt;\n}\ndata class MutableContact(\n    override val rawContacts: List&lt;MutableRawContact&gt;\n) : Contact\n\nsealed interface RawContact {\n    val addresses: List&lt;Address&gt;\n}\ndata class MutableRawContact(\n    override var addresses: MutableList&lt;MutableAddress&gt;\n) : RawContact\n\nsealed interface Address {\n    val formattedAddress: String?\n}\ndata class MutableAddress(\n    override var formattedAddress: String?\n) : Address\n</code></pre> <p>Notice that there is a non-concrete declaration (i.e. <code>Contact</code>, <code>RawContact</code>, and <code>Address</code>) and just one concrete implementation (i.e. <code>MutableContact</code>, <code>MutableRawContact</code>, and <code>MutableAddress</code>).</p> <p>\u2139\ufe0f A <code>val</code> declaration can be overridden by a <code>var</code>. Keep in mind that <code>val</code> only requires getters whereas <code>var</code> requires both getters and setters. Therefore, a <code>var</code> cannot be overridden by a  <code>val</code>. Or maybe there is a different reason Kotlin imposes this restriction. On a similar note,  the <code>List</code> interface can be overridden to a <code>MutableList</code>.</p> <p>We, as API contributors, can avoid having to write seemingly duplicate functions and extensions!</p> <p>However! Can you see what's wrong with this setup? If we do this, we would either be deceiving consumers to think that the instances of \"immutable\" class signatures (i.e. <code>Contact</code>, <code>RawContact</code>, and <code>Address</code>) are actually immutable OR we would have to let consumers know that the API does not really provide true immutability. Neither option is ideal (nor is it acceptable IMO).</p> <p>Consumers would have a reference to a <code>Contact</code>, which they may assume is immutable because of the usage of <code>val</code> instead of <code>var</code>, but in actuality the underlying implementation is mutable... This could be a cause of really hard to find bugs in multi-threaded usage. Consumers may use <code>Contact</code> with the assumption that it is immutable only to find that it can actually be mutated! We could fix this by just making the mutable implementation thread-safe but since that is the only implementation, consumers will be forced to use thread-safe code when they don't have to thereby negatively affecting performance.</p> <p>Keep in mind that thread safety is only one of several reasons for immutability. Those other reasons will be violated too.</p> <p>Consumers will be shocked if they ever do the following or something similar.</p> <pre><code>fun x(contact: Contact) = when(contact) {\n    is MutableContact -&gt; {} // this is always true\n    is Contact -&gt; {} // this is always true\n}\n</code></pre> <p>In any case, I have to admit, it is a nice trick that would save API contributors time. But that's just it! It's just a trick. A shortcut. A nice little time save at the cost of integrity. It is not worth it (IMO).</p>"},{"location":"dev-notes/#why-not-add-android-x-support-library-dependencies","title":"Why Not Add Android X / Support Library Dependencies?","text":"<p>I want to keep the dependency list of this library to a minimum. The Contacts Provider is AOSP to Android since the beginning. I want to honor that fact by avoiding adding dependencies here. I made a bit of an exception by adding a permissions handling library for the permissions modules (not in  the core modules). I'm tempted to remove the permissions dependency and implement permissions  handling myself because external dependencies brings in other dependencies with it. However, it is  not part of the core module so I'm able to live with this.</p> <p>Keeping dependencies to a minimum is just a small challenge I made up. We will see how long it can last!</p> <p>I left comments all over the code on when an androidx dependency may be useful. The most glaring example of this is @WorkerThread. Even with that, I'll hold off on adding the androidx annotation lib. I think we can all be consenting adults =)</p> <p>If the community strongly desires the addition of these support libs, then the community will win =)</p>"},{"location":"accounts/move-raw-contacts-across-accounts/","title":"Move RawContacts across Accounts","text":"<p>This library provides the <code>MoveRawContactsAcrossAccounts</code> API, which allows you to move RawContacts from one Account to another, including a null Account.</p> <p>This API functions identically to the Google Contacts app. Copies of RawContacts are inserted into the Contacts Provider database under a different account and the original RawContacts are deleted  afterwards. RawContact and Data values are also copied over.</p> <p>In other words, this is a copy-insert-delete operation. New rows are created in the RawContact,  Contact, and Data tables with the same values from the original. Then, the original rows are deleted.</p> <p>\u26a0\ufe0f The APIs for this have changed significantly since version 0.3.0. For documentation for version 0.2.4 and below, only supported moving local RawContacts to an Account, visit this page (click me).</p> <p>An instance of the <code>MoveRawContactsAcrossAccounts</code> API is obtained by,</p> <pre><code>val move = Contacts(context).accounts().move()\n</code></pre> <p>\u2139\ufe0f For more info on syncing, read Sync contact data across devices.</p> <p>\u2139\ufe0f For more info on local RawContacts, read about Local (device-only) contacts.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#basic-usage","title":"Basic usage","text":"<p>To move a given RawContacts to another account,</p> <pre><code>val moveResult = move.rawContactsTo(account, rawContact).commit()\n</code></pre> <p>If you only have the RawContact's ID,</p> <pre><code>val moveResult = move.rawContactsWithIdsTo(account, rawContactId).commit()\n</code></pre>"},{"location":"accounts/move-raw-contacts-across-accounts/#account-validation","title":"Account validation","text":"<p>By default, all Accounts in the system are queried in order to ensure that each<code>Entry.targetAccount</code> is in the system. For Accounts that are not in the system, null is used instead. This guards  against invalid accounts.</p> <p>You may explicitly enable or disable this,</p> <pre><code>.validateTargetAccounts(true|false)\n</code></pre> <p>\u2139\ufe0f This may affect performance. When this is set to true, the API executes extra lines of code to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to false.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#executing-the-move","title":"Executing the move","text":"<p>To execute the move,</p> <pre><code>.commit()\n</code></pre>"},{"location":"accounts/move-raw-contacts-across-accounts/#handling-the-move-result","title":"Handling the move result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <p>To check if all moves succeeded,</p> <pre><code>val allUMovesSuccessful = moveResult.isSuccessful\n</code></pre> <p>To check if a particular move succeeded,</p> <pre><code>val firstMoveSuccessful = moveResult.isSuccessful(rawContact1)\n</code></pre> <p>To get the RawContact IDs of all the newly created RawContact copies,</p> <pre><code>val rawContactCopiesIds = moveResult.rawContactIds\n</code></pre> <p>To get the ID of the RawContact copy of a particular original RawContact,</p> <pre><code>val firstRawContactCopyId = moveResult.rawContactId(originalRawContact2)\n</code></pre> <p>Once you have the RawContact IDs, you can retrieve the newly created aggregated Contacts via the  <code>Query</code> API,</p> <pre><code>val contacts = contactsApi\n    .query()\n    .where { RawContact.Id `in` rawContactCopiesIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Or, retrieve the RawContacts directly via the <code>RawContactsQuery</code> API,</p> <pre><code>val contacts = contactsApi\n    .rawContactsQuery()\n    .where { RawContact.Id `in` rawContactCopiesIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query RawContacts.</p> <p>Alternatively, you may use the extensions provided in <code>MoveRawContactsAcrossAccountsResult</code>.  To get all newly created Contacts,</p> <pre><code>val contacts = moveResult.contacts(contactsApi)\n</code></pre> <p>To get a particular contact,</p> <pre><code>val contact = moveResult.contact(contactsApi, originalRawContactId)\n</code></pre> <p>To instead get the RawContacts directly,</p> <pre><code>val rawContacts = moveResult.rawContacts(contactsApi)\n</code></pre> <p>To get a particular RawContact,</p> <pre><code>val rawContact = moveResult.rawContact(contactsApi, originalRawContactId)\n</code></pre>"},{"location":"accounts/move-raw-contacts-across-accounts/#handling-move-failure","title":"Handling move failure","text":"<p>The move may fail for a RawContact for various reasons,</p> <pre><code>moveResult.failureReason(originalRawContactId)?.let {\n    when (it) {\n        INVALID_ACCOUNT -&gt; showInvalidAccountError()\n        ALREADY_IN_ACCOUNT -&gt; promptUserToPickDifferentAccount()\n        RAW_CONTACT_NOT_FOUND -&gt; showRawContactNotFoundError()\n        INSERT_RAW_CONTACT_COPY_FAILED -&gt; promptUserToTryAgain()\n        DELETE_ORIGINAL_RAW_CONTACT_FAILED -&gt; showOriginalRawContactNotDeletedError()\n        UNKNOWN -&gt; showGenericErrorMessage()\n    }   \n}\n</code></pre>"},{"location":"accounts/move-raw-contacts-across-accounts/#cancelling-the-move","title":"Cancelling the move","text":"<p>To cancel a move amid execution,</p> <pre><code>.commit { returnTrueIfMoveShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel move processing as soon as possible. The function is called numerous times during move processing to check if processing should stop or continue. This gives you the option to cancel the move.</p> <p>For example, to automatically cancel the move inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val moveResult = move.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"accounts/move-raw-contacts-across-accounts/#performing-the-move-and-result-processing-asynchronously","title":"Performing the move and result processing asynchronously","text":"<p>Moves are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#performing-the-move-with-permission","title":"Performing the move with permission","text":"<p>Moves require the <code>android.permission.READ_CONTACTS</code>, <code>android.permission.WRITE_CONTACTS</code> and  <code>android.permission.GET_ACCOUNTS</code> permissions. If not granted, the move will do nothing and return  a failed result.</p> <p>To perform the move with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#profile-support","title":"Profile support","text":"<p>The <code>MoveRawContactsAcrossAccounts</code> API does NOT support moving Profile RawContacts.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#custom-data-support","title":"Custom data support","text":"<p>The <code>MoveRawContactsAcrossAccounts</code> API supports custom data. For more info, read Integrate custom data.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#group-memberships-are-copied-over-on-a-best-effort-basis","title":"Group memberships are copied over on a best-effort basis","text":"<ul> <li>Groups with matching title (case-sensitive)</li> <li>Default Group (autoAdd is true)</li> <li>Favorites Group (if starred is true)</li> </ul>"},{"location":"accounts/move-raw-contacts-across-accounts/#defaultprimary-flags-of-data-rows-are-not-copied-over","title":"Default/primary flags of Data rows are not copied over","text":"<p>For example, if a phone number is set as the default (isPrimary: 1, isSuperPrimary: 1), after this  move operation it will no longer be a default data (isPrimary: 0,   isSuperPrimary: 0).  Yes, like all other behaviors of this API, this is the same as Google Contacts.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#ids-and-lookup-keys-may-change","title":"IDs and lookup keys may change","text":"<p>This means that references to Contact IDs and lookup keys, RawContact IDs and source IDs may become  invalid. Shortcuts using aforementioned properties may break after performing this operation.</p> <p>\u2139\ufe0f For more info, read Contact lookup key vs ID.</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#rawcontact-links-aggregationexceptions-are-copied-over","title":"(Raw)Contact links (AggregationExceptions) are copied over","text":"<p>For example, if there are two or more RawContacts that are linked to the same Contact, moving one or more of the RawContacts will still result in the RawContacts being linked to the same Contact  (though the original Contact may have been deleted and replaced with a new copy).</p>"},{"location":"accounts/move-raw-contacts-across-accounts/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":"<p>Let's take a look at what happens when Google Contacts moves RawContacts to different Accounts. Other apps such as AOSP Contacts and Samsung Contacts may do things a bit differently. We will focus on modelling API behavior after Google Contacts behavior because... it's Google. For testing, I used a Pixel 4 API 30 emulator and a Samsung Galaxy A71 API 33.</p> Original Account Target Account null (local) X X null (local) X Y <p>For all of the above scenarios, the behavior is as follows...</p> <ul> <li>New row in RawContacts table with same values as original</li> <li>Original row is deleted</li> <li>New row in Contacts table as the parent of the new RawContact</li> <li>Original row is deleted</li> <li>New rows in the Data table with same values as original, belonging to the new RawContact</li> <li>Original rows are deleted</li> </ul> <p>Group memberships (which are Account-based) are \"carried over\" on a best-effort basis;</p> <ul> <li>Groups with matching title (case-sensitive)</li> <li>Default Group (autoAdd is true)</li> <li>Favorites Group (if starred is true)</li> </ul> <p>Default/primary flags of Data rows are not copied over. For example, if a phone number is set as the default (isPrimary: 1, isSuperPrimary: 1), after this move operation it will no longer be a default data (isPrimary: 0, isSuperPrimary: 0). Yes, like all other behaviors of this API, this is the same as Google Contacts.</p> <p>Contact IDs and lookup keys and RawContact IDs and source IDs may change since new  copies are created and the originals are deleted. Existing shortcuts may break after performing this operation.</p> <p>(Raw)Contact links (AggregationExceptions) are also copied over, in some cases. For example, if there are two RawContacts linked to the same Contact and one RawContact is moved to device  (no Account), a new RawContact is created, the original RawContact is deleted, and the two  RawContacts are still linked together. However, in the case where there are two RawContacts (one  having no Account) linked to the same Contact and the device RawContact is moved to the same Account as the sibling RawContact, the two RawContacts are no longer linked to the same Contact. This may or may not be intentional. Regardless, we should fix it =)</p>"},{"location":"accounts/query-accounts/","title":"Query for Accounts","text":"<p>This library provides the <code>AccountsQuery</code> API that allows you to retrieve visible <code>Account</code>s  from the <code>AccountManager</code> whose <code>Account.type</code> has a matching  <code>android.content.SyncAdapterType.accountType</code> where the <code>android.content.SyncAdapterType.authority</code> is equal to <code>android.provider.ContactsContract.AUTHORITY</code>.</p> <p>If you look at all of the Accounts returned by the <code>AccountManager.getAccounts</code> in your 3rd party app, you might see the following [Account.type]s...</p> <ul> <li>\"com.google\" if you are signed into a Google account</li> <li>\"com.google.android.gm.legacyimap\" if you are signed into an Personal (IMAP) account</li> <li>\"com.samsung.android.mobileservice\" if the device is from Samsung</li> </ul> <p>When you open the Google Contacts app (assuming that it is a 3rd party app that did not come  pre-installed in the OS) and select an Account to save a new Contact to, you will notice that it only allows you to choose between the Google account of local/device account. It does not show the Personal (IMAP) account or the Samsung Account. The reason is (probably) because there is no  sync adapter for Contacts for those accounts. This API filters such accounts for you because this  API is specific to accounts relating to Contacts!</p> <p>An instance of the <code>AccountsQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).accounts().query()\n</code></pre>"},{"location":"accounts/query-accounts/#a-basic-query","title":"A basic query","text":"<p>To get all available accounts in the system,</p> <pre><code>val accounts = Contacts(context).accounts().query()\n    .find()\n</code></pre> <p>To get all available accounts in the system with an account type of \"com.google\" or \"com.yahoo\",</p> <pre><code>val accounts = Contacts(context).accounts().query()\n    .withTypes(\"com.google\", \"com.yahoo\")\n    .find()\n</code></pre>"},{"location":"accounts/query-accounts/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"accounts/query-accounts/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"accounts/query-accounts/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.GET_ACCOUNTS</code> permissions. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"accounts/query-accounts/#limitations","title":"Limitations","text":"<p>Samsung (type \"com.osp.app.signin\"), Xiaomi (type \"com.xiaomi\"), and perhaps other OEMs do not allow 3rd party (non-system) apps (those that do not come pre-installed in the OS) to access their  accounts. Your app does not have visibility on this accounts, unless this API is packaged as part  of a custom Android OS, which would be super cool. Such accounts are not returned by this query.  In a Samsung device, the Samsung Contacts app is able to show the Samsung account but the Google  Contacts app cannot.</p>"},{"location":"async/async-execution-coroutines/","title":"Execute work outside of the UI thread using coroutines","text":"<p>This library provides extensions in the <code>async</code> module that allow you to execute all core API  functions outside of the main, UI thread. These extensions use Kotlin Coroutines.</p> <p>The extension functions are lightweight and mostly exist for Coroutine user's convenience. The  extensions can be generalized in two categories; <code>withContext</code> and <code>async</code>. These use, you guessed it, Kotlin Coroutine's withContext and async functions respectively.</p> <p>For all core API functions that does blocking work in the call-site thread (e.g. query, insert, update, and deletes), there is a corresponding <code>xxxWithContext</code> and <code>xxxAsync</code> extension function.</p>"},{"location":"async/async-execution-coroutines/#using-withcontext-extensions","title":"Using <code>withContext</code> extensions","text":"<p>To perform an query, insert, update, and delete in order (sequential) outside the main UI thread,</p> <pre><code>launch {\n    val queryResult = query.findWithContext()\n    val insertResult = insert.commitWithContext()\n    val updateResult = update.commitWithContext()\n    val deleteResult = delete.commitWithContext()\n}\n</code></pre> <p>For each invocation of <code>xxxWithContext</code>, the current coroutine suspends, performs the operation in  the given <code>CoroutineContext</code> (default is <code>Dispatchers.IO</code> if not specified), then returns the result.</p> <p>Computations automatically stops if the parent coroutine scope / job is cancelled.</p>"},{"location":"async/async-execution-coroutines/#using-async-extensions","title":"Using <code>async</code> extensions","text":"<p>To perform an query, insert, update, and delete in parallel outside the main UI thread,</p> <pre><code>launch {\n    val deferredQueryResult = query.findAsynct()\n    val deferredInsertResult = insert.commitAsync()\n    val deferredUpdateResult = update.commitAsync()\n    val deferredDeleteResult = delete.commitAsync()\n    awaitAll(deferredQueryResult, deferredInsertResult, deferredUpdateResult, deferredDeleteResult)\n}\n</code></pre> <p>For each invocation of <code>xxxAsync</code>, a <code>CoroutineScope</code>is created  with the given <code>CoroutineContext</code> (default is <code>Dispatchers.IO</code> if not specified), performs the operation in that scope, then returns  the <code>Deferred</code> result.</p> <p>Computations automatically stops if the parent coroutine scope / job is cancelled.</p>"},{"location":"async/async-execution-coroutines/#cancellations-are-supported","title":"Cancellations are supported","text":"<p>To cancel a query amid execution,</p> <pre><code>query.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The find function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>One scenario where this would be frequently used is when performing queries as the user types a  search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n}\n</code></pre> <p>Or, using the coroutine extensions in the <code>async</code> module,</p> <pre><code>launch {\n    val contacts = query.findWithContext()\n}\n</code></pre> <p>\u2139\ufe0f Most core API functions support cancellations, not just queries!</p>"},{"location":"async/async-execution-coroutines/#not-compatible-with-java","title":"Not compatible with Java","text":"<p>Unlike the <code>core</code> module, the <code>async</code> module is not compatible with Java because it requires Kotlin Coroutines.</p>"},{"location":"async/async-execution-coroutines/#these-extensions-are-optional","title":"These extensions are optional","text":"<p>You are free to use the core APIs however you want with whatever libraries or frameworks you want  that works with Java such as Reactive, AsyncTask (hope not), WorkManager, or your own DIY solution.</p>"},{"location":"async/async-execution-coroutines/#extensions-for-rxjava-and-flow-are-in-the-roadmap","title":"Extensions for RxJava and Flow are in the roadmap","text":"<p>If you prefer not to use Kotlin Coroutines and would rather use your own multi-threading mechanism,  then you are free to use the <code>core</code> module without using the <code>async</code> module functions.</p> <p>However, if you prefer to use something that comes with the library to ensure first-class support, then you might be interested in waiting for extensions for RxJava and Kotlin Flow!</p>"},{"location":"basics/delete-contacts/","title":"Delete Contacts","text":"<p>This library provides the <code>Delete</code> API, which allows you to delete one or more Contacts or RawContacts.</p> <p>An instance of the <code>Delete</code> API is obtained by,</p> <pre><code>val delete = Contacts(context).delete()\n</code></pre> <p>\u2139\ufe0f If you want to delete the device owner Contact Profile, read Delete device owner Contact profile.</p> <p>\u2139\ufe0f If you want to delete a set of Data, read Delete existing sets of data.</p>"},{"location":"basics/delete-contacts/#a-basic-delete","title":"A basic delete","text":"<p>To delete a set of Contact and all of its RawContacts,</p> <pre><code>val deleteResult = delete\n    .contacts(contactToDelete)\n    .commit()\n</code></pre> <p>To delete a set of RawContacts,</p> <pre><code>val deleteResult = delete\n    .rawContacts(contactToDelete)\n    .commit()\n</code></pre> <p>You may specify <code>contacts</code> and <code>rawContacts</code> in the same delete operation.</p> <p>You may also use IDs instead of entity references,</p> <pre><code>val deleteResult = delete\n    .contactsWithId(1, 2, 3)\n    .rawContactsWithId(4, 5, 6)\n    .commit()\n</code></pre> <p>\u2139\ufe0f Contacts are deleted automatically when all constituent RawContacts are deleted. RawContacts  are deleted automatically when the parent Contact is deleted.</p>"},{"location":"basics/delete-contacts/#an-advanced-delete","title":"An advanced delete","text":"<p>You may specify a matching criteria, like in queries, that will delete all matching contacts and RawContacts,</p> <pre><code>val deleteResult = delete\n    .rawContactsWhere { Options.SendToVoicemail equalTo true }\n    .rawContactsWhereData { Email.Address.isNotNullOrEmpty() and Phone.Number.contains(\"9\") }\n    .contactsWhere { Options.SendToVoicemail equalTo true }\n    .contactsWhereData { Email.Address.isNotNullOrEmpty() and Phone.Number.contains(\"9\") }\n    .commit()\n</code></pre>"},{"location":"basics/delete-contacts/#executing-the-delete","title":"Executing the delete","text":"<p>To execute the delete,</p> <pre><code>.commit()\n</code></pre> <p>If you want to delete all specified Contacts and RawContacts in a single atomic transaction,</p> <pre><code>.commitInOneTransaction()\n</code></pre> <p>The call to <code>commitInOneTransaction</code> will only succeed if ALL given Contacts and RawContacts are successfully deleted. If one delete fails, the entire operation will fail and everything will be reverted prior to the delete operation. In contrast, <code>commit</code> allows for some deletes to succeed and some to fail.</p>"},{"location":"basics/delete-contacts/#handling-the-delete-result","title":"Handling the delete result","text":"<p>The <code>commit</code> and <code>commitInOneTransaction</code> functions returns a <code>Result</code>,</p> <p>To check if all deletes succeeded,</p> <pre><code>val allDeletesSuccessful = deleteResult.isSuccessful\n</code></pre> <p>To check if a particular Contact has been deleted successfully,</p> <pre><code>val contactDeleteSuccessful = deleteResult.isSuccessful(mutableContact)\nval contactDeleteSuccessful = deleteResult.isContactDeleteSuccessful(mutableContact.id)\n</code></pre> <p>To check if a particular RawContact has been deleted successfully,</p> <pre><code>val rawContactDeleteSuccessful = deleteResult.isSuccessful(mutableRawContact)\nval rawContactDeleteSuccessful = deleteResult.isRawContactDeleteSuccessful(mutableRawContact.id)\n</code></pre> <p>To check if a particular advanced delete managed to delete at least one matching Contact/RawContact,</p> <pre><code>val where = RawContactsFields.Options.SendToVoicemail equalTo true\nval deleteResult = delete.rawContactsWhere(where).commit()\nval advancedDeleteSuccessful = deleteResult.isSuccessful(where)\n</code></pre>"},{"location":"basics/delete-contacts/#performing-the-delete-and-result-processing-asynchronously","title":"Performing the delete and result processing asynchronously","text":"<p>Deletes are executed when the <code>commit</code> or <code>commitInOneTransaction</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines .</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"basics/delete-contacts/#performing-the-delete-with-permission","title":"Performing the delete with permission","text":"<p>Deletes require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the delete will do nothing and return a failed result.</p> <p>To perform the delete with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/delete-contacts/#custom-data-support","title":"Custom data support","text":"<p>The <code>Delete</code> API supports custom data. For more info, read Delete custom data.</p>"},{"location":"basics/delete-contacts/#data-belonging-to-rawcontactscontact-are-deleted","title":"Data belonging to RawContacts/Contact are deleted","text":"<p>When a RawContact is deleted, all of its data are also deleted.</p>"},{"location":"basics/delete-contacts/#rawcontact-deletion-is-not-guaranteed-to-be-immediate","title":"RawContact deletion is not guaranteed to be immediate","text":"<p>RawContacts may not immediately be deleted. They are marked for deletion and get deleted in the  background by the Contacts Provider depending on sync settings and network availability.</p> <p>Contacts of RawContacts that are marked for deletion are immediately deleted!</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p>"},{"location":"basics/delete-contacts/#contacts-are-deleted-automatically-when-all-constituent-rawcontacts-are-deleted","title":"Contacts are deleted automatically when all constituent RawContacts are deleted","text":"<p>Deleting a contact's Contacts row, RawContacts row(s), and associated Data row(s) are best explained in the documentation in <code>ContactsContract.RawContacts</code>;</p> <p>When a raw contact is deleted, all of its Data rows as well as StatusUpdates, AggregationExceptions, PhoneLookup rows are deleted automatically.</p> <p>When all raw contacts associated with a Contacts row are deleted, the Contacts row itself is also deleted automatically.</p> <p>The invocation of resolver.delete(...), does not immediately delete a raw contacts row. Instead, it sets the ContactsContract.RawContactsColumns.DELETED flag on the raw contact and removes the raw contact from its aggregate contact. The sync adapter then deletes the raw contact from the server and finalizes phone-side deletion by calling resolver.delete(...) again and passing the ContactsContract#CALLER_IS_SYNCADAPTER  query parameter.</p> <p>Some sync adapters are read-only, meaning that they only sync server-side changes to the phone, but not the reverse. If one of those raw contacts is marked for deletion, it will remain on the phone. However it will be effectively invisible, because it will not be part of any aggregate contact.</p> <p>TLDR</p> <p>To delete a contacts and all associated rows, simply delete all RawContact rows with the desired Contacts id. Deletion of the Contacts row and associated Data row(s) will be done automatically by the Contacts Provider.</p>"},{"location":"basics/include-only-desired-data/","title":"Include only certain fields for read and write operations","text":"<p>The read (query) and write (insert, update) APIs in this library provides an <code>include</code> function that allows you to specify all (default) or some fields to read or write in the Contacts Provider  database.</p> <p>The fields defined in <code>contacts.core.Fields.kt</code> specify what properties of entities to include in read and write operations. For example, to include only the contact display name, organization company, and all phone number fields in a query/insert/update operation,</p> <pre><code>queryInsertUpdate.include(mutableSetOf&lt;AbstractDataField&gt;().apply {\n    add(Fields.Contact.DisplayNamePrimary)\n    add(Fields.Organization.Company)\n    addAll(Fields.Phone.all)\n})\n</code></pre> <p>The following entity properties are used in the read/write operation,</p> <pre><code>Contact {\n    displayNamePrimary\n\n    RawContact {\n        organization {\n            company\n        }\n        phones {\n            number\n            normalizedNumber\n            type\n            label\n        }\n    }\n}\n</code></pre> <p>\u2139\ufe0f For more info, read about API Entities.</p>"},{"location":"basics/include-only-desired-data/#including-all-fields","title":"Including all fields","text":"<p>By default (not calling the <code>include</code> function) or passing in an empty list will result in the  inclusion of all fields (including custom data fields) in the most optimal way,</p> <pre><code>query.include()\n// or\nquery.include(emptyList())\n</code></pre> <p>If for some reason you want to include only all non-custom data fields explicitly,</p> <pre><code>.include(Fields.all)\n</code></pre> <p>If you want to also include custom data fields explicitly (not recommended),</p> <pre><code>.include(Fields.all + contactsApi.customDataRegistry.allFields())\n</code></pre> <p>If you want to include all fields, including custom data fields, in the read/write operation, then  passing in an empty list or not invoking the <code>include</code> function is the most performant way to do it because internal checks will be disabled (less lines of code executed).</p>"},{"location":"basics/include-only-desired-data/#using-include-in-query-apis","title":"Using <code>include</code> in query APIs","text":"<p>When using query APIs such as <code>Query</code>, <code>BroadQuery</code>, <code>PhoneLookupQuery</code>, <code>RawContactsQuery</code>, <code>ProfileQuery</code>, and <code>DataQuery</code>, you are able to specify all or only some kinds of data that you  want to be included in the returned results.</p> <p>When all fields are included in a query operation, all properties of Contacts, RawContacts, and Data are populated with values from the database. Properties of fields that are included are not  guaranteed to be non-null because the database may actually have no data for the corresponding  field.</p> <p>When only some fields are included, only those included properties of Contacts, RawContacts, and  Data are populated with values from the database. Properties of fields that are not included are  guaranteed to be null.</p>"},{"location":"basics/include-only-desired-data/#optimizing-queries","title":"Optimizing queries","text":"<p>Are you finding that your queries are slow or take too much memory? Are you looking to optimize your queries? Well, you are in the right section!</p> <p>When you are showing a list of Contacts using the <code>Query</code> and <code>BroadQuery</code> APIs, you typically only  show their thumbnail photo and display name.</p> <pre><code>.include(Fields.Contact.PhotoThumbnailUri, Fields.Contact.DisplayNamePrimary)\n</code></pre> <p>If instead you are showing a list of RawContacts directly instead of Contacts using the  <code>RawContactsQuery</code>, you typically only show their display name.</p> <pre><code>.includeRawContactsFields(RawContactsFields.DisplayNamePrimary)\n</code></pre> <p>In such cases, you should only include those fields in order to increase speed and lessen memory usage.</p> <p>Here is a sample benchmark running on an M1 MacBook Pro using a Pixel 4 API 30 emulator in  Android Studio. The Contacts Provider database contains 10,000 contacts each having exactly one  address, email, event, im, name, nickname, note, organization, phone, relation, sip address, and  website.</p> <p>Getting all 10,000 contacts including only fields from <code>Fields.Contact</code> using the following query,</p> <pre><code>val contacts = Contacts(context)\n    .broadQuery()\n    .include(\n        Fields.Contact.LookupKey,\n        Fields.Contact.DisplayNamePrimary\n    )\n    .find()\n</code></pre> <p>takes between 99 to 144 milliseconds =)</p> <p>\u2139\ufe0f As of version 0.2.4,  including only fields from <code>Fields.Contact</code> in <code>Query</code> and <code>BroadQuery</code> API calls will result in  the fastest and most memory efficient queries. Prior versions do not have this extra optimization,  though including less fields still result in faster queries. Prior versions will take on average 1334 milliseconds for the same query above.</p> <p>Getting all 10,000 contacts including ALL fields using the following query,</p> <pre><code>val contacts = Contacts(context).broadQuery().find()\n</code></pre> <p>takes between 2953 to 3009 milliseconds =(</p>"},{"location":"basics/include-only-desired-data/#using-include-in-insert-apis","title":"Using <code>include</code> in insert APIs","text":"<p>When using insert APIs such as <code>Insert</code> and <code>ProfileInsert</code>, you are able to specify all or only  some kinds of data that you want to be included in the insert operation.</p> <p>When all fields are included in an insert operation, all properties of Contacts, RawContacts, and  Data are inserted into the database. </p> <p>When only some fields are included, only those included properties of Contacts, RawContacts, and Data are inserted into the database. Properties of fields that are not included are NOT inserted  into the database.</p>"},{"location":"basics/include-only-desired-data/#using-include-in-update-apis","title":"Using <code>include</code> in update APIs","text":"<p>When using update APIs such as <code>Update</code>, <code>ProfileUpdate</code>, and <code>DataUpdate</code>, you are able to specify  all or only some kinds of data that you want to be included in the update operation.</p>"},{"location":"basics/include-only-desired-data/#an-update-operation-consists-of-insertion-updates-and-deletions","title":"An \"update\" operation consists of insertion, updates, and deletions","text":"<p>To ensure that the database matches the data contained in the entities being passed into the update  operation, a combination of insert, update, or delete operations are performed internally by the  update API. The following is what constitutes an \"updated\" event;</p> <ul> <li>A RawContact can have 0 or 1 name. <ul> <li>If it is null or blank, then the update operation will...<ul> <li>delete the name row of the RawContact from the database, if it exist</li> </ul> </li> <li>If it is not null, then the update operation will do one of the following...<ul> <li>update an existing name row, if it exist</li> <li>or insert a new name row, if one does not exist</li> </ul> </li> </ul> </li> <li>A RawContact can have 0, 1 or more emails.<ul> <li>If the list of emails is empty (or contains only blanks), then the update operation will...<ul> <li>delete all email rows of the RawContact from the database, if any exist</li> </ul> </li> <li>If the list of emails is not empty, then the update operation will do all of the following...<ul> <li>update email rows for emails that already exist in the database</li> <li>insert new email rows for emails that do not yet exist in the database</li> <li>delete email rows for emails that exist in the database but not in the (in-memory) entity</li> </ul> </li> </ul> </li> </ul>"},{"location":"basics/include-only-desired-data/#blank-data-are-deleted","title":"Blank data are deleted","text":"<p>Blank data are deleted from the database, unless the the complete set of corresponding fields are  not included in the update operation.</p> <p>\u26a0\ufe0f Prior to version 0.2.1, before  <code>include</code> in update APIs have been overhauled,  blank data are deleted from the database even if the corresponding fields are not included.</p> <p>\u2139\ufe0f For more info on blank data, read about Blank data.</p>"},{"location":"basics/include-only-desired-data/#including-complete-field-sets-for-update","title":"Including complete field sets for \"update\"","text":"<p>When all fields are included in an update operation, all properties of Contacts, RawContacts, and Data are \"updated\" in the database.</p> <p>When only some fields are included, only those included properties of Contacts, RawContacts, and Data are \"updated\" in the database. Properties of fields that are not included are NOT  \"updated\".</p> <p>To get all contacts including all fields, then modify the emails, phones, and addresses and perform  an update operation on all fields,</p> <pre><code>val contacts = query.find() \nval contactsWithModifiedEmailPhoneAddress = modifyEmailPhoneAddressIn(contacts)\nupdate.contacts(contactsWithModifiedEmailPhoneAddress).commit()\n</code></pre> <p>To modify all emails of all contacts without updating anything else into the database,</p> <pre><code>val contactsWithOnlyEmailData = query.include(Fields.Email.all).find()\nval contactsWithModifiedEmailData = modifyEmailsIn(contactsWithOnlyEmailData)\nupdate.contacts(contactsWithModifiedEmailData).include(Fields.Email.all).commit()\n</code></pre> <p>To remove all emails from all contacts without updating anything else in the database,</p> <pre><code>val contactsWithAllData = query.find()\nval contactsWithNoEmailData = removeEmailsFrom(contactsWithAllData)\nupdate.contacts(contactsWithNoEmailData).include(Fields.Email.all).commit()\n</code></pre>"},{"location":"basics/include-only-desired-data/#including-a-subset-of-field-sets-for-update","title":"Including a subset of field sets for \"update\"","text":"<p>Including only a subset of a set of fields results in,</p> <ul> <li>deletion of blanks (same as if the complete set of fields are included)</li> <li>update of properties corresponding to included fields</li> <li>no-op on properties corresponding to excluded fields</li> </ul> <p>For example, the following set the given name and family name to the non-null values but does not set all others (i.e. display name, middle name, prefix, suffix, phonetic given middle family name).</p> <pre><code>contacts\n    .update()\n    .include(\n        Fields.Name.GivenName,\n        Fields.Name.FamilyName,\n    )\n    .rawContacts(\n        existingRawContact.mutableCopy {\n            setName {\n                displayName = \"Mr. \"\n                prefix = \"Mr.\"\n                givenName = \"First\"\n                middleName = \"Middle\"\n                familyName = \"Last\"\n                suffix = \"Jr.\"\n                phoneticGivenName = \"fUHRst\"\n                phoneticMiddleName = \"mIdl\"\n                phoneticFamilyName = \"lAHst\"\n            }\n        }\n    )\n    .commit()\n</code></pre> <p>If the name row for the RawContact did not exist before the update operation, then a new name row will be inserted into the database for the RawContact. The given name and family name columns will be set to the specified values. All other columns will be set to null.</p> <p>If the name row for the RawContact already exists before the update operation, then the name row will be updated. The given name and family name columns will be set to the specified values. All  other columns will remain unchanged (the null or non-null values will remain null and non-null respectively).</p>"},{"location":"basics/insert-contacts/","title":"Insert contacts","text":"<p>This library provides the <code>Insert</code> API that allows you to insert one or more RawContacts and Data.</p> <p>An instance of the <code>Insert</code> API is obtained by,</p> <pre><code>val insert = Contacts(context).insert()\n</code></pre> <p>\u2139\ufe0f If you want to create/insert the device owner Contact Profile, read Insert device owner Contact profile.</p> <p>\u2139\ufe0f If you want to insert Data into a new or existing contact, read Insert data into new or existing contacts.</p>"},{"location":"basics/insert-contacts/#a-basic-insert","title":"A basic insert","text":"<p>To create/insert a contact with a name of \"John Doe\" who works at Amazon with a work email of \"john.doe@amazon.com\" (in Kotlin),</p> <pre><code>val insertResult = Contacts(context)\n    .insert()\n    .rawContacts(NewRawContact().apply {\n        name = NewName().apply {\n            givenName = \"John\"\n            familyName = \"Doe\"\n        }\n        organization = NewOrganization().apply {\n            company = \"Amazon\"\n            title = \"Superstar\"\n        }\n        emails.add(NewEmail().apply {\n            address = \"john.doe@amazon.com\"\n            type = EmailEntity.Type.WORK\n        })\n    })\n    .commit()\n</code></pre> <p>Or alternatively, in a more Kotlinized style using named arguments,</p> <pre><code>val insertResult = Contacts(context)\n    .insert()\n    .rawContacts(NewRawContact(\n        name = NewName(\n            givenName = \"John\",\n            familyName = \"Doe\"\n        ),\n        organization = NewOrganization(\n            company = \"Amazon\",\n            title = \"Superstar\"\n        ),\n        emails = mutableListOf(NewEmail(\n            address = \"john.doe@amazon.com\",\n            type = EmailEntity.Type.WORK\n        ))\n    ))\n    .commit()\n</code></pre> <p>Or alternatively, using extension functions,</p> <pre><code>val insertResult = Contacts(context)\n    .insert()\n    .rawContact {\n        setName {\n            givenName = \"John\"\n            familyName = \"Doe\"\n        }\n        setOrganization {\n            company = \"Amazon\"\n            title = \"Superstar\"\n        }\n        addEmail {\n            address = \"john.doe@amazon.com\"\n            type = EmailEntity.Type.WORK\n        }\n    }\n    .commit()\n</code></pre>"},{"location":"basics/insert-contacts/#allowing-blanks","title":"Allowing blanks","text":"<p>The API allows you to specify if you want to be able to insert blank contacts or not,</p> <pre><code>.allowBlanks(true|false)\n</code></pre> <p>For more info, read about Blank contacts.</p> <p>\u2139\ufe0f This may affect performance. When this is set to false, the API executes extra lines of code  to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to true.</p>"},{"location":"basics/insert-contacts/#blank-data-are-not-inserted","title":"Blank data are not inserted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are ignored and are not inserted by insert APIs.</p> <p>For more info, read about Blank data.</p>"},{"location":"basics/insert-contacts/#associating-an-account","title":"Associating an Account","text":"<p>New RawContacts can be associated with an Account in order to enable syncing,</p> <pre><code>newRawContact.account = account\n// or newRawContact.setAccount(account)\n</code></pre> <p>\u2139\ufe0f Prior to version 0.3.0, setting the account is done via the <code>Insert.forAccount</code> function.</p> <p>For example, to associated the new RawContact to an account,</p> <pre><code>newRawContact.account = Account(\"john.doe@gmail.com\", \"com.google\")\n// or newRawContact.setAccount(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p>"},{"location":"basics/insert-contacts/#account-validation","title":"Account validation","text":"<p>By default, all Accounts in the system are queried in order to ensure that each  <code>NewRawContact.account</code> is in the system. For Accounts that are not in the system, null is used  instead. This guards against invalid accounts.</p> <p>You may explicitly enable or disable this,</p> <pre><code>.validateAccounts(true|false)\n</code></pre> <p>\u2139\ufe0f This may affect performance. When this is set to true, the API executes extra lines of code to  perform the validation, which may result in a slight performance hit. You can disable this  internal check, perhaps increasing insertion speed, by setting this to false.</p>"},{"location":"basics/insert-contacts/#group-memberships-validation","title":"Group memberships validation","text":"<p>By default, all Groups belonging to the <code>NewRawContact.account</code> are queried to ensure that each  <code>NewRawContact.groupMemberships</code> points to a Group in that list. Group memberships that are not  pointing to a group that belong to the <code>NewRawContact.account</code> are not inserted. This guards  against invalid accounts.</p> <p>You may explicitly enable or disable this,</p> <pre><code>.validateGroupMemberships(true|false)\n</code></pre> <p>\u2139\ufe0f This may affect performance. When this is set to true, the API executes extra lines of code to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to false.</p>"},{"location":"basics/insert-contacts/#local-rawcontacts","title":"Local RawContacts","text":"<p>If no Account is provided, or null is provided, or if an incorrect account is provided, the RawContacts inserted will not be associated with an Account. RawContacts inserted without an associated account are considered local or device-only contacts, which are not synced.</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p>"},{"location":"basics/insert-contacts/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the insert operation,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/insert-contacts/#executing-the-insert","title":"Executing the insert","text":"<p>To execute the insert,</p> <pre><code>.commit()\n</code></pre> <p>To execute the most optimal (fastest) insert for large amounts of RawContacts,</p> <pre><code>.commitInChunks()\n</code></pre>"},{"location":"basics/insert-contacts/#commitinchunks-vs-commit","title":"<code>commitInChunks</code> vs <code>commit</code>","text":"<p>When inserting just one <code>NewRawContact</code>, the <code>commitInChunks</code> function behaves and performs  identically to <code>commit</code>.</p> <p>When inserting more than one <code>NewRawContact</code>, the <code>commitInChunks</code> function is faster than <code>commit</code>. This performance improvement is negligible for small amounts of RawContacts (e.g. 5, 10, 20,...)  BUT is very noticeable for much larger amounts (e.g. 500, 1000, 5000, ...) by a magnitude of  3x to 5x or even, more depending on the amount of RawContacts and the amount of data each one holds.</p> <p>A caveat to using <code>commitInChunks</code> is that failure to insert one RawContact may result in failure to insert one or more other RawContacts that happen to be in inserted in the same \"chunk\" (or batch).  Using <code>commit</code> does not have this caveat. By using <code>commit</code>, each RawContact is inserted separately, guaranteeing that an error in the insertion of one RawContact does not affect another.</p> <p>It is recommended to use <code>commit</code> when inserting a few RawContacts. When inserting several hundreds  or thousands of RawContacts, then you should probably use <code>commitInChunks</code> if you want to optimize  for speed over \"correctness\".</p> <p>\u2139\ufe0f For more insights, join the discussion; https://github.com/vestrel00/contacts-android/discussions/317</p>"},{"location":"basics/insert-contacts/#handling-the-insert-result","title":"Handling the insert result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <pre><code>val contactsApi = Contacts(context)\nval newRawContact1 = NewRawContact(...)\nval newRawContact2 = NewRawContact(...)\n\nval insertResult = contactsApi\n    .insert()\n    .rawContacts(newRawContact1, newRawContact2)\n    .commit()\n</code></pre> <p>To check if all inserts succeeded,</p> <pre><code>val allInsertsSuccessful = insertResult.isSuccessful\n</code></pre> <p>To check if a particular insert succeeded,</p> <pre><code>val firstInsertSuccessful = insertResult.isSuccessful(newRawContact1)\n</code></pre> <p>To get the RawContact IDs of all the newly created RawContacts,</p> <pre><code>val allRawContactIds = insertResult.rawContactIds\n</code></pre> <p>To get the RawContact ID of a particular RawContact,</p> <pre><code>val secondRawContactId = insertResult.rawContactId(newRawContact2)\n</code></pre> <p>Once you have the RawContact IDs, you can retrieve the newly created Contacts via the <code>Query</code> API,</p> <pre><code>val contacts = contactsApi\n    .query()\n    .where { RawContact.Id `in` allRawContactIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Alternatively, you may use the extensions provided in <code>InsertResult</code>. To get all newly created Contacts,</p> <pre><code>val contacts = insertResult.contacts(contactsApi)\n</code></pre> <p>To get a particular contact,</p> <pre><code>val contact = insertResult.contact(contactsApi, newRawContact1)\n</code></pre> <p>To instead get the RawContacts directly,</p> <pre><code>val rawContacts = insertResult.rawContacts(contactsApi)\n</code></pre> <p>To get a particular RawContact,</p> <pre><code>val rawContact = insertResult.rawContact(contactsApi, newRawContact2)\n</code></pre>"},{"location":"basics/insert-contacts/#cancelling-the-insert","title":"Cancelling the insert","text":"<p>To cancel an insert amid execution,</p> <pre><code>.commit { returnTrueIfInsertShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel insert processing as soon as possible. The function is called numerous times during insert processing to check if processing should stop or continue. This gives you the option to cancel the insert.</p> <p>For example, to automatically cancel the insert inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val insertResult = insert.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/insert-contacts/#performing-the-insert-and-result-processing-asynchronously","title":"Performing the insert and result processing asynchronously","text":"<p>Inserts are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"basics/insert-contacts/#performing-the-insert-with-permission","title":"Performing the insert with permission","text":"<p>Inserts require the <code>android.permission.WRITE_CONTACTS</code> and <code>android.permission.GET_ACCOUNTS</code> permissions. If not granted, the insert will do nothing and return a failed result.</p> <p>To perform the insert with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/insert-contacts/#custom-data-support","title":"Custom data support","text":"<p>The <code>Insert</code> API supports custom data. For more info, read Insert custom data into new or existing contacts.</p>"},{"location":"basics/insert-contacts/#rawcontact-and-contacts-aggregation","title":"RawContact and Contacts aggregation","text":"<p>As per documentation in <code>android.provider.ContactsContract.Contacts</code>,</p> <p>A Contact cannot be created explicitly. When a raw contact is inserted, the provider will first try to find a Contact representing the same person. If one is found, the raw contact's RawContacts#CONTACT_ID column gets the _ID of the aggregate Contact. If no match is found, the provider automatically inserts a new Contact and puts its _ID into the RawContacts#CONTACT_ID column of the newly inserted raw contact.</p>"},{"location":"basics/insert-contacts/#insert-a-new-rawcontact-with-data-of-every-kind","title":"Insert a new RawContact with data of every kind","text":"<p>Unless you are allowing blanks, you only need to provide at least one data kind when inserting a new contact in order for the operation to succeed.</p> <p>If you want to provide data of every kind, which is useful when implementing a contact creation screen,</p> <pre><code>val accountToAddContactTo = Account(\"vestrel00@pixar.com\", \"com.pixar\")\n\nval insertResult = Contacts(context)\n    .insert()\n    .rawContact {\n        setAccount(accountToAddContactTo)\n        setName {\n            givenName = \"Buzz\"\n            familyName = \"Lightyear\"\n        }\n        setNickname {\n            name = \"Buzz\"\n        }\n        setOrganization {\n            title = \"Space Toy\"\n            company = \"Pixar\"\n        }\n        addPhone {\n            number = \"(555) 555-5555\"\n            type = PhoneEntity.Type.CUSTOM\n            label = \"Fake Number\"\n        }\n        setSipAddress {\n            sipAddress = \"sip:buzz.lightyear@pixar.com\"\n        }\n        addEmail {\n            address = \"buzz.lightyear@pixar.com\"\n            type = EmailEntity.Type.WORK\n        }\n        addEmail {\n            address = \"buzz@lightyear.net\"\n            type = EmailEntity.Type.HOME\n        }\n        addAddress {\n            formattedAddress = \"1200 Park Ave\"\n            type = AddressEntity.Type.WORK\n        }\n        addIm {\n            data = \"buzzlightyear@skype.com\"\n            protocol = ImEntity.Protocol.SKYPE\n        }\n        addWebsite {\n            url = \"https://www.pixar.com\"\n        }\n        addWebsite {\n            url = \"https://www.disney.com\"\n        }\n        addEvent {\n            date = EventDate.from(year = 1995, month = 10, dayOfMonth = 22)\n            type = EventEntity.Type.BIRTHDAY\n        }\n        addRelation {\n            name = \"Childhood friend\"\n            type = RelationEntity.Type.CUSTOM\n            label = \"Imaginary Friend\"\n        }\n        groupMemberships.addAll(\n            contactsApi\n                .groups()\n                .query()\n                .accounts(accountToAddContactTo)\n                .where { Title contains \"friend\"}\n                .find()\n                .newMemberships()\n        )\n        setNote {\n            note = \"The best toy in the world!\"\n        }\n    }\n    .commit()\n</code></pre>"},{"location":"basics/insert-contacts/#inserting-photos-and-thumbnails","title":"Inserting photos and thumbnails","text":"<p>To set full-sized photos (and by API design thumbnails),  read Get set remove full-sized and thumbnail contact photos.</p>"},{"location":"basics/limit-and-offset-queries/","title":"Using limit and offset in queries","text":"<p>Most query APIs in this library provide <code>limit</code> and <code>offset</code> functions to allow you to retrieve only some entities instead of everything.</p> <p>To limit the amount of entities returned and/or offset (skip) a specified number of entities,</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For example, to only get a maximum 20 entities, skipping the first 20,</p> <pre><code>.limit(20)\n.offset(20)\n</code></pre> <p>This is useful for pagination =)</p> <p>\u2139\ufe0f It is recommended to limit the number of entities requested when querying to increase  performance and decrease memory cost.</p>"},{"location":"basics/limit-and-offset-queries/#some-devices-do-not-support-limit-andor-offset-in-queries","title":"Some devices do not support limit and/or offset in queries","text":"<p>If the <code>limit</code> and <code>offset</code> functions are not supported by the device's database query operation,  all entities will be returned. In such cases, the <code>Result.isLimitBreached</code> will be true if the  number of entities returned exceed the <code>limit</code>.</p> <p>\u2139\ufe0f The <code>Result.isLimitBreached</code> is available since version 0.2.3.</p> <p>Setting <code>forceOffsetAndLimit(true)</code> will ensure that the <code>offset</code> and `limit will be applied after  performing the internal database query, before returning the result to the caller (you).</p> <p>\u2139\ufe0f The <code>forceOffsetAndLimit</code> is available since version 0.2.4.</p> <p>This defaults to true in order to seamlessly support pagination. However, it is recommended to set  this to false and handle such cases yourself to prevent performing more than one query for devices  that do not support pagination.</p> <p>For the full set of devices that do not support pagination, visit this discussion; https://github.com/vestrel00/contacts-android/discussions/242#discussioncomment-3337613</p>"},{"location":"basics/limit-and-offset-queries/#limitation","title":"Limitation","text":"<p>If the number of entities found do not exceed the <code>limit</code> but an <code>offset</code> is provided, this is  unable to detect/handle events where the <code>offset</code> is not supported. Sorry :P</p>"},{"location":"basics/query-contacts-advanced/","title":"Query contacts (advanced)","text":"<p>This library provides the <code>Query</code> API that allows you to get a list of Contacts matching a specific  search criteria. All RawContacts of matching Contacts are included in the resulting Contact  instances.</p> <p>This provides a great deal of granularity and customizations when providing matching criteria via the <code>where</code> function.</p> <p>An instance of the <code>Query</code> API is obtained by,</p> <pre><code>val query = Contacts(context).query()\n</code></pre> <p>\u2139\ufe0f For a broader, and more AOSP Contacts app like query, use the <code>BroadQuery</code> API, read Query contacts.</p> <p>\u2139\ufe0f To query contacts using lookup keys, read Query contacts by lookup key.</p> <p>\u2139\ufe0f For specialized matching of phone numbers and SIP addresses, use the <code>PhoneLookupQuery</code> API; Query contacts by phone or SIP.</p> <p>\u2139\ufe0f If you want to query RawContacts directly instead of Contacts, read Query RawContacts.</p> <p>\u2139\ufe0f If you want to query Data directly instead of Contacts, read Query specific data kinds.</p> <p>\u2139\ufe0f If you want to get the device owner Contact Profile, read Query device owner Contact profile.</p>"},{"location":"basics/query-contacts-advanced/#an-advanced-query","title":"An advanced query","text":"<p>To retrieve the first 5 contacts (including only the contact id, display name, and phone numbers in the results) ordered by display name in descending order, matching ALL of these rules;</p> <ul> <li>a first name starting with \"leo\"</li> <li>has emails from gmail or hotmail</li> <li>lives in the US</li> <li>has been born prior to making this query</li> <li>is favorited (starred)</li> <li>has a nickname of \"DarEdEvil\" (case sensitive)</li> <li>works for Facebook</li> <li>has a note</li> <li>belongs to the account of \"john.doe@gmail.com\" or \"john.doe@myspace.com\"</li> </ul> <pre><code>val contacts = Contacts(context)\n    .query()\n    .where {\n        (Name.GivenName startsWith \"leo\") and\n        (Email.Address { endsWith(\"gmail.com\") or endsWith(\"hotmail.com\") }) and\n        (Address.Country equalToIgnoreCase \"us\") and\n        (Event { (Date lessThan Date().toWhereString()) and (Type equalTo EventEntity.Type.BIRTHDAY) }) and\n        (Contact.Options.Starred equalTo true) and\n        (Nickname.Name equalTo \"DarEdEvil\") and\n        (Organization.Company `in` listOf(\"facebook\", \"FB\")) and\n        (Note.Note.isNotNullOrEmpty())\n    }\n    .accounts(\n        Account(\"john.doe@gmail.com\", \"com.google\"),\n        Account(\"john.doe@myspace.com\", \"com.myspace\"),\n    )\n    .include { setOf(\n        Contact.Id,\n        Contact.DisplayNamePrimary,\n        Phone.Number\n    ) }\n    .orderBy(ContactsFields.DisplayNamePrimary.desc())\n    .offset(0)\n    .limit(5)\n    .find()\n</code></pre>"},{"location":"basics/query-contacts-advanced/#a-basic-query","title":"A basic query","text":"<p>This query API may also be used to make basic, simpler queries.</p> <p>To get all contacts ordered by the primary display name,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    .orderBy(ContactsFields.DisplayNamePrimary.asc())\n    .find()\n</code></pre> <p>To get all contacts with a phone number AND email,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    ...\n    .where{ Phone.Number.isNotNullOrEmpty() and Email.Address.isNotNullOrEmpty() }\n    .find()\n</code></pre> <p>\u2139\ufe0f Phone numbers are a special case because the Contacts Provider keeps track of the existence of  a phone number for any given contact. Use <code>Contact.HasPhoneNumber equalTo true</code> instead for a  more optimized query.</p> <p>To get a list of contacts with the given IDs,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    ...\n    .where { Contact.Id `in` contactIds }\n    .find()\n</code></pre> <p>To get Contacts using lookup keys, read Query contacts by lookup key.</p>"},{"location":"basics/query-contacts-advanced/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those contacts associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to limit the search to contacts belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>The Contacts returned may still contain RawContacts / data that belongs to other accounts not specified in the given accounts because Contacts may be made up of more than one RawContact from different Accounts. This is the same behavior as the AOSP Contacts app.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all RawContacts of Contacts are included in the search.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included in the search. RawContacts without an associated account are considered local contacts or device-only contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts-advanced/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the matching contacts,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/query-contacts-advanced/#optimize-your-queries","title":"Optimize your queries","text":"<p>To optimize speed and minimize CPU and memory consumption, it is highly recommended that you only include fields you need.</p> <p>For more info, read Optimizing queries.</p>"},{"location":"basics/query-contacts-advanced/#specifying-groups","title":"Specifying Groups","text":"<p>To limit the search to only those RawContacts associated with at least one of the given groups,</p> <pre><code>.where { GroupMembership.GroupId `in` groups.mapNotNull { it.id } }\n</code></pre> <p>\u2139\ufe0f For more info, read Query groups.</p> <p>Contacts returned may still contain RawContacts / data that belongs to other groups not specified in the given groups because Contacts may be made up of more than one RawContact from different Groups. This is the same behavior as the AOSP Contacts app.</p> <p>If no groups are specified, then all RawContacts of Contacts are included in the search.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts-advanced/#ordering","title":"Ordering","text":"<p>To order resulting Contacts using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order contacts by favorite/starred status such that favorite/starred contacts appear first in the list AND order by display name primary in ascending order (from a to z ignoring case),</p> <pre><code>.orderBy(\n    ContactsFields.Options.Starred.desc(),\n    ContactsFields.DisplayNamePrimary.asc()\n)\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>ContactsFields</code> to construct the orderBys.</p> <p>\u2139\ufe0f If you need to sort a collection of Contacts outside of a database query using any field (in addition to <code>ContactsFields</code>), use <code>contacts.core.util.ContactsComparator</code>. For more info, read Convenience functions.</p>"},{"location":"basics/query-contacts-advanced/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of contacts returned and/or offset (skip) a specified number of contacts, use  the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"basics/query-contacts-advanced/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"basics/query-contacts-advanced/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/query-contacts-advanced/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"basics/query-contacts-advanced/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/query-contacts-advanced/#custom-data-support","title":"Custom data support","text":"<p>The <code>Query</code> API supports custom data. For more info, read Query custom data.</p>"},{"location":"basics/query-contacts-advanced/#using-the-where-function-to-specify-matching-criteria","title":"Using the <code>where</code> function to specify matching criteria","text":"<p>Use the <code>contacts.core.Fields</code> combined with the extensions from <code>contacts.core.Where</code> to form WHERE clauses. </p> <p>\u2139\ufe0f This docs page will not provide a tutorial on database where clauses. It assumes that you know the basics.  If you don't know the basics, then search for sqlite where clause. </p> <p>For example, to get all contacts with a phone number AND email,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    ...\n    .where { Phone.Number.isNotNullOrEmpty() and Email.Address.isNotNullOrEmpty() }\n    .find()\n</code></pre> <p>To get a list of contacts with the given IDs,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    ...\n    .where { Contact.Id `in` contactIds }\n    .find()\n</code></pre>"},{"location":"basics/query-contacts-advanced/#performance","title":"Performance","text":"<p>Using <code>where</code> may require one or more additional queries, internally performed by the API, which increases the time it takes for the query to complete. Therefore, you should only use <code>where</code> if  you actually need it.</p> <p>For every usage of the <code>and</code> operator where the left-hand-side and right-hand-side are different  data kinds, an internal database query is performed. This is due to the way the Data table is  structured in relation to Contacts. For example,</p> <pre><code>Email.Address.isNotNull() and Phone.Number.isNotNull() and Address.FormattedAddress.isNotNull()\n</code></pre> <p>The above will require two additional internal database queries in order to simplify the query such  that it can actually provide matching Contacts.</p> <p>Using the <code>or</code> operator does not have this performance hit.</p>"},{"location":"basics/query-contacts-advanced/#groups-matching","title":"Groups Matching","text":"<p>Unlike <code>BroadQuery.groups</code>, this does not have a <code>groups</code> function. You may still match groups (in a much flexible way) by using <code>Fields.GroupMembership</code> with <code>where</code>.</p>"},{"location":"basics/query-contacts-advanced/#limitations","title":"Limitations","text":"<p>This library only provides basic WHERE functions. It does not cover the entirety of SQLite, though  the community may add more over time &lt;3</p> <p>Furthermore, this library is constrained by rules and limitations set by the Contacts Provider and the behavior of the AOSP Contacts app. One such rule/limitation has resulted in this library not providing WHERE functions such as <code>isNull</code> or <code>isNullOrEmpty</code> to prevent making misleading queries.</p> <p>Removing a piece of existing data results in the deletion of the row in the Data table if that row  no longer contains any meaningful data. This is the behavior of the AOSP Contacts app. Therefore,  querying for null fields is not possible. For example, there may be no Data rows that exist where  the email address is null. Thus, a query to search for all contacts with no email addresses may  return 0 contacts even if there are some contacts that do not have at least one email address.</p> <p>If you want to match contacts that has no particular type of data, you will have to make two  queries. One to get contacts that have that particular type of data and another to get contacts that were not part of the first query results. For example,</p> <pre><code>val contactsWithEmails = query\n    .include(Fields.Contact.Id)\n    .where { Email.Address.isNotNullOrEmpty() }\n    .find()\n\nval contactIdsWithEmails = contactsWithEmails.mapNotNull { it.id }\nval contactsWithoutEmails = query\n    .where { Contact.Id notIn contactIdsWithEmails }\n    .find()\n</code></pre> <p>There is a special case with phone numbers. The ContactsContract provides a field that is true if the contact has at least one phone number; <code>Fields.Contact.HasPhoneNumber</code>. The phone number is the  only kind of data that the ContactsContract provides with an indexed value such as this. The  ContactsContract does NOT provide things like \"hasEmail\", \"hasWebsite\", etc. Regardless, this  library provide functions to match contacts that \"has at least one instance of a kind of data\".  The <code>HasPhoneNumber</code> field is not necessary to get contacts that have a phone number. However, this  does provide an easy way to get contacts that have no phone numbers without having to make two  queries. For example,</p> <pre><code>val contactsWithNoPhoneNumbers = query\n    .where { Contact.HasPhoneNumber notEqualTo true }\n    .find()\n</code></pre>"},{"location":"basics/query-contacts-by-lookup-key/","title":"Query contacts by lookup key","text":"<p>This library provides the <code>LookupQuery</code> API that uses the <code>ContactsContract.Contacts.CONTENT_LOOKUP_URI</code> to get contacts using lookup keys, which are typically used in shortcuts or other long-term links  to contacts.</p> <p>\u2139\ufe0f For more info about lookup keys, read about Contact lookup key vs ID</p> <p>An instance of the <code>LookupQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).lookupQuery()\n</code></pre> <p>\u2139\ufe0f For a broader, and more AOSP Contacts app like query that allows partial matching, use the <code>BroadQuery</code> API, read Query contacts.</p> <p>\u2139\ufe0f For a more granular, advanced queries, use the <code>Query</code> API; Query contacts (advanced).</p> <p>\u2139\ufe0f For specialized matching of phone numbers and SIP addresses, use the <code>PhoneLookupQuery</code> API; Query contacts by phone or SIP.</p> <p>\u2139\ufe0f If you want to query RawContacts directly instead of Contacts, read Query RawContacts.</p> <p>\u2139\ufe0f If you want to query Data directly instead of Contacts, read Query specific data kinds.</p> <p>\u2139\ufe0f If you want to get the device owner Contact Profile, read Query device owner Contact profile.</p>"},{"location":"basics/query-contacts-by-lookup-key/#a-basic-query","title":"A basic query","text":"<p>To get the contact with the given lookup key,</p> <pre><code>val contact = Contacts(context)\n    .lookupQuery()\n    .whereLookupKeyMatches(lookupKey)\n    .find()\n    .firstOrNull()\n</code></pre>"},{"location":"basics/query-contacts-by-lookup-key/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those contacts associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to limit the search to contacts belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>The Contacts returned may still contain RawContacts / data that belongs to other accounts not specified in the given accounts because Contacts may be made up of more than one RawContact from different Accounts. This is the same behavior as the AOSP Contacts app.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all RawContacts of Contacts are included in the search.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included in the search. RawContacts without an associated account are considered local contacts or device-only contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts-by-lookup-key/#specifying-groups","title":"Specifying Groups","text":"<p>To limit the search to only those RawContacts associated with at least one of the given groups,</p> <pre><code>.groups(groups)\n</code></pre> <p>For example, to limit the search to only friends,</p> <pre><code>.groups(friendsGroup)\n</code></pre> <p>\u2139\ufe0f For more info, read Query groups.</p> <p>Contacts returned may still contain RawContacts / data that belongs to other groups not specified in the given groups because Contacts may be made up of more than one RawContact from different Groups. This is the same behavior as the AOSP Contacts app.</p> <p>If no groups are specified (this function is not called or called with no Groups), then all RawContacts of Contacts are included in the search.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts-by-lookup-key/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the matching contacts,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include phone fields,</p> <pre><code>.include { Phone.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/query-contacts-by-lookup-key/#optimize-your-queries","title":"Optimize your queries","text":"<p>To optimize speed and minimize CPU and memory consumption, it is highly recommended that you only  include fields you need.</p> <p>For more info, read Optimizing queries.</p>"},{"location":"basics/query-contacts-by-lookup-key/#ordering","title":"Ordering","text":"<p>To order resulting Contacts using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order contacts by favorite/starred status such that favorite/starred contacts appear first in the list AND order by display name primary in ascending order (from a to z ignoring case),</p> <pre><code>.orderBy(\n    ContactsFields.Options.Starred.desc(),\n    ContactsFields.DisplayNamePrimary.asc()\n)\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>ContactsFields</code> to construct the orderBys.</p> <p>\u2139\ufe0f If you need to sort a collection of Contacts outside of a database query using any field (in addition to <code>ContactsFields</code>), use <code>contacts.core.util.ContactsComparator</code>. For more info, read Convenience functions.</p>"},{"location":"basics/query-contacts-by-lookup-key/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of contacts returned and/or offset (skip) a specified number of contacts, use  the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"basics/query-contacts-by-lookup-key/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"basics/query-contacts-by-lookup-key/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/query-contacts-by-lookup-key/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"basics/query-contacts-by-lookup-key/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/query-contacts-by-phone-or-sip/","title":"Query contacts by phone or SIP","text":"<p>This library provides the <code>PhoneLookupQuery</code> API that performs a highly optimized query using a  phone number or SIP address. This will only match EXACT phone numbers or SIP addresses of different formatting and variations. There is no partial matching. This is useful for dialer apps that want  to implement caller IDs for incoming and outgoing calls.</p> <p>An instance of the <code>PhoneLookupQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).phoneLookupQuery()\n</code></pre> <p>\u2139\ufe0f For a broader, and more AOSP Contacts app like query that allows partial matching, use the <code>BroadQuery</code> API, read Query contacts.</p> <p>\u2139\ufe0f For a more granular, advanced queries, use the <code>Query</code> API; Query contacts (advanced).</p> <p>\u2139\ufe0f To query contacts using lookup keys, read Query contacts by lookup key.</p> <p>\u2139\ufe0f If you want to query RawContacts directly instead of Contacts, read Query RawContacts.</p> <p>\u2139\ufe0f If you want to query Data directly instead of Contacts, read Query specific data kinds.</p> <p>\u2139\ufe0f If you want to get the device owner Contact Profile, read Query device owner Contact profile.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#a-basic-query","title":"A basic query","text":"<p>To get all contacts that have the exact phone number \"555-555-5555\",</p> <pre><code>val contacts = Contacts(context)\n    .phoneLookupQuery()\n    .whereExactlyMatches(\"555-555-5555\")\n    .find()\n</code></pre> <p>The above query will also match contacts that have the following formatting and variations of that number, such as \"5555555555\", \"(555) 555-5555\", or \"+1 (555) 555-5555\" regardless of the normalized number stored in the database. For more info about matching, read up on the  <code>match</code> function</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those contacts associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to limit the search to contacts belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>The Contacts returned may still contain RawContacts / data that belongs to other accounts not specified in the given accounts because Contacts may be made up of more than one RawContact from different Accounts. This is the same behavior as the AOSP Contacts app.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all RawContacts of Contacts are included in the search.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included in the search. RawContacts without an associated account are considered local contacts or device-only contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#specifying-groups","title":"Specifying Groups","text":"<p>To limit the search to only those RawContacts associated with at least one of the given groups,</p> <pre><code>.groups(groups)\n</code></pre> <p>For example, to limit the search to only friends,</p> <pre><code>.groups(friendsGroup)\n</code></pre> <p>\u2139\ufe0f For more info, read Query groups.</p> <p>Contacts returned may still contain RawContacts / data that belongs to other groups not specified in the given groups because Contacts may be made up of more than one RawContact from different Groups. This is the same behavior as the AOSP Contacts app.</p> <p>If no groups are specified (this function is not called or called with no Groups), then all RawContacts of Contacts are included in the search.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the matching contacts,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include phone fields,</p> <pre><code>.include { Phone.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#optimize-your-queries","title":"Optimize your queries","text":"<p>To optimize speed and minimize CPU and memory consumption, it is highly recommended that you only  include fields you need.</p> <p>For more info, read Optimizing queries.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#ordering","title":"Ordering","text":"<p>To order resulting Contacts using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order contacts by favorite/starred status such that favorite/starred contacts appear first in the list AND order by display name primary in ascending order (from a to z ignoring case),</p> <pre><code>.orderBy(\n    ContactsFields.Options.Starred.desc(),\n    ContactsFields.DisplayNamePrimary.asc()\n)\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>ContactsFields</code> to construct the orderBys.</p> <p>\u2139\ufe0f If you need to sort a collection of Contacts outside of a database query using any field (in addition to <code>ContactsFields</code>), use <code>contacts.core.util.ContactsComparator</code>. For more info, read Convenience functions.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of contacts returned and/or offset (skip) a specified number of contacts, use  the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"basics/query-contacts-by-phone-or-sip/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/query-contacts-by-phone-or-sip/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#custom-data-support","title":"Custom data support","text":"<p>The <code>PhoneLookupQuery</code> API does not include custom data in the matching process. However, you may still use the <code>include</code> function with custom data. For more info, read Query custom data.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#using-the-match-and-whereexactlymatches-functions-to-specify-matching-criteria","title":"Using the <code>match</code> and <code>whereExactlyMatches</code> functions to specify matching criteria","text":"<p>The <code>PhoneLookupQuery</code> API lets the Contacts Provider perform the search using its own custom matching algorithm via the <code>whereExactlyMatches</code> function.</p> <p>This will only match EXACT phone numbers or SIP addresses of different formatting and variations.  There is no partial matching.</p> <p>There are several different types of matching algorithms that can be used. The type is set via the <code>match</code> function.</p> <p>Custom data are not included in the matching process! To match custom data, use <code>Query</code>.</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#matchphone","title":"Match.PHONE","text":"<p>Match phone numbers. This is useful in cases where you want to implement a caller ID function for  incoming and outgoing calls. This is the default.</p> <p>For example, if there are contacts with the following numbers;</p> <ul> <li>123</li> <li>1234</li> <li>1234</li> <li>12345</li> </ul> <p>Searching for \"123\" will only return the one contact with the number \"123\". Searching for \"1234\"  will return the contact(s) with the number \"1234\".</p> <p>Additionally, this is able to match phone numbers with or without using country codes. For example,  the phone number \"+923123456789\" (country code 92) will be matched using any of the following; \"03123456789\", \"923123456789\", \"+923123456789\".</p> <p>The reverse is partially true. For example, the phone number \"03123456789\" will be matched using \"03123456789\" or \"+923123456789\" BUT will NOT be matched using \"923123456789\".</p> <p>If a phone number is saved with AND without a country code, then only the contact with the number  that matches exactly will be returned. For example, when numbers \"+923123456789\" and  \"03123456789\" are saved, searching for \"03123456789\" will return only the contact with that exact  number (NOT including the contact with \"+923123456789\").</p> <p>\u2139\ufe0f Matching is not strictly based on the <code>PhoneEntity.normalizedNumber</code> (E164 representation) if  it is not null. In cases where it is null, matching will be done strictly based on the  <code>PhoneEntity.number</code>.</p> <p>\u26a0\ufe0f The matching process/results described here may differ across OEMs and/or Android versions. For more details, read https://github.com/vestrel00/contacts-android/issues/337#issuecomment-1843672903</p>"},{"location":"basics/query-contacts-by-phone-or-sip/#matchsip","title":"Match.SIP","text":"<p>Same as <code>Match.PHONE</code> except this matches SIP addresses instead of phone numbers.</p> <p>\u26a0\ufe0f This is only available for API 21 and above. The <code>Match.PHONE</code> will be used for API versions  below 21 even if <code>Match.SIP</code> is specified.</p>"},{"location":"basics/query-contacts/","title":"Query contacts","text":"<p>This library provides the <code>BroadQuery</code> API that allows you to get the exact same search results as the AOSP Contacts app! This query lets the Contacts Provider perform the search using its own custom matching algorithm via the <code>wherePartiallyMatches</code> function. This type of query is the basis of an app that does a broad search of the Contacts Provider. The technique is useful for apps that want to implement functionality similar to the People app's contact list screen.</p> <p>An instance of the <code>BroadQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).broadQuery()\n</code></pre> <p>\u2139\ufe0f For a more granular, advanced queries, use the <code>Query</code> API; Query contacts (advanced).</p> <p>\u2139\ufe0f To query contacts using lookup keys, read Query contacts by lookup key.</p> <p>\u2139\ufe0f For specialized matching of phone numbers and SIP addresses, use the <code>PhoneLookupQuery</code> API; Query contacts by phone or SIP.</p> <p>\u2139\ufe0f If you want to query RawContacts directly instead of Contacts, read Query RawContacts.</p> <p>\u2139\ufe0f If you want to query Data directly instead of Contacts, read Query specific data kinds.</p> <p>\u2139\ufe0f If you want to get the device owner Contact Profile, read Query device owner Contact profile.</p>"},{"location":"basics/query-contacts/#a-basic-query","title":"A basic query","text":"<p>To get all contacts ordered by the primary display name,</p> <pre><code>val contacts = Contacts(context)\n    .broadQuery()\n    .orderBy(ContactsFields.DisplayNamePrimary.asc())\n    .find()\n</code></pre> <p>To get all contacts that have any data (e.g. name, email, phone, address, organization, note, etc)  that at least partially matches a given <code>searchText</code>,</p> <pre><code>val contacts = Contacts(context)\n    .broadQuery()\n    .wherePartiallyMatches(searchText)\n    .find()\n</code></pre>"},{"location":"basics/query-contacts/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those contacts associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to limit the search to contacts belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>The Contacts returned may still contain RawContacts / data that belongs to other accounts not specified in the given accounts because Contacts may be made up of more than one RawContact from different Accounts. This is the same behavior as the AOSP Contacts app.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all RawContacts of Contacts are included in the search.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included in the search. RawContacts without an associated account are considered local contacts or device-only contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts/#specifying-groups","title":"Specifying Groups","text":"<p>To limit the search to only those RawContacts associated with at least one of the given groups,</p> <pre><code>.groups(groups)\n</code></pre> <p>For example, to limit the search to only friends,</p> <pre><code>.groups(friendsGroup)\n</code></pre> <p>\u2139\ufe0f For more info, read Query groups.</p> <p>Contacts returned may still contain RawContacts / data that belongs to other groups not specified in the given groups because Contacts may be made up of more than one RawContact from different Groups. This is the same behavior as the AOSP Contacts app.</p> <p>If no groups are specified (this function is not called or called with no Groups), then all RawContacts of Contacts are included in the search.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"basics/query-contacts/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the matching contacts,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/query-contacts/#optimize-your-queries","title":"Optimize your queries","text":"<p>To optimize speed and minimize CPU and memory consumption, it is highly recommended that you only  include fields you need.</p> <p>For more info, read Optimizing queries.</p>"},{"location":"basics/query-contacts/#ordering","title":"Ordering","text":"<p>To order resulting Contacts using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order contacts by favorite/starred status such that favorite/starred contacts appear first in the list AND order by display name primary in ascending order (from a to z ignoring case),</p> <pre><code>.orderBy(\n    ContactsFields.Options.Starred.desc(),\n    ContactsFields.DisplayNamePrimary.asc()\n)\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>ContactsFields</code> to construct the orderBys.</p> <p>\u2139\ufe0f If you need to sort a collection of Contacts outside of a database query using any field (in addition to <code>ContactsFields</code>), use <code>contacts.core.util.ContactsComparator</code>. For more info, read Convenience functions.</p>"},{"location":"basics/query-contacts/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of contacts returned and/or offset (skip) a specified number of contacts, use  the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"basics/query-contacts/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"basics/query-contacts/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val contacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/query-contacts/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"basics/query-contacts/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/query-contacts/#custom-data-support","title":"Custom data support","text":"<p>The <code>BroadQuery</code> API does not include custom data in the matching process. However, you may still use the <code>include</code> function with custom data. For more info, read Query custom data.</p>"},{"location":"basics/query-contacts/#using-the-match-and-wherepartiallymatches-functions-to-specify-matching-criteria","title":"Using the <code>match</code> and <code>wherePartiallyMatches</code> functions to specify matching criteria","text":"<p>The <code>BroadQuery</code> API lets the Contacts Provider perform the search using its own custom matching algorithm via the <code>wherePartiallyMatches</code> function.</p> <p>There are several different types of matching algorithms that can be used. The type is set via the <code>match</code> function.</p> <p>Matching is case-insensitive (case is ignored).</p> <p>Custom data are not included in the matching process! To match custom data, use <code>Query</code>.</p>"},{"location":"basics/query-contacts/#matchany","title":"Match.ANY","text":"<p>Most, but not all, Contact data are included in the matching process. E.G. name, email, phone, address, organization, note, etc.</p> <p>Use this if you want to get the same results when searching contacts using the AOSP Contacts app  and the Google Contacts app.</p> <p>Data matching is more sophisticated under the hood than <code>Query</code>. The Contacts Provider matches parts of several types of data in segments. For example, a Contact having the email \"hologram@gram.net\" will be matched with the following texts;</p> <ul> <li>h</li> <li>HOLO</li> <li>@g</li> <li>@gram.net</li> <li>gram@</li> <li>net</li> <li>holo.net</li> <li>hologram.net</li> </ul> <p>But will NOT be matched with the following texts;</p> <ul> <li>olo</li> <li>@</li> <li>gram@gram</li> <li>am@gram.net</li> </ul> <p>Similarly, a Contact having the name \"Zack Air\" will be matched with the following texts;</p> <ul> <li>z</li> <li>zack</li> <li>zack, air</li> <li>air, zack</li> <li>za a</li> <li>, z</li> <li>, a</li> <li>,a</li> </ul> <p>But will NOT be matched with the following texts;</p> <ul> <li>ack</li> <li>ir</li> <li>,</li> </ul> <p>Another example is a Contact having the note \"Lots   of   spa        ces.\" will be matched with the following texts;</p> <ul> <li>l</li> <li>lots</li> <li>lots of</li> <li>of lots</li> <li>ces spa       lots of.</li> <li>lo o sp ce . . . . .</li> </ul> <p>But will NOT be matched with the following texts;</p> <ul> <li>.</li> <li>ots</li> </ul> <p>Several types of data are matched in segments. E.G. A Contact with display name \"Bell Zee\" and  phone numbers \"987\", \"1 23\", and \"456\" will be matched with \"be bell ze 9 123 1 98 456\".</p>"},{"location":"basics/query-contacts/#matchphone","title":"Match.PHONE","text":"<p>Only phones or (contact display name + any phones) are included in the matching process.</p> <p>Use this if you want to get contacts that have a matching phone number or matching (<code>Contact.displayNamePrimary</code> + any phone number).</p> <p>If you are attempting to matching contacts with phone numbers using <code>Query</code>, then you will most likely find it to difficult and tricky because the normalizedNumber could be null and matching formatted numbers (e.g. (718) 737-1991) would require some special regular expressions. This match might just be what you need =)</p> <p>Only the <code>Contact.displayNamePrimary</code> and the phone number/normalizedNumber are included in the matching process.</p> <p>For example, a contact with <code>Contact.displayNamePrimary</code> of \"Bob Dole\" and phone number \"(718) 737-1991\" (regardless of the value of normalizedNumber) will be matched with the following texts;</p> <ul> <li>718</li> <li>7187371991</li> <li>7.1-8.7-3.7-19(91)</li> <li>bob</li> <li>dole</li> </ul> <p>Notice that \"bob\" and \"dole\" will trigger a match because the display name matches and the contact has a phone number.</p> <p>The following texts will NOT trigger a match because the comparison begins at the beginning of the string and not in the middle or end;</p> <ul> <li>737</li> <li>1991</li> </ul>"},{"location":"basics/query-contacts/#matchemail","title":"Match.EMAIL","text":"<p>Only emails or (contact display name + any emails) are included in the matching process.</p> <p>Only the <code>Contact.displayNamePrimary</code> and the email address are included in the matching process.</p> <p>For example, the search text \"bob\" will match the following contacts;</p> <ul> <li>Robert Parr (bob@incredibles.com)</li> <li>Bob Parr (incredible@android.com)</li> </ul> <p>Notice that the contact Bob Parr is also matched because the display name matches and an email exist (even though it does not match).</p> <p>The following search texts will NOT trigger a match because the comparison begins at the beginning of the string and not in the middle or end;</p> <ul> <li>android</li> <li>gmail</li> <li>@</li> <li>.com</li> </ul>"},{"location":"basics/query-contacts/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":"<p>Matching only by phone number or email address is possible thanks to the following filter Uris defined in <code>ContactsContract</code>, which exist for this specific purpose.</p> <pre><code>ContactsContract {\n    Contacts { CONTENT_FILTER_URI } // Default used by BroadQuery\n    CommonDataKinds {\n        Phone { CONTENT_FILTER_URI }\n        Email { CONTENT_FILTER_URI }\n    }\n} \n</code></pre> <p>These special filter URIs are only available for the phone and email common data kinds.</p> <p>Note that the <code>EMAIL</code> and <code>PHONE</code> additionally matches the contact display name.</p>"},{"location":"basics/query-contacts/#comparison-table","title":"Comparison table","text":"<p>I've done some preliminary testing on the differences between the different matching/filter  algorithms. So, given the following contacts...</p> <ol> <li>Display name: Robert Parr<ul> <li>Email: bob@incredibles.com</li> </ul> </li> <li>Display name: Bob Parr<ul> <li>Email: incredible@android.com</li> </ul> </li> <li>Display name: Bob Dole<ul> <li>Phone: (718) 737-1991</li> </ul> </li> <li>Display name: vestrel00@gmail.com<ul> <li>Email: vestrel00@gmail.com</li> </ul> </li> <li>Display name: 646-123-4567<ul> <li>Phone: 646-123-4567</li> </ul> </li> <li>Display name: Secret agent.<ul> <li>Address: Dole street</li> <li>Company: 718</li> <li>Note: Agent code is 646000. His skills are incredible!</li> </ul> </li> </ol> <p>Here are some search terms followed by matching contacts based on the type of <code>Match</code> used.</p> Search term ANY PHONE EMAIL bob 1, 2, 3 3 1, 2 incredible 1, 2, 6 2 android 2 gmail 4 .com 1, 2, 4 @ 7187371991 3 3 7.1-8.7-3.7-19(91) 3 3 646 5, 6 5 646-646 6 718 3, 6 3 1991 4567 000 dole 3, 6 3 <p>The above table gives us some insight on how sophisticated the matching (or search / indexing)  algorithm is.</p> <p>For the search term \"bob\",</p> <ul> <li>PHONE matches contact 3.<ul> <li>Display name matches and contact has a phone even though it does match.</li> </ul> </li> <li>EMAIL matches contact 1, 2.<ul> <li>1 has a matching email \"bob\". 2 is also matched because the name matches even though the email   does not. On the other hand, 3 is NOT matched even though the name matches because 3 has no   email. Adding an email to 3 will cause 3 to be matched.</li> </ul> </li> </ul> <p>For the search term \"incredible\",</p> <ul> <li>EMAIL matches 2 (incredible@android.com) but NOT 1 (bob@incredibles.com).<ul> <li>This means that email matching does not use <code>contains</code> but rather a form of <code>startsWith</code>.</li> </ul> </li> </ul> <p>TLDR</p> <ul> <li>ANY matches any contact data; name, email, phone, address, organization, note, etc.</li> <li>EMAIL matches emails or (display name + any email)</li> <li>PHONE matches phones or (display name + any phone)</li> <li>EMAIL and PHONE matching is NOT as simple as using the <code>Query</code> API   with <code>.where { [Email|Phone] contains searchTerm }</code></li> </ul>"},{"location":"basics/query-raw-contacts/","title":"Query RawContacts","text":"<p>This library provides the <code>RawContactsQuery</code> API that allows you to get a list of RawContacts  matching a specific search criteria. Use this if you want to show RawContacts directly (something that the Google Contacts app does) instead of Contacts that may consist of several linked RawContacts.</p> <p>\u26a0\ufe0f The APIs for this have changed significantly since version 0.3.0. For documentation for version 0.2.4 and below, visit this page (click me).</p> <p>An instance of the <code>RawContactsQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).rawContactsQuery()\n</code></pre> <p>\u2139\ufe0f For a broader, and more AOSP Contacts app like query, use the <code>BroadQuery</code> API, read Query contacts.</p> <p>\u2139\ufe0f To query contacts using lookup keys, read Query contacts by lookup key.</p> <p>\u2139\ufe0f For specialized matching of phone numbers and SIP addresses, use the <code>PhoneLookupQuery</code> API; Query contacts by phone or SIP.</p> <p>\u2139\ufe0f If you want to get Contacts instead of RawContacts; Query contacts (advanced).</p> <p>\u2139\ufe0f If you want to query Data directly instead of Contacts, read Query specific data kinds.</p> <p>\u2139\ufe0f If you want to get the device owner Contact Profile, read Query device owner Contact profile.</p>"},{"location":"basics/query-raw-contacts/#a-basic-query","title":"A basic query","text":"<p>To get all RawContacts, </p> <pre><code>val rawContacts = Contacts(context).rawContactsQuery().find()\n</code></pre>"},{"location":"basics/query-raw-contacts/#an-advanced-query","title":"An advanced query","text":"<p>To retrieve the first 5 RawContacts in the given account that has at least one email, skipping the  first 2, where the RawContact's display name starts with \"a\", ordered by the display name in  ascending order (ignoring case),</p> <pre><code>val rawContacts = rawContactsQuery\n    .rawContactsWhere(emptySet(), RawContactsFields.DisplayNamePrimary.isNotNullOrEmpty() )\n    .where { Email.Address.isNotNullOrEmpty() }\n    .orderBy(RawContactsFields.DisplayNamePrimary.asc())\n    .limit(5)\n    .offset(2)\n    .find()\n</code></pre>"},{"location":"basics/query-raw-contacts/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the matching RawContacts,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include the RawContact's primary display name, and email and name fields,</p> <pre><code>.includeRawContactsFields(RawContactsFields.DisplayNamePrimary)\n.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/query-raw-contacts/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those RawContacts associated with one of the given accounts,</p> <pre><code>.rawContactsWhere(accounts, null)\n</code></pre> <p>For example, to limit the search to contacts belonging to only one account,</p> <pre><code>.rawContactsWhere(listOf(Account(\"john.doe@gmail.com\", \"com.google\")), null)\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all RawContacts of Contacts are included in the search.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included in the search. RawContacts without an associated account are considered local contacts or device-only contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally  performed in this function, which increases the time required for the search. Therefore, you  should only specify this if you actually need it.</p>"},{"location":"basics/query-raw-contacts/#ordering","title":"Ordering","text":"<p>To order resulting RawContacts using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order RawContacts by account type,</p> <pre><code>.orderBy(RawContactsFields.AccountType.asc())\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>RawContactsFields</code> to construct the orderBys.</p>"},{"location":"basics/query-raw-contacts/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of RawContacts returned and/or offset (skip) a specified number of RawContacts,  use the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"basics/query-raw-contacts/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"basics/query-raw-contacts/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val rawContacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/query-raw-contacts/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"basics/query-raw-contacts/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/query-raw-contacts/#custom-data-support","title":"Custom data support","text":"<p>The <code>RawContactsQuery</code> API supports custom data. For more info, read Query custom data.</p>"},{"location":"basics/query-raw-contacts/#rawcontacts-from-more-than-one-account-in-the-same-list","title":"RawContacts from more than one account in the same list","text":"<p>When you perform a query that returns groups from more than one account, you will get everything in the same list. This list is just like any other <code>List</code> except it also provides an extra function that allows you to get a sublist with RawContacts belonging only to a particular account.</p> <pre><code>val rawContactsFromAccount = rawContactsList.from(account)\n</code></pre>"},{"location":"basics/query-raw-contacts/#getting-contacts-from-rawcontacts","title":"Getting Contacts from RawContacts","text":"<p>If you want to get the Contacts and all associated RawContacts and Data from a set of <code>RawContact</code>s,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    .where { RawContact.Id `in` rawContactIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>If you need a more convenient way to convert the <code>RawContact</code>s to <code>Contact</code>s, use  <code>RawContactContact</code> extensions. For more info, read Convenience functions.</p>"},{"location":"basics/query-raw-contacts/#profile-rawcontacts","title":"Profile RawContacts","text":"<p>The <code>RawContactsQuery</code> API also supports querying the Profile (device owner) RawContacts.  To get an instance of this API for Profile queries,</p> <pre><code>val query = Contacts(context).profile().rawContactsQuery()\n</code></pre> <p>All queries will be limited to the Profile, whether it exists or not.</p>"},{"location":"basics/query-raw-contacts/#using-the-where-and-rawcontactswhere-function-to-specify-matching-criteria","title":"Using the <code>where</code> and <code>rawContactsWhere</code> function to specify matching criteria","text":"<p>Use the <code>contacts.core.Fields</code> and <code>contacts.core.RawContactsFields</code> combined with the extensions  from <code>contacts.core.Where</code> to form WHERE clauses. </p> <p>\u2139\ufe0f This docs page will not provide a tutorial on database where clauses. It assumes that you know  the basics. If you don't know the basics, then search for sqlite where clause. </p> <p>For example, to get a list of RawContacts with the given IDs,</p> <pre><code>val rawContacts = Contacts(context)\n    .rawContactsQuery()\n    .rawContactsWhere(emptyList(), RawContactsFields.Id `in` rawContactIds)\n    // alternatively, .where { RawContact.Id `in` rawContactIds }\n    .find()\n</code></pre> <p>To get all favorited/starred RawContacts,</p> <pre><code>fun getAllFavoriteRawContacts(): List&lt;RawContact&gt; = Contacts(this)\n    .rawContactsQuery()\n    .rawContactsWhere(emptyList(), RawContactsFields.Options.Starred equalTo true)\n    .find()\n</code></pre>"},{"location":"basics/query-raw-contacts/#limitations","title":"Limitations","text":"<p>This library only provides basic WHERE functions. It does not cover the entirety of SQLite, though  the community may add more over time &lt;3</p> <p>Furthermore, this library is constrained by rules and limitations set by the Contacts Provider and the behavior of the AOSP Contacts app. One such rule/limitation has resulted in this library not providing WHERE functions such as <code>isNull</code> or <code>isNullOrEmpty</code> to prevent making misleading queries.</p>"},{"location":"basics/update-contacts/","title":"Update contacts","text":"<p>This library provides the <code>Update</code> API that allows you to updates one or more contacts in the  Contacts Provider database to ensure that it contains the same data as the contacts and raw contacts provided in memory.</p> <p>An instance of the <code>Update</code> API is obtained by,</p> <pre><code>val update = Contacts(context).update()\n</code></pre> <p>\u2139\ufe0f If you want to update the device owner Contact Profile, read Update device owner Contact profile.</p> <p>\u2139\ufe0f If you want to update a set of Data, read Update existing sets of data.</p>"},{"location":"basics/update-contacts/#a-basic-update","title":"A basic update","text":"<p>To update a Contact and all of its RawContacts,</p> <pre><code>val updateResult = Contacts(context)\n    .update()\n    .contacts(johnDoe.mutableCopy {\n       setOrganization {\n           company = \"Microsoft\"\n           title = \"Newb\"\n       }\n       emails().first().apply {\n           address = \"john.doe@microsoft.com\"\n       }\n    })\n    .commit()\n</code></pre> <p>To update a RawContact directly,</p> <pre><code>val updateResult = Contacts(context)\n    .update()\n    .rawContacts(johnDoeFromGmail.mutableCopy {\n       setOrganization {\n           company = \"Microsoft\"\n           title = \"Newb\"\n       }\n       emails().first().apply {\n           address = \"john.doe@microsoft.com\"\n       }\n    })\n    .commit()\n</code></pre>"},{"location":"basics/update-contacts/#deleting-blanks","title":"Deleting blanks","text":"<p>The API allows you to specify if you want the update operation to delete blank contacts or not,</p> <pre><code>.deleteBlanks(true|false)\n</code></pre> <p>For more info, read about Blank contacts.</p>"},{"location":"basics/update-contacts/#blank-data-are-deleted","title":"Blank data are deleted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are  deleted by update APIs, unless the corresponding fields are not included in the operation.</p> <p>For more info, read about Blank data.</p>"},{"location":"basics/update-contacts/#including-only-specific-data","title":"Including only specific data","text":"<p>To perform update operations only the given set of fields (data),</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to perform updates on only email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"basics/update-contacts/#executing-the-update","title":"Executing the update","text":"<p>To execute the update,</p> <pre><code>.commit()\n</code></pre>"},{"location":"basics/update-contacts/#handling-the-update-result","title":"Handling the update result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <pre><code>val contactsApi =  Contacts(context)\nval mutableContact1 = contact1.mutableCopy { ... }\nval mutableContact2 = contact2.mutableCopy { ... }\n\nval updateResult = contactsApi\n    .update()\n    .contacts(mutableContact1, mutableContact2)\n    .commit()\n</code></pre> <p>To check if all updates succeeded,</p> <pre><code>val allUpdatesSuccessful = updateResult.isSuccessful\n</code></pre> <p>To check if a particular update succeeded,</p> <pre><code>val firstUpdateSuccessful = updateResult.isSuccessful(mutableContact1)\n</code></pre> <p>Once you have performed the updates, you can retrieve the updated Contacts references via the <code>Query</code> API,</p> <pre><code>val updatedContacts = contactsApi\n    .query()\n    .where { Contact.Id `in` listOf(contact1.id) }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Alternatively, you may use the extensions provided in <code>ContactRefresh</code> and <code>RawContactRefresh</code>.</p> <p>To get the updated Contact and all of its RawContacts and Data,</p> <pre><code>val updatedContact1 = contact1.refresh(contactsApi)\n</code></pre> <p>To get an updated RawContact and Data,</p> <pre><code>val updatedRawContact1 = contact1.rawContacts.first().refresh(contactsApi)\n</code></pre>"},{"location":"basics/update-contacts/#cancelling-the-update","title":"Cancelling the update","text":"<p>To cancel an update amid execution,</p> <pre><code>.commit { returnTrueIfUpdateShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel update processing as soon as possible. The function is called numerous times during update processing to check if processing should stop or continue. This gives you the option to cancel the update.</p> <p>For example, to automatically cancel the update inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val updateResult = update.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"basics/update-contacts/#performing-the-update-and-result-processing-asynchronously","title":"Performing the update and result processing asynchronously","text":"<p>Updates are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"basics/update-contacts/#performing-the-update-with-permission","title":"Performing the update with permission","text":"<p>Updates require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the update  will do nothing and return a failed result.</p> <p>To perform the update with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"basics/update-contacts/#custom-data-support","title":"Custom data support","text":"<p>The <code>Update</code> API supports custom data. For more info, read Update custom data.</p>"},{"location":"basics/update-contacts/#modifiable-contact-fields","title":"Modifiable Contact fields","text":"<p>As per documentation in <code>android.provider.ContactsContract.Contacts</code>,</p> <p>\u2139\ufe0f Only certain columns of Contact are modifiable: STARRED, CUSTOM_RINGTONE, SEND_TO_VOICEMAIL. Changing any of these columns on the Contact also changes them on all constituent raw contacts.</p> <p>The rest of the APIs provided in this library allow you to modify Data fields (e.g. Email, Phone,  etc). Essentially, anything that the Contacts Provider allows for modification =) </p>"},{"location":"basics/update-contacts/#updating-photos-and-thumbnails","title":"Updating photos and thumbnails","text":"<p>To set full-sized photos (and by API design thumbnails), read Get set remove full-sized and thumbnail contact photos.</p>"},{"location":"basics/update-contacts/#local-rawcontacts","title":"Local RawContacts","text":"<p>Updates to local RawContacts are not synced!</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p>"},{"location":"blockednumbers/about-blocked-numbers/","title":"Blocked numbers","text":"<p>The Android 7.0 (API 24) release introduced the Blocked Numbers content provider that stores a list of phone numbers the user has specified should not be able to contact them via telephony communications (calls, SMS, MMS).</p> <p>This library provides the following APIs that allow you to read/write blocked numbers;</p> <ul> <li><code>BlockedNumbersQuery</code></li> <li><code>BlockedNumbersInsert</code></li> <li><code>BlockedNumbersDelete</code></li> </ul>"},{"location":"blockednumbers/about-blocked-numbers/#blocked-number-data","title":"Blocked number data","text":"<p>Blocked number data consists of the <code>number</code> and <code>normalizedNumber</code>.</p> <p>The <code>BlockedNumber.number</code> is the phone number to block as the user entered it. It may or may not be formatted (e.g. (012) 345-6789).</p> <p>\u2139\ufe0f Other than regular phone numbers, the blocked number provider can also store addresses (such as email) from which a user can receive messages, and calls.</p> <p>The <code>BlockedNumber.normalizedNumber</code> is the <code>number</code>'s E164 representation (e.g. +10123456789). This value can be omitted in which case the provider will try to automatically infer it. (It'll be left null if the provider fails to infer.) If present, <code>number</code> has to be set as well (it will be ignored otherwise). If you want to set this value yourself, you may want to look at <code>android.telephony.PhoneNumberUtils</code>.</p> <p>\u2139\ufe0f This may contain an email if <code>number</code> is an email.</p>"},{"location":"blockednumbers/about-blocked-numbers/#privileges-to-readwrite-blocked-numbers-directly","title":"Privileges to read/write blocked numbers directly","text":"<p>Reading and writing directly to the Blocked Numbers database table can only be done by certain privileged apps. The Blocked Number APIs this library provides will only work if all of the  following requirements are met;</p> <ul> <li>your app must is a system app and/or the default dialer/phone app and/or the default SMS/messaging   app</li> <li>the current user (if in a multi-user environment) must be allowed to read/write blocked numbers</li> <li>the runtime OS version is at least Android 7.0 (N) (API 24)</li> </ul> <p>To check if all of the requirements specified above are met,</p> <pre><code>val canReadAndWriteBlockedNumbers = Contacts(context).blockedNumbers().privileges.canReadAndWrite()\n</code></pre> <p>Starting with Android 11 (API 30), you must include the following to your app's manifest in order to successfully use this function and therefore the bocked number APIs provided in this library.</p> <pre><code>&lt;queries&gt;\n    &lt;intent&gt;\n        &lt;action android:name=\"android.provider.Telephony.SMS_DELIVER\" /&gt;\n    &lt;/intent&gt;\n&lt;/queries&gt;\n</code></pre> <p>\u2139\ufe0f The above is required to be able to check if your app is the default SMS/messaging app.</p>"},{"location":"blockednumbers/about-blocked-numbers/#use-the-builtin-blocked-numbers-activity","title":"Use the builtin Blocked Numbers activity","text":"<p>If your app does not have the privilege to read/write directly to the blocked number provider, you may instead launch the builtin system Blocked numbers activity. It provides a fully functional UI allowing users to see, add, and remove blocked numbers. It is the same activity used by the AOSP  Contacts app and Google Contacts app when accessing the \"Blocked numbers\".</p> <pre><code>Contacts(context).blockedNumbers().startBlockedNumbersActivity(activity)\n</code></pre> <p>If the <code>activity</code> is null, the builtin blocked numbers activity will be launched as a new task, separate from the current application instance. If it is provided, then the activity will be part of the current application's stack/history.</p> <p>Blocked numbers have been introduced in Android 7.0 (N) (API 24). Therefore, this will do nothing for versions lower than API 24.</p>"},{"location":"blockednumbers/about-blocked-numbers/#using-the-defaultdialerrequest-extensions","title":"Using the DefaultDialerRequest extensions","text":"<p>The most common way for 3rd party apps (apps that don't come pre-installed by the OEM) to get direct read/write access to the blocked numbers table is to be set as the default dialer/phone or SMS/messaging app.</p> <p>The <code>contacts.ui.util.DefaultDialerRequest.kt</code> in the <code>ui</code> module` provides extension functions that allow you to prompt the user to set your app as the default dialer/phone app.</p> <p>To use it,</p> <pre><code>Activity {\n    fun onRequestToBeTheDefaultDialerAppClicked() {\n        requestToBeTheDefaultDialerApp()\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        onRequestToBeDefaultDialerAppResult(requestCode, resultCode) {\n            // You are now able to use the BlockedNumbersQuery, BlockedNumbersInsert, and \n            // BlockedNumbersDelete APIs.\n        }\n    }\n}\n</code></pre> <p>As per the official docs in <code>RoleManagerCompat.ROLE_DIALER</code>, your app must have an activity with following intent filters in your manifest. Otherwise, this will do nothing.</p> <pre><code>&lt;activity&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.DIAL\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;\n    &lt;/intent-filter&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.DIAL\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;\n        &lt;data android:scheme=\"tel\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>The above intent filters do NOT need to be added to the activity where the extension functions are invoked. It can be placed in any activity within the application.</p> <p>Additionally, starting with API 33 (Tiramisu), to qualify for this role, an application needs to  handle the intent to dial, and implement an <code>android.telecom.InCallService</code>...</p> <pre><code>@TargetApi(Build.VERSION_CODES.M)\nclass SampleInCallServiceForDialerRoleRequest: InCallService()\n</code></pre> <pre><code>&lt;service\n    android:name=\".SampleInCallServiceForDialerRoleRequest\"\n    android:exported=\"true\"\n    android:permission=\"android.permission.BIND_INCALL_SERVICE\"&gt;\n    &lt;meta-data\n        android:name=\"android.telecom.IN_CALL_SERVICE_UI\"\n        android:value=\"true\" /&gt;\n    &lt;meta-data\n        android:name=\"android.telecom.IN_CALL_SERVICE_CAR_MODE_UI\"\n        android:value=\"false\" /&gt;\n\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.telecom.InCallService\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/service&gt;\n</code></pre> <p>To check if your app is the default dialer/phone app,</p> <pre><code>Context.isDefaultDialerApp()\n</code></pre> <p>If your app is not a dialer/phone app, then you should not set it as the default dialer/phone app. Otherwise, users of your app may get confused as to why you are prompting them for this privilege. If you still want to read/write blocked numbers directly, you may still use this method. However, make it clear to your users as to why you are doing this despite your app not being a dialer/phone app.</p>"},{"location":"blockednumbers/about-blocked-numbers/#update-an-existing-blocked-number-entry","title":"Update an existing blocked number entry","text":"<p>Update operations are not supported by the Blocked Number provider. Use delete and insert instead.</p>"},{"location":"blockednumbers/about-blocked-numbers/#debugging","title":"Debugging","text":"<p>To look at all of the rows in the Blocked Numbers table, use the <code>Context.logBlockedNumbersTable</code> function in the <code>debug</code> module.</p> <p>For more info, read Debug the Blocked Number Provider tables.</p>"},{"location":"blockednumbers/delete-blocked-numbers/","title":"Delete blocked numbers","text":"<p>This library provides the <code>BlockedNumbersDelete</code> API that allows you to delete existing  BlockedNumbers.</p> <p>An instance of the <code>BlockedNumbersDelete</code> API is obtained by,</p> <pre><code>val delete = Contacts(context).blockedNumbers().delete()\n</code></pre> <p>Note that blocked number deletions will only work for privileged apps. For more info, read about Blocked numbers.</p>"},{"location":"blockednumbers/delete-blocked-numbers/#a-basic-delete","title":"A basic delete","text":"<p>To delete a set of existing blocked numbers,</p> <p><pre><code>val deleteResult = delete\n    .blockedNumbers()\n    .delete()\n    .blockedNumbers(existingBlockedNumbers)\n    .commit()\n</code></pre> To delete a set of existing blocked numbers using IDs,</p> <pre><code>val deleteResult = delete\n    .blockedNumbers()\n    .delete()\n    .blockedNumbersWithId(1, 2, 3)\n    .commit()\n</code></pre>"},{"location":"blockednumbers/delete-blocked-numbers/#an-advanced-delete","title":"An advanced delete","text":"<p>You may specify a matching criteria, like in queries, that will delete all matching blocked numbers,</p> <pre><code>val deleteResult = delete\n    .dataWhere { Number contains \"555\" }\n    .commit()\n</code></pre>"},{"location":"blockednumbers/delete-blocked-numbers/#executing-the-delete","title":"Executing the delete","text":"<p>To execute the delete,</p> <pre><code>.commit()\n</code></pre> <p>If you want to delete all given blockedNumbers in a single atomic transaction,</p> <pre><code>.commitInOneTransaction()\n</code></pre> <p>The call to <code>commitInOneTransaction</code> will only succeed if ALL given blocked numbers are successfully deleted. If one delete fails, the entire operation will fail and everything will be reverted prior to the delete operation. In contrast, <code>commit</code> allows for some deletes to succeed and some to fail.</p>"},{"location":"blockednumbers/delete-blocked-numbers/#handling-the-delete-result","title":"Handling the delete result","text":"<p>The <code>commit</code> and <code>commitInOneTransaction</code> functions returns a <code>Result</code>,</p> <p>To check if all deletes succeeded,</p> <pre><code>val allDeletesSuccessful = deleteResult.isSuccessful\n</code></pre> <p>To check if a particular delete succeeded,</p> <pre><code>val deleteSuccessful = deleteResult.isSuccessful(blockedNumber)\nval deleteSuccessful = deleteResult.isSuccessful(blockedNumber.id)\n</code></pre> <p>To check if a particular advanced delete managed to delete at least one matching blocked number,</p> <pre><code>val where = BlockedNumbersFields.Number contains \"555\"\nval deleteResult = delete.groupsWhere(where).commit()\nval advancedDeleteSuccessful = deleteResult.isSuccessful(where)\n</code></pre>"},{"location":"blockednumbers/delete-blocked-numbers/#performing-the-delete-and-result-processing-asynchronously","title":"Performing the delete and result processing asynchronously","text":"<p>Deletes are executed when the <code>commit</code> or <code>commitInOneTransaction</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"blockednumbers/delete-blocked-numbers/#performing-the-delete-with-permission","title":"Performing the delete with permission","text":"<p>There are no permissions required for blocked numbers. However, there are privileges that must be acquired. For more info, read about Blocked numbers.</p>"},{"location":"blockednumbers/insert-blocked-numbers/","title":"Insert blocked numbers","text":"<p>This library provides the <code>BlockedNumbersInsert</code> API that allows you to create/insert blocked numbers.</p> <p>An instance of the <code>BlockedNumbersInsert</code> API is obtained by,</p> <pre><code>val insert = Contacts(context).blockedNumbers().insert()\n</code></pre> <p>Note that blocked number insertions will only work for privileged apps. For more info, read about Blocked numbers.</p>"},{"location":"blockednumbers/insert-blocked-numbers/#a-basic-insert","title":"A basic insert","text":"<p>To create/insert a new blocked number,</p> <pre><code>val insertResult = Contacts(context)\n    .blockedNumbers()\n    .insert()\n    .blockedNumber { number = \"(555) 555-5555\" }\n    .commit()\n</code></pre> <p>If you need to insert multiple blocked numbers,</p> <pre><code>val newBlockedNumber1 = NewBlockedNumber(number = \"(555) 555-5555\")\nval newBlockedNumber2 = NewBlockedNumber(number = \"(123) 456-7890\")\n\nval insertResult = Contacts(context)\n    .blockedNumbers()\n    .insert()\n    .blockedNumbers(newBlockedNumber1, newBlockedNumber2)\n    .commit()\n</code></pre>"},{"location":"blockednumbers/insert-blocked-numbers/#executing-the-insert","title":"Executing the insert","text":"<p>To execute the insert,</p> <pre><code>.commit()\n</code></pre>"},{"location":"blockednumbers/insert-blocked-numbers/#handling-the-insert-result","title":"Handling the insert result","text":"<p>The <code>commit</code> function returns a <code>Result</code>.</p> <p>To check if all inserts succeeded,</p> <pre><code>val allInsertsSuccessful = insertResult.isSuccessful\n</code></pre> <p>To check if a particular insert succeeded,</p> <pre><code>val firstInsertSuccessful = insertResult.isSuccessful(newBlockedNumber1)\n</code></pre> <p>To get the BlockedNumber IDs of all the newly created BlockedNumbers,</p> <pre><code>val allBlockedNumberIds = insertResult.blockedNumberIds\n</code></pre> <p>To get the BlockedNumber ID of a particular BlockedNumber,</p> <pre><code>val secondBlockedNumberId = insertResult.blockedNumberId(newBlockedNumber2)\n</code></pre> <p>Once you have the BlockedNumber IDs, you can retrieve the newly created BlockedNumbers via the  <code>BlockedNumbersQuery</code> API,</p> <pre><code>val blockedNumbers = contactsApi\n    .blockedNumbers()\n    .query()\n    .where { Id `in` allBlockedNumberIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query blocked numbers.</p> <p>Alternatively, you may use the extensions provided in <code>BlockedNumbersInsertResult</code>. To get all  newly created BlockedNumbers,</p> <pre><code>val blockedNumbers = insertResult.blockedNumbers(contactsApi)\n</code></pre> <p>To get a particular blockedNumber,</p> <pre><code>val blockedNumber = insertResult.blockedNumber(contactsApi, newBlockedNumber1)\n</code></pre>"},{"location":"blockednumbers/insert-blocked-numbers/#handling-insert-failure","title":"Handling insert failure","text":"<p>The insert may fail for a particular blocked number for various reasons,</p> <pre><code>insertResult.failureReason(newBlockedNumber1)?.let {\n    when (it) {\n        NUMBER_ALREADY_BLOCKED -&gt; tellUserTheNumberIsAlreadyBlocked()\n        NUMBER_IS_BLANK -&gt; promptUserProvideANonBlankNumber()\n        UNKNOWN -&gt; showGenericErrorMessage()\n    }   \n}\n</code></pre>"},{"location":"blockednumbers/insert-blocked-numbers/#cancelling-the-insert","title":"Cancelling the insert","text":"<p>To cancel an insert amid execution,</p> <pre><code>.commit { returnTrueIfInsertShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel insert processing as soon as possible. The function is called numerous times during insert processing to check if processing should stop or continue. This gives you the option to cancel the insert.</p> <p>For example, to automatically cancel the insert inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val insertResult = insert.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"blockednumbers/insert-blocked-numbers/#performing-the-insert-and-result-processing-asynchronously","title":"Performing the insert and result processing asynchronously","text":"<p>Inserts are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"blockednumbers/insert-blocked-numbers/#performing-the-insert-with-permission","title":"Performing the insert with permission","text":"<p>There are no permissions required for blocked numbers. However, there are privileges that must be acquired. For more info, read about Blocked numbers.</p>"},{"location":"blockednumbers/query-blocked-numbers/","title":"Query blocked numbers","text":"<p>This library provides the <code>BlockedNumbersQuery</code> API that allows you to get blocked numbers.</p> <p>An instance of the <code>BlockedNumbersQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).blockedNumbers().query()\n</code></pre> <p>Note that blocked number queries will only work for privileged apps. For more info, read about Blocked numbers.</p>"},{"location":"blockednumbers/query-blocked-numbers/#a-basic-query","title":"A basic query","text":"<p>To get all of the blocked numbers,</p> <pre><code>val blockedNumbers = Contacts(context)\n    .blockedNumbers()\n    .query()\n    .find()\n</code></pre>"},{"location":"blockednumbers/query-blocked-numbers/#ordering","title":"Ordering","text":"<p>To order resulting BlockedNumbers using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order blocked numbers by number,</p> <pre><code>.orderBy(BlockedNumbersFields.Number.asc())\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>BlockedNumbersFields</code> to construct the orderBys.</p>"},{"location":"blockednumbers/query-blocked-numbers/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of blocked numbers returned and/or offset (skip) a specified number of  blocked numbers, use the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"blockednumbers/query-blocked-numbers/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"blockednumbers/query-blocked-numbers/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val blockedNumbers = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"blockednumbers/query-blocked-numbers/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"blockednumbers/query-blocked-numbers/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>There are no permissions required for blocked numbers. However, there are privileges that must be  acquired. For more info, read about Blocked numbers.</p>"},{"location":"blockednumbers/query-blocked-numbers/#using-the-where-function-to-specify-matching-criteria","title":"Using the <code>where</code> function to specify matching criteria","text":"<p>Use the <code>contacts.core.BlockedNumbersFields</code> combined with the extensions from <code>contacts.core.Where</code> to form WHERE clauses. </p> <p>\u2139\ufe0f This docs page will not provide a tutorial on database where clauses. It assumes that you know  the basics.  If you don't know the basics, then search for sqlite where clause. </p> <p>For example, to find blocked numbers that contains \"555\",</p> <pre><code>.where { Number contains \"555\" }\n</code></pre> <p>To get a list of blocked numbers by IDs,</p> <pre><code>.where { Id `in` blockedNumberIds }\n</code></pre>"},{"location":"customdata/delete-custom-data/","title":"Delete custom data","text":"<p>This library provides several APIs that supports deleting custom data.</p> <ol> <li><code>DataDelete</code></li> <li>Delete existing sets of data</li> <li><code>Delete</code></li> <li>Delete Contacts</li> <li><code>ProfileDelete</code></li> <li>Delete device owner Contact profile</li> <li><code>Update</code></li> <li>Update contacts</li> <li><code>ProfileUpdate</code></li> <li>Update device owner Contact profile</li> </ol> <p>To help illustrate how custom data integrates with these update APIs, we'll use the <code>HandleName</code> and <code>Gender</code> custom data.</p> <p>\u2139\ufe0f For more info about custom data, read Integrate custom data.</p>"},{"location":"customdata/delete-custom-data/#deleting-custom-data-via-contactsrawcontacts","title":"Deleting custom data via Contacts/RawContacts","text":"<p>Custom data, just like regular data kinds, are attached to a RawContact. They follow the same rules as regular data kinds.</p> <p>\u2139\ufe0f or more info, read about API Entities.</p> <p>For example, you are able to delete existing handle names and the gender of an existing RawContact,</p> <pre><code>mutableRawContact.removeHandleName(contactsApi, handleName)\nmutableRawContact.setGender(contactsApi, null)\n</code></pre> <p>There are also extensions that allow you to delete custom data of an existing RawContact via a Contact, which can be made up of one or more RawContacts,</p> <pre><code>mutableContact.removeHandleName(contactsApi, handleName)\nmutableContact.setGender(contactsApi, null)\n</code></pre> <p>Once you have removed custom data, you can perform the update operation on the RawContact to commit  your changes into the database using <code>Update</code> or <code>ProfileUpdate</code>.</p> <p>You may also delete an entire Contact or RawContact using <code>Delete</code> or <code>ProfileDelete</code> in order delete all associated data.</p>"},{"location":"customdata/delete-custom-data/#deleting-set-of-custom-data-directly","title":"Deleting set of custom data directly","text":"<p>All custom data are compatible with the <code>DataDelete</code> API, which allows you to delete sets of existing regular and custom data kinds.</p> <p>For example, to delete a set of <code>HandleName</code>s and <code>Gender</code>s,</p> <pre><code>val handleNames: List&lt;MutableHandleName&gt;\nval genders: List&lt;MutableGender&gt;\n\nval deleteResult = Contacts(this)\n   .data()\n   .delete()\n   .data(handleNames + genders)\n   .commit()\n</code></pre> <p>For more info, read Delete existing sets of data.</p>"},{"location":"customdata/insert-custom-data/","title":"Insert custom data into new or existing contacts","text":"<p>Regular and custom data can only be created/inserted into the database whenever inserting or updating new or existing contacts.</p> <p>This library provides several insert and update APIs that support custom data integration.</p> <ol> <li><code>Insert</code><ul> <li>Insert contacts</li> </ul> </li> <li><code>ProfileInsert</code><ul> <li>Insert device owner Contact profile</li> </ul> </li> <li><code>Update</code><ul> <li>Update contacts 4<code>ProfileUpdate</code></li> <li>Update device owner Contact profile</li> </ul> </li> </ol> <p>To help illustrate how custom data integrates with these query APIs, we'll use the <code>HandleName</code> and <code>Gender</code> custom data.</p> <p>\u2139\ufe0f For more info, read Integrate the gender custom data and Integrate the handle name custom data.</p>"},{"location":"customdata/insert-custom-data/#creatinginserting-custom-data-into-a-rawcontact","title":"Creating/inserting custom data into a RawContact","text":"<p>Custom data, just like regular data kinds, are attached to a RawContact. They follow the same rules as regular data kinds.</p> <p>\u2139\ufe0f For more info, read about API Entities.</p> <p>For example, you are able to add handle names and set gender of a new RawContact,</p> <pre><code>newRawContact.addHandleName(contactsApi) {\n   handle = \"dude91\"\n}\nnewRawContact.setGender(contactsApi) {\n   type = GenderEntity.Type.MALE\n}\n</code></pre> <p>Once you have created/insert the custom data into the RawContact, you can perform the insert  operation on the new RawContact to commit your changes into the database.</p> <p>For more info, read Insert data into new or existing contacts.</p>"},{"location":"customdata/insert-custom-data/#the-include-function-and-custom-data","title":"The <code>include</code> function and custom data","text":"<p>All of the above mentioned APIs provide an <code>include</code> function that allows you to include only a  given set of fields (data) to be processed in the insert operation. Custom data entries provides  fields that can be used in this function.</p> <p>By default, not calling the <code>include</code> function will include all fields, including custom data fields.</p> <p>For example, to specifically include only <code>HandleName</code> and <code>Gender</code> fields,</p> <pre><code>.include(HandleNameFields.all + GenderFields.all)\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"customdata/insert-custom-data/#blank-data-are-not-inserted","title":"Blank data are not inserted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are ignored and are not inserted by insert APIs.</p> <p>For more info, read about Blank data.</p>"},{"location":"customdata/integrate-custom-data-from-other-apps/","title":"Integrate custom data from other apps","text":"<p>If you are looking to create and integrate your own custom data, read Integrate custom data.</p> <p>If you are looking to integrate custom data from other apps, you are in the right place!</p> <p>There are a lot of other apps out there that provide their own custom data, such as  Google Contacts and WhatsApp. </p> <p>There are two parts to \"integrating custom data\";</p> <ol> <li>Providing create (insert), read (query), update, and delete (CRUD) APIs for custom data    associated with RawContacts.</li> <li>Providing sync adapters to sync custom data across devices.</li> </ol> <p>This library only handles the first part. Other (third party) apps typically provide sync adapters  to sync their custom data across devices. This library does not interfere with any syncing  functionality of custom data from other apps. What this library does is allow you and others to  easily read and write custom data from other apps in your own apps.</p>"},{"location":"customdata/integrate-custom-data-from-other-apps/#research-what-custom-data-the-third-party-apps-are-adding-if-any","title":"Research what custom data the third party app's are adding, if any","text":"<p>The hardest part will be researching what custom data a particular third party app provides, what  they are used for, and how they behave. Here are some things you can do to find the answers.</p> <ol> <li>Install and log into the app you are interested in researching. Then, use the <code>debug</code> module     functions in your app to log the Data table via <code>Context.logDataTable()</code>. Look for any mime types    that look like like they belong to the app. Figure out how where in the app's UI the data is    shown and/or how the app uses it in general.</li> <li>Deconstruct the APK and look for <code>res/xml/contacts.xml</code> and other places in code where custom     data may reside. A good place to look will be in sync adapter related classes.</li> <li>Search the internet for any official documentation on the custom data added by the app. There is    a high chance that this does not exist.</li> <li>Search the internet for other people's research on the app's custom data, if any.</li> </ol> <p>The first strategy is the most effective strategy to take because you are able to experience  first-hand and play around with the custom data and document everything about it. Nothing beats  first-hand research!</p> <p>The second strategy is a bit more hacky and advanced and time consuming but it could pay off.</p> <p>The third strategy is optimistic but could end up being the most useful if you are able to locate official documentation from the app developers themselves.</p> <p>The fourth strategy could be unreliable as it depends on other people's knowledge, which could be inaccurate. </p>"},{"location":"customdata/integrate-custom-data-from-other-apps/#integrate-the-third-party-app-custom-data-with-this-library","title":"Integrate the third party app custom data with this library","text":"<p>Once you have figured out all of the details of all of the custom data (mimetypes) that the third party app adds, you may proceed to write the code that will allow you and others to perform read and write operations on it using the CRUD APIs provided in this library.</p> <p>To proceed, read Integrate custom data.</p>"},{"location":"customdata/integrate-custom-data-from-other-apps/#example-google-contacts-app-custom-data","title":"Example, Google Contacts app custom data","text":"<p>Issue #165: Google Contacts app custom data integrates custom data from the Google Contacts app into this library. You may use it as an example on how to get started with the research and also what code to write after the research has been  completed.</p>"},{"location":"customdata/integrate-custom-data-from-other-apps/#consider-adding-your-integration-of-third-party-apps-custom-data-to-this-library","title":"Consider adding your integration of third party apps' custom data to this library","text":"<p>Let's say that you have written the code that integrates custom data from a third party app into  your app using this library. That's great and all but your app will be the only app that will be  able to use it! In the spirit of open source, please feel free to add your third party app custom  data integration into this library so that other people using this library can optionally integrate  it into their own apps! Please create a GitHub issue and file a pull request!</p>"},{"location":"customdata/integrate-custom-data/","title":"Integrate custom data","text":"<p>If you are looking to integrate custom data from other apps,  read Integrate custom data from other apps.</p> <p>If you are looking to create and integrate your own custom data, you are in the right place!</p> <p>There are two parts to \"integrating custom data\";</p> <ol> <li>Providing create (insert), read (query), update, and delete (CRUD) APIs for custom data     associated with RawContacts.</li> <li>Providing sync adapters to sync custom data across devices.</li> </ol> <p>This library only handles the first part. If you want to sync your custom data, then you need to  implement a sync adapter to interface with your remote server. That is out of scope of this library.</p> <p>In order to create and integrate your own custom data for use in your own apps, there is a bit of boilerplate code that needs to be written. Thankfully none of this stuff is difficult! </p> <p>Here are the steps, in chronological order, on how to define and use your own custom data,</p> <ol> <li>Define the mimetype</li> <li>Define the entities</li> <li>Define the fields</li> <li>Implement the cursor</li> <li>Implement the mapper</li> <li>Implement the operation</li> <li>Define the count restriction</li> <li>Define RawContact getters and setters</li> <li>Define Contact getters and setters</li> <li>Define exceptions</li> <li>Implement the field mapper</li> <li>Define the data query function</li> <li>Define the custom data entry</li> <li>Define the custom data entry registration</li> <li>Register your custom data with the Contacts API instance</li> <li>Use your custom data in queries, inserts, updates, and deletes</li> </ol> <p>\u2139\ufe0f Maybe someday someone with code generation experience (or I'll learn how to do it), will create annotations and annotation processors to eliminate having to manually write this stuff =)</p> <p>To help illustrate the above steps, we'll use the <code>HandleName</code> and <code>Gender</code> custom data provided in this library's <code>customdata-handlename</code> and <code>customdata-gender</code> respectively as an example.</p> <p>\u2139\ufe0f For more specifics on these custom data, read Integrate the gender custom data and Integrate the handle name custom data.</p> <p>At the bottom of this page, we'll also discuss,</p> <ul> <li>Consider adding your custom data to this library</li> <li>Custom data without sync adapters will not be synced</li> <li>Displaying your custom data in other Contacts apps</li> <li>Summary of limitations</li> </ul> <p>\u2139\ufe0f Some of the code used in these examples are in Kotlin. If you would like a Java version of this page, create an issue in GitHub. You are also free to file a pull request with your own page. In the event that a Java version of this page is created, this quote block should be replaced with a link to that page.</p>"},{"location":"customdata/integrate-custom-data/#1-define-the-mimetype","title":"1. Define the mimetype","text":"<p>The mimetype is a string that describes what kind of data a row in the Data table represents.</p> <p>For <code>Gender</code>,</p> <pre><code>internal object GenderMimeType : MimeType.Custom() {\n\n    // Following Contacts Provider convention of \"vnd.android.cursor.item/&lt;package&gt;.&lt;mimetype&gt;\"\n    override val value: String = \"vnd.android.cursor.item/contacts.entities.custom.gender\"\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>internal object HandleNameMimeType : MimeType.Custom() {\n\n    // Following Contacts Provider convention of \"vnd.android.cursor.item/&lt;package&gt;.&lt;mimetype&gt;\"\n    override val value: String = \"vnd.android.cursor.item/contacts.entities.custom.handlename\"\n}\n</code></pre> <p>Do not change the mimetype value! If you have already deployed apps to production that use these mimetype values, then changing them could result in \"data loss\". Old rows in the Data table will not be compatible if the mimetype value changes. You can certainly perform migrations by creating a new custom data altogether and migrating your old custom data to your new one.</p> <p>Do not use built-in mimetypes! The Contacts Provider has predefined the mimetypes for all of the common data kinds it supports (e.g. email). Make sure that your custom data does not use any of those. You can take a look at built-in mimetypes in <code>contacs.core.entities.MimeType.kt</code>. But, here they are for your convenience =)</p> Builtin data kind mimetype Address \"vnd.android.cursor.item/postal-address_v2\" Email \"vnd.android.cursor.item/email_v2\" Event \"vnd.android.cursor.item/contact_event\" GroupMembership \"vnd.android.cursor.item/group_membership\" Im \"vnd.android.cursor.item/im\" Name \"vnd.android.cursor.item/name\" Nickname \"vnd.android.cursor.item/nickname\" Note \"vnd.android.cursor.item/note\" Organization \"vnd.android.cursor.item/organization\" Phone \"vnd.android.cursor.item/phone_v2\" Photo \"vnd.android.cursor.item/photo\" Relation \"vnd.android.cursor.item/relation\" SipAddress \"vnd.android.cursor.item/sip_address\" Website \"vnd.android.cursor.item/website\""},{"location":"customdata/integrate-custom-data/#2-define-the-entities","title":"2. Define the entities","text":"<p>The entities are the main code that users of your custom data will be exposed to. The properties model/represent the fields/columns in the Data table.</p> <p>Due to the length of the <code>Gender.kt</code> and <code>HandleName.kt</code> files, I will not be copy-pasting them here. Please take a look at those files instead.</p> <p>A few things to note,</p> <ul> <li>Either inherit from <code>CustomDataEntity</code> or <code>CustomDataEntityWithTypeAndLabel</code>.</li> <li>Implement the <code>mimeType</code> using the mimetype you defined in the previous step.</li> <li>Implement the <code>isBlank</code> using the <code>contacts.core.entities.propertiesAreAllNullOrBlank</code> function.<ul> <li>Put the properties that you consider to be important such that if they are null, then the data   is useless (blank).</li> </ul> </li> <li>Define an immutable class so that instances can be returned on queries.<ul> <li>These would also need to inherit from <code>ExistingCustomDataEntity</code> and   <code>ImmutableCustomDataEntityWithMutableType</code> (or   <code>ImmutableCustomDataEntityWithNullableMutableType</code>).</li> <li>All properties and types defined here must be immutable (<code>val</code>).</li> </ul> </li> <li>Define a mutable class so that instances can be updated.<ul> <li>These would also need to inherit from <code>ExistingCustomDataEntity</code>.</li> <li>Only modifiable fields should have properties and types defined as mutable (<code>var</code>).</li> </ul> </li> <li>Define a \"new\" class so that instances can be inserted.<ul> <li>These would also need to inherit from <code>NewCustomDataEntity</code>.</li> <li>Only modifiable fields should have properties and types defined as mutable (<code>var</code>).</li> </ul> </li> <li>Properties that map to your custom data fields should be nullable (<code>?</code>).</li> <li>The following properties should always be immutable (<code>val</code>);<ul> <li><code>id</code>, <code>rawContactId</code>, <code>contactId</code>, <code>isPrimary</code>, <code>isSuperPrimary</code>, and <code>isRedacted</code>.</li> </ul> </li> <li>Be mindful of what properties should be redacted when implementing the <code>redactedCopy</code> function.</li> <li>All entity class must implement <code>Parecelable</code>.</li> </ul>"},{"location":"customdata/integrate-custom-data/#3-define-the-fields","title":"3. Define the fields","text":"<p>Fields (or columns) represent (or map to) one of the properties you defined in the previous step. These are used in queries, inserts, and update operations.</p> <p>For <code>Gender</code>,</p> <pre><code>data class GenderField internal constructor(private val columnName: ColumnName) :\n    AbstractCustomDataField(columnName) {\n\n    override val customMimeType: MimeType.Custom = GenderMimeType\n}\n\nobject GenderFields : AbstractCustomDataFieldSet&lt;GenderField&gt;() {\n\n    @JvmField\n    val Type = GenderField(ColumnName.TYPE)\n\n    @JvmField\n    val Label = GenderField(ColumnName.LABEL)\n\n    override val all: Set&lt;GenderField&gt; = setOf(Type, Label)\n    override val forMatching: Set&lt;GenderField&gt; = emptySet()\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>data class HandleNameField internal constructor(private val columnName: ColumnName) :\n    AbstractCustomDataField(columnName) {\n\n    override val customMimeType: MimeType.Custom = HandleNameMimeType\n}\n\nobject HandleNameFields : AbstractCustomDataFieldSet&lt;HandleNameField&gt;() {\n\n    @JvmField\n    val Handle = HandleNameField(ColumnName.DATA)\n\n    override val all: Set&lt;HandleNameField&gt; = setOf(Handle)\n    override val forMatching: Set&lt;HandleNameField&gt; = setOf(Handle)\n}\n</code></pre> <p>A few things to note,</p> <ul> <li>You need to define a <code>AbstractCustomDataField</code> and a <code>AbstractCustomDataFieldSet</code>.</li> <li>Annotate your field instances with <code>@JvmField</code> to make it more accessible for Java users.<ul> <li>This is only helpful if you are writing code for other people to use.</li> </ul> </li> <li>Carefully choose what to put in <code>all</code> and <code>forMatching</code>.<ul> <li>If you are using <code>ColumnName.BLOB</code>, do not put it in <code>all</code> or <code>forMatching</code>! For more info,   read the in-code documentation on it.</li> </ul> </li> </ul>"},{"location":"customdata/integrate-custom-data/#4-implement-the-cursor","title":"4. Implement the cursor","text":"<p>Cursors read the values from the Data table and convert them into the types you want (e.g. String).</p> <p>For <code>Gender</code>,</p> <pre><code>internal class GenderDataCursor(cursor: Cursor, includeFields: Set&lt;GenderField&gt;?) :\n    AbstractCustomDataCursor&lt;GenderField&gt;(cursor, includeFields) {\n\n    val type: GenderEntity.Type? by type(\n        GenderFields.Type,\n        typeFromValue = GenderEntity.Type::fromValue\n    )\n\n    val label: String? by string(GenderFields.Label)\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>internal class HandleNameDataCursor(cursor: Cursor, includeFields: Set&lt;HandleNameField&gt;?) :\n    AbstractCustomDataCursor&lt;HandleNameField&gt;(cursor, includeFields) {\n\n    val handle: String? by string(HandleNameFields.Handle)\n}\n</code></pre> <p>A few things to note,</p> <ul> <li>Inheritors of <code>AbstractCustomDataCursor</code> have access to several regular and delegate functions   that extract data. All of them are defined in <code>contacts.core.entities.cursor.AbstractEntityCursor</code>   .</li> <li>If you are using Java, you are only able to use the regular functions.</li> <li>The delegate functions are prettier but use Kotlin reflection, which could slightly affect runtime   performance.</li> <li>You can either extract nullable or non-nullable values using these functions.</li> </ul>"},{"location":"customdata/integrate-custom-data/#5-implement-the-mapper","title":"5. Implement the mapper","text":"<p>Mappers use the cursors implemented in the previous step in order to create instances of your custom data entities.</p> <p>For <code>Gender</code>,</p> <pre><code>internal class GenderMapperFactory :\n    AbstractCustomDataEntityMapper.Factory&lt;GenderField, GenderDataCursor, Gender&gt; {\n\n    override fun create(\n        cursor: Cursor, includeFields: Set&lt;GenderField&gt;?\n    ): AbstractCustomDataEntityMapper&lt;GenderField, GenderDataCursor, Gender&gt; =\n        GenderMapper(GenderDataCursor(cursor, includeFields))\n}\n\nprivate class GenderMapper(cursor: GenderDataCursor) :\n    AbstractCustomDataEntityMapper&lt;GenderField, GenderDataCursor, Gender&gt;(cursor) {\n\n    override fun value(cursor: GenderDataCursor) = Gender(\n        id = cursor.dataId,\n        rawContactId = cursor.rawContactId,\n        contactId = cursor.contactId,\n\n        isPrimary = cursor.isPrimary,\n        isSuperPrimary = cursor.isSuperPrimary,\n\n        type = cursor.type,\n        label = cursor.label,\n\n        isRedacted = false\n    )\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>internal class HandleNameMapperFactory :\n    AbstractCustomDataEntityMapper.Factory&lt;HandleNameField, HandleNameDataCursor, HandleName&gt; {\n\n    override fun create(\n        cursor: Cursor, includeFields: Set&lt;HandleNameField&gt;?\n    ): AbstractCustomDataEntityMapper&lt;HandleNameField, HandleNameDataCursor, HandleName&gt; =\n        HandleNameMapper(HandleNameDataCursor(cursor, includeFields))\n}\n\nprivate class HandleNameMapper(cursor: HandleNameDataCursor) :\n    AbstractCustomDataEntityMapper&lt;HandleNameField, HandleNameDataCursor, HandleName&gt;(cursor) {\n\n    override fun value(cursor: HandleNameDataCursor) = HandleName(\n        id = cursor.dataId,\n        rawContactId = cursor.rawContactId,\n        contactId = cursor.contactId,\n\n        isPrimary = cursor.isPrimary,\n        isSuperPrimary = cursor.isSuperPrimary,\n\n        handle = cursor.handle,\n\n        isRedacted = false\n    )\n}\n</code></pre> <p>A few things to note,</p> <ul> <li>This requires definitions and implementations done in the previous steps.<ul> <li>If you are having compile-time issues at this point, make sure that you did not skip a step!</li> </ul> </li> <li>Ensure that <code>isRedacted</code> is set to <code>false</code> (unless you are already performing the redaction) here.</li> </ul>"},{"location":"customdata/integrate-custom-data/#6-implement-the-operation","title":"6. Implement the operation","text":"<p>Operations are used for inserts and updates from in-memory instances of your entities to the database.</p> <p>For <code>Gender</code>,</p> <pre><code>internal class GenderOperationFactory :\n    AbstractCustomDataOperation.Factory&lt;GenderField, GenderEntity&gt; {\n\n    override fun create(\n        callerIsSyncAdapter: Boolean,\n        isProfile: Boolean,\n        includeFields: Set&lt;GenderField&gt;?\n    ): AbstractCustomDataOperation&lt;GenderField, GenderEntity&gt; = GenderOperation(\n        callerIsSyncAdapter = callerIsSyncAdapter,\n        isProfile = isProfile,\n        includeFields = includeFields\n    )\n}\n\nprivate class GenderOperation(\n    callerIsSyncAdapter: Boolean,\n    isProfile: Boolean,\n    includeFields: Set&lt;GenderField&gt;?\n) : AbstractCustomDataOperation&lt;GenderField, GenderEntity&gt;(\n    callerIsSyncAdapter = callerIsSyncAdapter,\n    isProfile = isProfile,\n    includeFields = includeFields\n) {\n\n    override val mimeType: MimeType.Custom = GenderMimeType\n\n    override fun setCustomData(\n        data: GenderEntity, setValue: (field: GenderField, value: Any?) -&gt; Unit\n    ) {\n        setValue(GenderFields.Type, data.type?.value)\n        setValue(GenderFields.Label, data.label)\n    }\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>internal class HandleNameOperationFactory :\n    AbstractCustomDataOperation.Factory&lt;HandleNameField, HandleNameEntity&gt; {\n\n    override fun create(\n        callerIsSyncAdapter: Boolean, isProfile: Boolean, includeFields: Set&lt;HandleNameField&gt;?\n    ): AbstractCustomDataOperation&lt;HandleNameField, HandleNameEntity&gt; = HandleNameOperation(\n        callerIsSyncAdapter = callerIsSyncAdapter,\n        isProfile = isProfile,\n        includeFields = includeFields\n    )\n}\n\nprivate class HandleNameOperation(\n    callerIsSyncAdapter: Boolean,\n    isProfile: Boolean,\n    includeFields: Set&lt;HandleNameField&gt;?\n) : AbstractCustomDataOperation&lt;HandleNameField, HandleNameEntity&gt;(\n    callerIsSyncAdapter = callerIsSyncAdapter,\n    isProfile = isProfile,\n    includeFields = includeFields\n) {\n\n    override val mimeType: MimeType.Custom = HandleNameMimeType\n\n    override fun setCustomData(\n        data: HandleNameEntity, setValue: (field: HandleNameField, value: Any?) -&gt; Unit\n    ) {\n        setValue(HandleNameFields.Handle, data.handle)\n    }\n}\n</code></pre> <p>A few things to note,</p> <ul> <li>You just need to use your custom data fields and the corresponding data property it maps to in   the <code>setValue</code> function provided in the <code>setCustomData</code> function.</li> </ul>"},{"location":"customdata/integrate-custom-data/#7-define-the-count-restriction","title":"7. Define the count restriction","text":"<p>The count restriction defines whether a RawContact can have 0 or 1 of your custom data or if it can have 0, 1, or more.</p> <p>For <code>Gender</code>,</p> <pre><code>/**\n * A RawContact may have at most 1 gender.\n */\ninternal val GENDER_COUNT_RESTRICTION = CustomDataCountRestriction.AT_MOST_ONE\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>/**\n * A RawContact may have 0, 1, or more handle names.\n */\ninternal val HANDLE_NAME_COUNT_RESTRICTION = CustomDataCountRestriction.NO_LIMIT\n</code></pre>"},{"location":"customdata/integrate-custom-data/#8-define-rawcontact-getters-and-setters","title":"8. Define RawContact getters and setters","text":"<p>In order for you or your consumers to be able to get and set your custom data in instances of RawContacts they belong to, you must define a set of getters and setters.</p> <p>Due to the length of the <code>RawContactGender.kt</code> and <code>RawContactHandleName.kt</code> files, I will not be copy-pasting them here. Please take a look at those files instead.</p> <p>A few things to note,</p> <ul> <li>For getters, use the <code>Contacts.customDataRegistry.customDataEntitiesFor</code> function to extract the   custom data instance(s) for the RawContact with your custom mimetype.<ul> <li>Consider returning <code>Sequence</code> for the getters for optimizations in Kotlin.</li> </ul> </li> <li>For setters use,<ul> <li>the <code>Contacts.customDataRegistry.putCustomDataEntityInto</code> function to set the custom data   instance into the RawContact.</li> <li>the <code>Contacts.customDataRegistry.removeAllCustomDataEntityFrom</code> function to remove the custom   data instance from the RawContact.</li> </ul> </li> <li>Define getters and setters for <code>RawContact</code>, <code>MutableRawContact</code>, and <code>NewRawContact</code>.<ul> <li>Ensure to match the type of RawContact with the type of the custom data. For example,<ul> <li><code>RawContact</code> -&gt; <code>Gender</code>, <code>HandleName</code></li> <li><code>MutableRawContact</code> -&gt; <code>MutableGenderEntity</code>, <code>MutableHandleNameEntity</code><ul> <li>When setting/adding a new custom data entity,   <code>MutableRawContact</code> -&gt; <code>NewGender</code>, <code>NewHandleName</code></li> </ul> </li> <li><code>NewRawContact</code> -&gt; <code>NewGender</code>, <code>NewHandleName</code></li> </ul> </li> </ul> </li> <li>Setters for custom data with count restriction of <code>AT_MOST_ONE</code> should use <code>setXXX</code> for the    function name.</li> <li>Setters for custom data with count restriction of <code>NO_LIMIT</code> should use <code>addXXX</code> and <code>removeXXX</code>    for the function names.</li> </ul>"},{"location":"customdata/integrate-custom-data/#9-define-contact-getters-and-setters","title":"9. Define Contact getters and setters","text":"<p>Defining getters and setters for RawContacts is the bare minimum. However, if you want to add some convenience functions so that you can access RawContact getters and setters from a Contact, then you are free (and recommended) to do so.</p> <p>Due to the length of the <code>ContactGender.kt</code> and <code>ContactHandleName.kt</code> files, I will not be copy-pasting them here. Please take a look at those files instead.</p> <p>A few things to note,</p> <ul> <li>For getters, consider returning <code>Sequence</code> for optimizations in Kotlin.</li> <li>For setters, use the first RawContact (in case there are more than one).</li> <li>Consider returning <code>Sequence</code> for the getters for optimizations in Kotlin.</li> <li>Define getters and setters for <code>Contact</code> and <code>MutableContact</code>.<ul> <li>Ensure to match the type of Contact with the type of the custom data. For example,<ul> <li><code>Contact</code> -&gt; <code>Gender</code>, <code>HandleName</code></li> <li><code>MutableContact</code> -&gt; <code>MutableGenderEntity</code>, <code>MutableHandleNameEntity</code><ul> <li>When setting/adding a new custom data entity,   <code>MutableContact</code> -&gt; <code>NewGender</code>, <code>NewHandleName</code></li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"customdata/integrate-custom-data/#10-define-exceptions","title":"10. Define exceptions","text":"<p>Whether you are building this custom data just for your own app or for others to use, it is useful to define a subclass of <code>CustomDataException</code> to help identify errors in certain custom data integrations.</p> <p>For <code>Gender</code>,</p> <pre><code>class GenderDataException(message: String) : CustomDataException(message)\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>class HandleNameDataException(message: String) : CustomDataException(message)\n</code></pre>"},{"location":"customdata/integrate-custom-data/#11-implement-the-field-mapper","title":"11. Implement the field mapper","text":"<p>A field mapper maps your custom data field to the corresponding property in your custom data entity.</p> <p>For <code>Gender</code>,</p> <pre><code>internal class GenderFieldMapper : CustomDataFieldMapper&lt;GenderField, GenderEntity&gt; {\n\n    override fun valueOf(field: GenderField, customDataEntity: GenderEntity): String? =\n        when (field) {\n            GenderFields.Type -&gt; customDataEntity.type?.ordinal?.toString()\n            GenderFields.Label -&gt; customDataEntity.label\n            else -&gt; throw GenderDataException(\"Unrecognized gender field $field\")\n        }\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>internal class HandleNameFieldMapper : CustomDataFieldMapper&lt;HandleNameField, HandleNameEntity&gt; {\n\n    override fun valueOf(field: HandleNameField, customDataEntity: HandleNameEntity): String? =\n        when (field) {\n            HandleNameFields.Handle -&gt; customDataEntity.handle\n            else -&gt; throw HandleNameDataException(\"Unrecognized handle name field $field\")\n        }\n}\n</code></pre> <p>A few things to note,</p> <ul> <li>You should throw an instance of your custom data exception in the case that there is no mapping   from a field to a property. This ensures that your custom data integration will fail and fail-fast   in case you forget to add a mapping to a property.</li> </ul>"},{"location":"customdata/integrate-custom-data/#12-define-the-data-query-function","title":"12. Define the data query function","text":"<p>These (extension) functions on the <code>DataQueryFactory</code> allows you and your consumers to use the <code>DataQuery</code> API to specifically query for only your custom data kind instead of Contacts.</p> <p>For <code>Gender</code>,</p> <pre><code>fun DataQueryFactory.genders(): DataQuery&lt;GenderField, GenderFields, Gender&gt; =\n    customData(GenderMimeType)\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>fun DataQueryFactory.handleNames(): DataQuery&lt;HandleNameField, HandleNameFields, HandleName&gt; =\n    customData(HandleNameMimeType)\n</code></pre> <p>For more info on the <code>DataQuery</code> API, read Query specific data kinds and Query custom data.</p>"},{"location":"customdata/integrate-custom-data/#13-define-the-custom-data-entry","title":"13. Define the custom data entry","text":"<p>The entry puts everything together so that it can be handed off to the custom data registry to integrate your custom data with all of the APIs provided in the library.</p> <p>For <code>Gender</code>,</p> <pre><code>internal class GenderEntry : Entry&lt;GenderField, GenderDataCursor, GenderEntity, Gender&gt; {\n    override val mimeType = GenderMimeType\n    override val fieldSet = GenderFields\n    override val fieldMapper = GenderFieldMapper()\n    override val countRestriction = GENDER_COUNT_RESTRICTION\n    override val mapperFactory = GenderMapperFactory()\n    override val operationFactory = GenderOperationFactory()\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>internal class HandleNameEntry : Entry&lt;HandleNameField, HandleNameDataCursor, HandleNameEntity, HandleName&gt; {\n    override val mimeType = HandleNameMimeType\n    override val fieldSet = HandleNameFields\n    override val fieldMapper = HandleNameFieldMapper()\n    override val countRestriction = HANDLE_NAME_COUNT_RESTRICTION\n    override val mapperFactory = HandleNameMapperFactory()\n    override val operationFactory = HandleNameOperationFactory()\n}\n</code></pre>"},{"location":"customdata/integrate-custom-data/#14-define-the-custom-data-entry-registration","title":"14. Define the custom data entry registration","text":"<p>The entry registration provides a way for you to keep your Entry <code>internal</code> to your library module.</p> <p>\u2139\ufe0f In Java, the closest thing to this is package-private.</p> <p>This is not necessary to implement. Feel free to make your <code>Entry</code> public so that it can be handed off to the custom data registry. </p> <p>For <code>Gender</code>,</p> <pre><code>class GenderRegistration : CustomDataRegistry.EntryRegistration {\n    override fun registerTo(customDataRegistry: CustomDataRegistry) {\n        customDataRegistry.register(GenderEntry())\n    }\n}\n</code></pre> <p>For <code>HandleName</code>,</p> <pre><code>class HandleNameRegistration : CustomDataRegistry.EntryRegistration {\n    override fun registerTo(customDataRegistry: CustomDataRegistry) {\n        customDataRegistry.register(HandleNameEntry())\n    }\n}\n</code></pre>"},{"location":"customdata/integrate-custom-data/#15-register-your-custom-data-with-the-contacts-api-instance","title":"15. Register your custom data with the Contacts API instance","text":"<p>There are two ways to register your custom data. Either using the entry registration defined in the previous step or the entry itself defined in the step prior.</p> <p>Using <code>Gender</code> and <code>HandleName</code> entry registration,</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        GenderRegistration(),\n        HandleNameRegistration()\n    )\n)\n</code></pre> <p>Alternatively,</p> <pre><code>val contactsApi = Contacts(context)\nGenderRegistration().registerTo(contactsApi.customDataRegistry)\nHandleNameRegistration().registerTo(contactsApi.customDataRegistry)\n</code></pre> <p>Using <code>Gender</code> and <code>HandleName</code> entry,</p> <p>\u2139\ufe0f This is not possible with <code>Gender</code> and <code>HandleName</code> as their entries are internal. This is for  demonstration purposes only.</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        GenderEntry(),\n        HandleNameEntry()\n    )\n)\n</code></pre>"},{"location":"customdata/integrate-custom-data/#16-use-your-custom-data-in-queries-inserts-updates-and-deletes","title":"16. Use your custom data in queries, inserts, updates, and deletes","text":"<p>Once you have registered your custom data with the <code>Contacts</code> API instance, the API instance is now able to perform read and write operations on it.</p> <ul> <li>Query custom data</li> <li>Insert custom data into new or existing contacts</li> <li>Update custom data</li> <li>Delete custom data</li> </ul>"},{"location":"customdata/integrate-custom-data/#consider-adding-your-custom-data-to-this-library","title":"Consider adding your custom data to this library","text":"<p>Let's say that you have created your own custom data in your own app. That's great and all but your app will be the only app that will be able to perform operations on it (unless the mimetype value you are using is also used by others). This is definitely something you want to do if you don't really want others to mess with your custom data (though you can't really stop others).</p> <p>If you want to add your custom data to this library so that other people using this library can optionally integrate it into their own apps, please create a GitHub issue and file a pull request!</p>"},{"location":"customdata/integrate-custom-data/#custom-data-without-sync-adapters-will-not-be-synced","title":"Custom data without sync adapters will not be synced","text":"<p>Custom data provided by this library such as those in those in the <code>customdata-gender</code>, <code>customdata-handlename</code>, <code>customdata-pokemon</code>, and <code>customdata-rpg</code> modules are not synced because  there are no sync adapters and a remote service to store those data. Therefore, they are not synced  across devices and will remain local to the device regardless of Account sync settings. It is up to you to implement your own sync adapters for your own custom data. </p> <p>For more info, read Sync contact data across devices.</p>"},{"location":"customdata/integrate-custom-data/#displaying-your-custom-data-in-other-contacts-apps","title":"Displaying your custom data in other Contacts apps","text":"<p>If you want your custom data to be visible in the Android Open Source Project (AOSP) Contacts app  (the default Contacts app that comes with a vanilla version of Android) and the  Google Contacts app, then read this section. This is optional. If you only want your custom data to be visible in your application, then you should NOT do the things described in this part of the guide.</p> <p>\u2139\ufe0f The Google Contacts app keeps its \"File as\" custom data invisible to other  Contacts apps such as the AOSP Contacts app. However, it exposes the \"Custom field+label\" custom  data by doing the things described in this section.</p> <p>Important! The first criteria for being able to show your custom data in the Contacts app is to define and implement your own sync adapter. If you do not have a sync adapter implementation, your custom data will not be shown in the Contacts app! Again, this library does not provide any sync adapters. That is for you to implement based on your account services. This library provides you and users of your library an easy, uniform way to perform read and write operations on your custom data. The act of syncing is up to you.</p> <p>The official documentation on custom data rows is as follows,</p> <p>By creating and using your own custom MIME types, you can insert, edit, delete, and retrieve your  own data rows in the <code>ContactsContract.Data</code> table. Your rows are limited to using the column  defined in <code>ContactsContract.DataColumns</code>, although you can map your own type-specific column  names to the default column names. In the device's contacts application, the data for your rows  is displayed but can't be edited or deleted, and users can't add additional data. To allow users  to modify your custom data rows, you must provide an editor activity in your own application.</p> <p>To display your custom data, provide a <code>contacts.xml</code> file containing a <code>&lt;ContactsAccountType&gt;</code>  element and one or more of its <code>&lt;ContactsDataKind&gt;</code> child elements. This is described in more  detail in the section <code>&lt;ContactsDataKind&gt;</code> element.</p> <p>Let's break down the official documentation.</p> <ul> <li>Contacts applications such as the Android Open Source Project (AOSP) Contacts app (the default    Contacts app that comes with a vanilla version of Android) and the Google Contacts app    (and other Contacts app that support this feature) shows custom data from other apps when viewing    contact details. </li> <li>Custom data from other apps are viewable but not editable in order to preserve and respect the    rules surrounding those custom data managed by other apps. </li> </ul> <p>This library allows you to read (query) and write (insert, update, delete) custom data from other  apps. It is up to you whether you want to follow the same limitations imposed by the AOSP and  Google Contacts app.</p> <p>In order to show your custom data in the AOSP Contacts app and Google Contacts app (and other  Contacts app that support this feature), you must add an xml file in your app; <code>res/xml/contacts.xml</code>. The <code>res/xml/contacts.xml</code> template looks  like this,</p> <pre><code>&lt;ContactsAccountType\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        inviteContactActivity=\"activity_name\"\n        inviteContactActionLabel=\"invite_command_text\"\n        viewContactNotifyService=\"view_notify_service\"\n        viewGroupActivity=\"group_view_activity\"\n        viewGroupActionLabel=\"group_action_text\"\n        viewStreamItemActivity=\"viewstream_activity_name\"\n        viewStreamItemPhotoActivity=\"viewphotostream_activity_name\"&gt;\n    &lt;ContactsDataKind\n        android:mimeType=\"MIMEtype\"\n        android:icon=\"icon_resources\"\n        android:summaryColumn=\"column_name\"\n        android:detailColumn=\"column_name\" /&gt;\n&lt;/ContactsAccountType&gt;\n</code></pre> <p>The full official documentation for each of those tags and attributes within each tag are available by clicking this link. </p> <p>For example, the bare-minimum <code>contacts.xml</code> for showing <code>Gender</code> and <code>HandleName</code> custom data in the AOSP and Google Contacts app is the following,</p> <pre><code>&lt;ContactsAccountType xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;!-- Gender --&gt;\n    &lt;ContactsDataKind\n        android:mimeType=\"vnd.android.cursor.item/contacts.entities.custom.gender\"\n        android:summaryColumn=\"data2\"\n        android:detailColumn=\"data3\" /&gt;\n\n    &lt;!-- HandleName --&gt;\n    &lt;ContactsDataKind\n        android:mimeType=\"vnd.android.cursor.item/contacts.entities.custom.handlename\"\n        android:summaryColumn=\"data1\" /&gt;\n\n&lt;/ContactsAccountType&gt;\n</code></pre> <p>A few things to note,</p> <ul> <li>The value of <code>android:mimeType</code> corresponds to the String value defined in <code>GenderMimeType</code> and   <code>HandleNameMimeType</code> as seen in the previous sections of this guide.</li> <li>The value of <code>android:summaryColumn</code> and <code>android:detailColumn</code> corresponds to the    values defined in <code>contacts.core.Fields.kt#AbstractCustomDataField.ColumnName</code> that are used by   <code>GenderFields</code> and <code>HandleNameFields</code>.<ul> <li>These values, as raw strings, are; <code>data1</code>, <code>data2</code>, <code>data3</code>,...<code>data15</code></li> </ul> </li> </ul> <p>Again, in order for your custom data to be shown in the Contacts app, you must also provide a sync adapter implementation. For more info, read Sync contact data across devices.</p>"},{"location":"customdata/integrate-custom-data/#summary-of-limitations","title":"Summary of limitations","text":"<p>To reiterate, this library does not provide a remote server or sync adapters to interface with that server. This library provides create (insert), read (query), update, and delete (CRUD) APIs for pretty, type-safe, and well-documented read and write operations on all data kinds, including custom data. </p> <p>This means that if you do not implement your own sync adapter for your custom data, then your  custom data...</p> <ul> <li>will NOT be synced across devices</li> <li>will NOT be shown in AOSP and Google Contacts apps, and other Contacts apps   that show custom data from other apps</li> </ul> <p>You may still do creative things with custom data without sync adapters as long as you understand these limitations.</p> <p>This library provides CRUD API integration with custom data with no sync adapters;</p> <ul> <li><code>customdata-gender</code></li> <li><code>customdata-handlename</code></li> <li><code>customdata-pokemon</code></li> <li><code>customdata-rpg</code></li> </ul> <p>Also provided are CRUD API integration with custom data from other apps that do have sync adapters;</p> <ul> <li><code>customdata-googlecontacts</code></li> </ul> <p>\u2139\ufe0f Please update the above list whenever adding new custom data modules.</p>"},{"location":"customdata/integrate-gender-custom-data/","title":"Integrate the gender custom data","text":"<p>This library provides extensions for <code>Gender</code> custom data that allows you to read and write gender  data for all of your contacts. These (optional) extensions live in the <code>customdata-gender</code> module.</p> <p>\u2139\ufe0f If you are looking to create your own custom data or get more insight on how the <code>Gender</code> custom data was built, read Integrate custom data.</p>"},{"location":"customdata/integrate-gender-custom-data/#register-the-gender-custom-data-with-the-contacts-api-instance","title":"Register the gender custom data with the Contacts API instance","text":"<p>You may register the <code>Gender</code> custom data when creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        GenderRegistration()\n    )\n)\n</code></pre> <p>Or, alternatively after creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(context)\nGenderRegistration().registerTo(contactsApi.customDataRegistry)\n</code></pre>"},{"location":"customdata/integrate-gender-custom-data/#getset-gender-custom-data","title":"Get/set gender custom data","text":"<p>Just like regular data kinds, gender custom data belong to a RawContact. A RawContact may only have 0 or 1 gender.</p> <p>To get the gender of a RawContact,</p> <pre><code>val gender = rawContact.gender(contactsApi)\n</code></pre> <p>To get the genders of all RawContacts belonging to a Contact,</p> <pre><code>val genderSequence = contact.genders(contactsApi)\nval genderList = contact.genderList(contactsApi)\n</code></pre> <p>To set the gender of a (mutable) RawContact,</p> <pre><code>mutableRawContact.setGender(contacts, mutableGender)\n// or\nmutableRawContact.setGender(contacts) {\n    type = GenderEntity.Type.MALE\n}\n</code></pre> <p>To set the gender of the first RawContact in a Contact,</p> <pre><code>mutableContact.setGender(contacts, mutableGender)\n// or\nmutableContact.setGender(contacts) {\n    type = GenderEntity.Type.MALE\n}\n</code></pre>"},{"location":"customdata/integrate-gender-custom-data/#use-the-gender-custom-data-in-queries-inserts-updates-and-deletes","title":"Use the gender custom data in queries, inserts, updates, and deletes","text":"<p>Once you have registered your gender custom data with the <code>Contacts</code> API instance, the API instance  is now able to perform read and write operations on it.</p> <ul> <li>Query custom data</li> <li>Insert custom data into new or existing contacts</li> <li>Update custom data</li> <li>Delete custom data</li> </ul>"},{"location":"customdata/integrate-gender-custom-data/#syncing-gender-custom-data","title":"Syncing gender custom data","text":"<p>This library does not provide sync adapters for gender custom data. Unless you implement your own  sync adapter, gender custom data...</p> <ul> <li>will NOT be synced across devices</li> <li>will NOT be shown in AOSP and Google Contacts apps, and other Contacts apps   that show custom data from other apps</li> </ul> <p>For more info, read Sync contact data across devices.</p>"},{"location":"customdata/integrate-googlecontacts-custom-data/","title":"Integrate the Google Contacts custom data","text":"<p>This library provides extensions for custom data from the Google Contacts app;  <code>FileAs</code> and <code>UserDefined</code>, which allows you to read and write Google Contacts data for all of your  contacts. These (optional) extensions live in the <code>customdata-googlecontacts</code> module.</p> <p>\u2139\ufe0f If you are looking to create your own custom data or get more insight on how the <code>FileAs</code> and  <code>UserDefined</code> custom data was built, read Integrate custom data.</p>"},{"location":"customdata/integrate-googlecontacts-custom-data/#register-the-google-contacts-custom-data-with-the-contacts-api-instance","title":"Register the Google Contacts custom data with the Contacts API instance","text":"<p>You may register all Google Contacts custom data when creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        GoogleContactsRegistration()\n    )\n)\n</code></pre> <p>Or, alternatively after creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(context)\nGoogleContactsRegistration().registerTo(contactsApi.customDataRegistry)\n</code></pre>"},{"location":"customdata/integrate-googlecontacts-custom-data/#readwrite-google-contacts-custom-data","title":"Read/write Google Contacts custom data","text":""},{"location":"customdata/integrate-googlecontacts-custom-data/#getset-fileas","title":"Get/set <code>FileAs</code>","text":"<p>Just like regular data kinds, <code>FileAs</code> custom data belong to a RawContact. A RawContact may only have 0 or 1 <code>FileAs</code>.</p> <p>To get the <code>FileAs</code> of a RawContact,</p> <pre><code>val fileAs = rawContact.fileAs(contactsApi)\n</code></pre> <p>To get the <code>FileAs</code> of all RawContacts belonging to a Contact,</p> <pre><code>val fileAsSequence = contact.fileAs(contactsApi)\nval fileAsList = contact.fileAsList(contactsApi)\n</code></pre> <p>To set the <code>FileAs</code> of a (mutable) RawContact,</p> <pre><code>mutableRawContact.setFileAs(contacts, mutableFileAs)\n// or\nmutableRawContact.setFileAs(contacts) {\n    name = \"Robot\"\n}\n</code></pre> <p>To set the <code>FileAs</code> of the first RawContact in a Contact,</p> <pre><code>mutableContact.setFileAs(contacts, mutableFileAs)\n// or\nmutableContact.setFileAs(contacts) {\n  name = \"Robot\"\n}\n</code></pre>"},{"location":"customdata/integrate-googlecontacts-custom-data/#getaddremove-userdefined","title":"Get/add/remove <code>UserDefined</code>","text":"<p>Just like regular data kinds, <code>UserDefined</code> custom data belong to a RawContact. A RawContact may  have 0, 1, or more <code>UserDefined</code>.</p> <p>To get the <code>UserDefined</code> list/sequence of a RawContact,</p> <pre><code>val userDefinedSequence = rawContact.userDefined(contactsApi)\nval userDefinedList = rawContact.userDefinedList(contactsApi)\n</code></pre> <p>To get the <code>UserDefined</code> of all RawContacts belonging to a Contact,</p> <pre><code>val userDefinedSequence = contact.userDefined(contactsApi)\nval userDefinedList = contact.userDefinedList(contactsApi)\n</code></pre> <p>To add a <code>UserDefined</code> to a (mutable) RawContact,</p> <pre><code>mutableRawContact.addUserDefined(contacts, mutableUserDefined)\n// or\nmutableRawContact.addUserDefined(contacts) {\n    field = \"My Field\"\n    label = \"My Label\"\n}\n</code></pre> <p>To add a <code>UserDefined</code> to the first RawContact in a Contact,</p> <pre><code>mutableContact.addUserDefined(contacts, mutableUserDefined)\n// or\nmutableContact.addUserDefined(contacts) {\n  field = \"My Field\"\n  label = \"My Label\"\n}\n</code></pre>"},{"location":"customdata/integrate-googlecontacts-custom-data/#use-the-google-contacts-custom-data-in-queries-inserts-updates-and-deletes","title":"Use the Google Contacts custom data in queries, inserts, updates, and deletes","text":"<p>Once you have registered the Google Contacts custom data with the <code>Contacts</code> API instance, the API  instance is now able to perform read and write operations on it.</p> <ul> <li>Query custom data</li> <li>Insert custom data into new or existing contacts</li> <li>Update custom data</li> <li>Delete custom data</li> </ul>"},{"location":"customdata/integrate-googlecontacts-custom-data/#google-contacts-app-data-integrity","title":"Google Contacts app data integrity","text":"<p>When inserting or updating a <code>UserDefined</code> data kind, the Google Contacts app enforces  <code>UserDefined.field</code> and <code>UserDefined.label</code> to both be non-null and non-blank. Otherwise, the insert or update operation fails. To protect the data integrity that the Google Contacts app imposes, this  library is silently not performing insert or update operations for these instances. Consumers are  informed via documentation.</p> <p>Both <code>field</code> and <code>label</code> must be non-null and non-blank strings in order for insert and update operations to be performed on them. The corresponding fields must also be included in the insert or update operation. Otherwise, the update and insert operation will silently NOT be performed.</p> <p>We might change the way we handle this in the future. Maybe we'll throw an exception instead or fail the entire insert/update and bubble up the reason. For now, to avoid complicating the API in these early stages, we'll go with silent but documented. We'll see what the community thinks!</p>"},{"location":"customdata/integrate-googlecontacts-custom-data/#google-contacts-app-ui","title":"Google Contacts app UI","text":"<p>In the Google Contacts app, the <code>FileAs</code> and <code>UserDefined</code> custom data are only  shown for RawContacts that are associated with a Google Account. Local (device-only) RawContacts do  not have these custom data!</p> <p>\u2139\ufe0f For more info on local contacts, read about Local (device-only) contacts.</p>"},{"location":"customdata/integrate-googlecontacts-custom-data/#syncing-google-contacts-custom-data","title":"Syncing Google Contacts custom data","text":"<p>The Google Contacts app comes with sync adapters that is responsible for syncing <code>FileAs</code> and <code>UserDefined</code> custom data. As long as you have the Google Contacts app installed,  these custom data should remain synced depending on account sync settings.</p> <p>\u2139\ufe0f This library does not provide sync adapters for Google Contacts custom data.</p> <p>For more info, read Sync contact data across devices.</p>"},{"location":"customdata/integrate-handlename-custom-data/","title":"Integrate the handle name custom data","text":"<p>This library provides extensions for <code>HandleName</code> custom data that allows you to read and write handle name data for all of your contacts. These (optional) extensions live in the  <code>customdata-handlename</code> module. </p> <p>\u2139\ufe0f If you are looking to create your own custom data or get more insight on how the <code>HandleName</code>  custom data was built, read Integrate custom data.</p>"},{"location":"customdata/integrate-handlename-custom-data/#register-the-handle-name-custom-data-with-the-contacts-api-instance","title":"Register the handle name custom data with the Contacts API instance","text":"<p>You may register the <code>HandleName</code> custom data when creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        HandleNameRegistration()\n    )\n)\n</code></pre> <p>Or, alternatively after creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(context)\nHandleNameRegistration().registerTo(contactsApi.customDataRegistry)\n</code></pre>"},{"location":"customdata/integrate-handlename-custom-data/#getaddremove-handle-name-custom-data","title":"Get/add/remove handle name custom data","text":"<p>Just like regular data kinds, handle name custom data belong to a RawContact. A RawContact may have  0, 1, or more handle names.</p> <p>To get the handle names of a RawContact,</p> <pre><code>val handleNameSequence = rawContact.handleNames(contactsApi)\nval handleNameList = rawContact.handleNameList(contactsApi)\n</code></pre> <p>To get the handle names of all RawContacts belonging to a Contact,</p> <pre><code>val handleNameSequence = contact.handleNames(contactsApi)\nval handleNameList = contact.handleNameList(contactsApi)\n</code></pre> <p>To add a handle name to a (mutable) RawContact,</p> <pre><code>mutableRawContact.addHandleName(contacts, mutableHandleName)\n// or\nmutableRawContact.addHandleName(contacts) {\n    handle = \"CoolDude91\"\n}\n</code></pre> <p>To add a handle name to a the first RawContact or a Contact,</p> <pre><code>mutableContact.addHandleName(contacts, mutableHandleName)\n// or\nmutableContact.addHandleName(contacts) {\n    handle = \"CoolGal89\"\n}\n</code></pre>"},{"location":"customdata/integrate-handlename-custom-data/#use-the-handle-name-custom-data-in-queries-inserts-updates-and-deletes","title":"Use the handle name custom data in queries, inserts, updates, and deletes","text":"<p>Once you have registered your handle name custom data with the <code>Contacts</code> API instance, the API  instance is now able to perform read and write operations on it.</p> <ul> <li>Query custom data</li> <li>Insert custom data into new or existing contacts</li> <li>Update custom data</li> <li>Delete custom data</li> </ul>"},{"location":"customdata/integrate-handlename-custom-data/#syncing-handle-name-custom-data","title":"Syncing handle name custom data","text":"<p>This library does not provide sync adapters for handle name custom data. Unless you implement your own sync adapter, handle name custom data...</p> <ul> <li>will NOT be synced across devices</li> <li>will NOT be shown in AOSP and Google Contacts apps, and other Contacts apps   that show custom data from other apps</li> </ul> <p>For more info, read Sync contact data across devices.</p>"},{"location":"customdata/integrate-pokemon-custom-data/","title":"Integrate the Pokemon custom data","text":"<p>This library provides extensions for <code>Pokemon</code> custom data that allows you to read and write pokemon data for all of your contacts. These (optional) extensions live in the  <code>customdata-pokemon</code> module. </p> <p>\u2139\ufe0f If you are looking to create your own custom data or get more insight on how the <code>Pokemon</code>  custom data was built, read Integrate custom data.</p>"},{"location":"customdata/integrate-pokemon-custom-data/#register-the-pokemon-custom-data-with-the-contacts-api-instance","title":"Register the pokemon custom data with the Contacts API instance","text":"<p>You may register the <code>Pokemon</code> custom data when creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        PokemonRegistration()\n    )\n)\n</code></pre> <p>Or, alternatively after creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(context)\nPokemonRegistration().registerTo(contactsApi.customDataRegistry)\n</code></pre>"},{"location":"customdata/integrate-pokemon-custom-data/#getaddremove-pokemon-custom-data","title":"Get/add/remove pokemon custom data","text":"<p>Just like regular data kinds, pokemon custom data belong to a RawContact. A RawContact may have  0, 1, or more pokemons.</p> <p>To get the pokemons of a RawContact,</p> <pre><code>val pokemonSequence = rawContact.pokemons(contactsApi)\nval pokemonList = rawContact.pokemonList(contactsApi)\n</code></pre> <p>To get the pokemons of all RawContacts belonging to a Contact,</p> <pre><code>val pokemonSequence = contact.pokemons(contactsApi)\nval pokemonList = contact.pokemonList(contactsApi)\n</code></pre> <p>To add a pokemon to a (mutable) RawContact,</p> <pre><code>mutableRawContact.addPokemon(contacts, mutablePokemon)\n// or\nmutableRawContact.addPokemon(contacts) {\n    name = \"ditto\"\n    nickname = \"copy-cat\"\n    level = 24\n    pokeApiId = 132\n}\n</code></pre> <p>To add a pokemon to a the first RawContact or a Contact,</p> <pre><code>mutableContact.addPokemon(contacts, mutablePokemon)\n// or\nmutableContact.addPokemon(contacts) {\n    name = \"ditto\"\n    nickname = \"copy-cat\"\n    level = 24\n    pokeApiId = 132\n}\n</code></pre>"},{"location":"customdata/integrate-pokemon-custom-data/#use-the-pokemon-custom-data-in-queries-inserts-updates-and-deletes","title":"Use the pokemon custom data in queries, inserts, updates, and deletes","text":"<p>Once you have registered your pokemon custom data with the <code>Contacts</code> API instance, the API  instance is now able to perform read and write operations on it.</p> <ul> <li>Query custom data</li> <li>Insert custom data into new or existing contacts</li> <li>Update custom data</li> <li>Delete custom data</li> </ul>"},{"location":"customdata/integrate-pokemon-custom-data/#syncing-pokemon-custom-data","title":"Syncing pokemon custom data","text":"<p>This library does not provide sync adapters for pokemon custom data. Unless you implement your own sync adapter, pokemon custom data...</p> <ul> <li>will NOT be synced across devices</li> <li>will NOT be shown in AOSP and Google Contacts apps, and other Contacts apps   that show custom data from other apps</li> </ul> <p>For more info, read Sync contact data across devices.</p>"},{"location":"customdata/integrate-rpg-custom-data/","title":"Integrate the Role Playing Game (RPG) custom data","text":"<p>This provides extensions for <code>RpgStats</code> and <code>RpgProfession</code> custom data that allows you to read and  write rpg data for all of your contacts. These (optional) extensions live in the  <code>customdata-rpg</code> module.</p> <p>\u2139\ufe0f If you are looking to create your own custom data or get more insight on how the <code>RpgStats</code> and  <code>RpgProfession</code> custom data was built, read Integrate custom data.</p>"},{"location":"customdata/integrate-rpg-custom-data/#register-the-rpg-custom-data-with-the-contacts-api-instance","title":"Register the RPG custom data with the Contacts API instance","text":"<p>You may register all RPG custom data when creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(\n    context,\n    customDataRegistry = CustomDataRegistry().register(\n        RpgRegistration()\n    )\n)\n</code></pre> <p>Or, alternatively after creating the <code>Contacts</code> API instance,</p> <pre><code>val contactsApi = Contacts(context)\nRpgRegistration().registerTo(contactsApi.customDataRegistry)\n</code></pre>"},{"location":"customdata/integrate-rpg-custom-data/#readwrite-rpg-custom-data","title":"Read/write RPG custom data","text":""},{"location":"customdata/integrate-rpg-custom-data/#getset-rpgstats","title":"Get/set <code>RpgStats</code>","text":"<p>Just like regular data kinds, <code>RpgStats</code> custom data belong to a RawContact. A RawContact may only have 0 or 1 <code>RpgStats</code>.</p> <p>To get the <code>RpgStats</code> of a RawContact,</p> <pre><code>val rpgStats = rawContact.rpgStats(contactsApi)\n</code></pre> <p>To get the <code>RpgStats</code> of all RawContacts belonging to a Contact,</p> <pre><code>val rpgStatsSequence = contact.rpgStats(contactsApi)\nval rpgStatsList = contact.rpgStatsList(contactsApi)\n</code></pre> <p>To set the <code>RpgStats</code> of a (mutable) RawContact,</p> <pre><code>mutableRawContact.setRpgStats(contacts, mutableRpgStats)\n// or\nmutableRawContact.setRpgStats(contacts) {\n    level = 78\n    speed = 500\n    strength = 789\n    intelligence = 123\n    luck = 999\n}\n</code></pre> <p>To set the <code>RpgStats</code> of the first RawContact in a Contact,</p> <pre><code>mutableContact.setRpgStats(contacts, mutableRpgStats)\n// or\nmutableContact.setRpgStats(contacts) {\n    level = 78\n    speed = 500\n    strength = 789\n    intelligence = 123\n    luck = 999\n}\n</code></pre>"},{"location":"customdata/integrate-rpg-custom-data/#getset-rpgprofession","title":"Get/set <code>RpgProfession</code>","text":"<p>Just like regular data kinds, <code>RpgProfession</code> custom data belong to a RawContact. A RawContact may  only have 0 or 1 <code>RpgProfession</code>.</p> <p>To get the <code>RpgProfession</code> of a RawContact,</p> <pre><code>val rpgProfession = rawContact.rpgProfession(contactsApi)\n</code></pre> <p>To get the <code>RpgProfession</code> of all RawContacts belonging to a Contact,</p> <pre><code>val rpgProfessionSequence = contact.rpgProfessions(contactsApi)\nval rpgProfessionList = contact.rpgProfessionList(contactsApi)\n</code></pre> <p>To set the <code>RpgProfession</code> of a (mutable) RawContact,</p> <pre><code>mutableRawContact.setRpgProfession(contacts, mutableRpgProfession)\n// or\nmutableRawContact.setRpgProfession(contacts) {\n    title = \"swordsman\"\n}\n</code></pre> <p>To set the <code>RpgProfession</code> of the first RawContact in a Contact,</p> <pre><code>mutableContact.setRpgProfession(contacts, mutableRpgProfession)\n// or\nmutableContact.setRpgProfession(contacts) {\n    title = \"swordsman\"\n}\n</code></pre>"},{"location":"customdata/integrate-rpg-custom-data/#use-the-rpg-custom-data-in-queries-inserts-updates-and-deletes","title":"Use the RPG custom data in queries, inserts, updates, and deletes","text":"<p>Once you have registered the RPG custom data with the <code>Contacts</code> API instance, the API instance is  now able to perform read and write operations on it.</p> <ul> <li>Query custom data</li> <li>Insert custom data into new or existing contacts</li> <li>Update custom data</li> <li>Delete custom data</li> </ul>"},{"location":"customdata/integrate-rpg-custom-data/#syncing-rpg-custom-data","title":"Syncing RPG custom data","text":"<p>This library does not provide sync adapters for RPG custom data. Unless you implement your own sync  adapter, RPG custom data...</p> <ul> <li>will NOT be synced across devices</li> <li>will NOT be shown in AOSP and Google Contacts apps, and other Contacts apps   that show custom data from other apps</li> </ul> <p>For more info, read Sync contact data across devices.</p>"},{"location":"customdata/query-custom-data/","title":"Query custom data","text":"<p>This library provides several query APIs that support custom data integration.</p> <ol> <li><code>Query</code><ul> <li>Query contacts (advanced)</li> </ul> </li> <li><code>BroadQuery</code><ul> <li>Query contacts</li> </ul> </li> <li><code>RawContactsQuery</code><ul> <li>Query contacts</li> </ul> </li> <li><code>ProfileQuery</code><ul> <li>Query device owner Contact profile</li> </ul> </li> <li><code>DataQuery</code><ul> <li>Query specific data kinds</li> </ul> </li> </ol> <p>To help illustrate how custom data integrates with these query APIs, we'll use the <code>HandleName</code> and <code>Gender</code> custom data.</p> <p>\u2139\ufe0f For more info, read Integrate the gender custom data and Integrate the handle name custom data.</p>"},{"location":"customdata/query-custom-data/#getting-custom-data-from-a-contact-or-rawcontact","title":"Getting custom data from a Contact or RawContact","text":"<p>Custom data, just like regular data kinds, are attached to a RawContact. They follow the same rules as regular data kinds. </p> <p>\u2139\ufe0f For more info, read about API Entities.</p> <p>For example, you are able to get the handle names and gender of a RawContact,</p> <pre><code>val handleNames = rawContact.handleNames(contactsApi)\nval gender = rawContact.gender(contactsApi)\n</code></pre> <p>There are also extensions that allow you to get custom data from a Contact, which can be made up of  one or more RawContacts,</p> <pre><code>val handleNames = contact.handleNames(contactsApi)\nval genders = contact.genders(contactsApi)\n</code></pre>"},{"location":"customdata/query-custom-data/#getting-specific-custom-data-kinds-directly","title":"Getting specific custom data kinds directly","text":"<p>Every custom data provides an extension to the <code>DataQuery</code> that allows you to query for only that specific custom data kind.</p> <p>For example, to get all available <code>HandleName</code>s and <code>Gender</code>s from all contacts,</p> <pre><code>val handleNames = Contacts(context).data().query().handleNames().find()\nval genders = Contacts(context).data().query().genders().find()\n</code></pre> <p>To get all <code>HandleName</code>s starting with the letter \"h\",</p> <pre><code>val handleNames = Contacts(context)\n    .data()\n    .query()\n    .handleNames()\n    .where { Handle startsWith \"h\" }\n    .find()\n</code></pre> <p>For more info, read Query specific data kinds.</p>"},{"location":"customdata/query-custom-data/#the-include-function-and-custom-data","title":"The <code>include</code> function and custom data","text":"<p>All of the above mentioned APIs provide an <code>include</code> function that allows you to include only a  given set of fields (data) in each of the returned entities. Custom data entries provides fields  that can be used in this function. </p> <p>By default, not calling the <code>include</code> function will include all fields, including custom data fields. </p> <p>For example, to explicitly include all <code>HandleName</code> fields, </p> <pre><code>.include(HandleNameFields.all)\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"customdata/query-custom-data/#the-where-function-and-custom-data","title":"The <code>where</code> function and custom data","text":"<p>The <code>Query</code>, <code>RawContactsQuery</code>, and <code>DataQuery</code> APIs provides a <code>where</code> function that allows you  to specify a matching  criteria based on specific field values. Custom data entries provides fields  that can be used in this function. For example, to match <code>HandleName</code>s starting with the letter \"h\",</p> <pre><code>.where { Handle startsWith \"h\" }\n</code></pre> <p>The <code>BroadQuery</code> API provides a <code>wherePartiallyMatches</code> function that NOT support matching custom data. Only AOSP data are included in the matching process.</p> <p>The <code>ProfileQuery</code> API does not provide a where function as there can only be one profile Contact per device. </p>"},{"location":"customdata/query-custom-data/#the-orderby-function-and-custom-data","title":"The <code>orderBy</code> function and custom data","text":"<p>The <code>DataQuery</code> API provides an <code>orderBy</code> function that supports custom data. For example, to order <code>HandleName</code>s,</p> <pre><code>.orderBy(HandleNameFields.Handle.asc())\n</code></pre> <p>The <code>Query</code>, <code>BroadQuery</code>, and <code>RawContactsQuery</code> APIs provides an <code>orderBy</code> function that only  takes in fields from the Contacts/RawContacts table, not the Data table. So there is no custom  data, or AOSP data, support for this.</p> <p>The <code>ProfileQuery</code> API does not provide an <code>orderBy</code> function as there can only be at most one  profile Contact on the device.</p>"},{"location":"customdata/update-custom-data/","title":"Update custom data","text":"<p>This library provides several update APIs that support custom data integration.</p> <ol> <li><code>Update</code><ul> <li>Update contacts</li> </ul> </li> <li><code>ProfileUpdate</code><ul> <li>Update device owner Contact profile</li> </ul> </li> <li><code>DataUpdate</code><ul> <li>Update existing sets of data</li> </ul> </li> </ol> <p>To help illustrate how custom data integrates with these update APIs, we'll use the <code>HandleName</code> and <code>Gender</code> custom data.</p> <p>\u2139\ufe0f For more info about custom data, read Integrate custom data.</p>"},{"location":"customdata/update-custom-data/#updating-custom-data-via-contactsrawcontacts","title":"Updating custom data via Contacts/RawContacts","text":"<p>Custom data, just like regular data kinds, are attached to a RawContact. They follow the same rules as regular data kinds.</p> <p>\u2139\ufe0f For more info, read about API Entities.</p> <p>For example, you are able to update existing handle names and the gender of an existing RawContact,</p> <pre><code>mutableRawContact.handleNames(contactsApi).firstOrNull()?.apply {\n   handle = \"gal91\"\n}\nmutableRawContact.gender(contactsApi)?.apply {\n   type = GenderEntity.Type.FEMALE\n}\n</code></pre> <p>There are also extensions that allow you to update custom data of an existing RawContact via a  Contact, which can be made up of one or more RawContacts,</p> <pre><code>mutableContact.handleNames(contactsApi).firstOrNull()?.apply {\n   handle = \"gal91\"\n}\nmutableContact.genders(contactsApi).firstOrNull()?.apply {\n   type = GenderEntity.Type.FEMALE\n}\n</code></pre> <p>Once you have made the updates to existing custom data, you can perform the update operation on the  RawContact to commit your changes into the database using <code>Update</code> or <code>ProfileUpdate</code>.</p>"},{"location":"customdata/update-custom-data/#updating-sets-of-custom-data-directly","title":"Updating sets of custom data directly","text":"<p>All custom data are compatible with the <code>DataUpdate</code> API, which allows you to update sets of  existing regular and custom data kinds.</p> <p>For example, to update a set of <code>HandleName</code>s and <code>Gender</code>s,</p> <pre><code>val handleNames: List&lt;MutableHandleName&gt;\nval genders: List&lt;MutableGender&gt;\n\nval updateResult = Contacts(this)\n   .data()\n   .update()\n   .data(handleNames + genders)\n   .commit()\n</code></pre> <p>For more info, read Update existing sets of data.</p>"},{"location":"customdata/update-custom-data/#the-include-function-and-custom-data","title":"The <code>include</code> function and custom data","text":"<p>All of the above mentioned APIs provide an <code>include</code> function that allows you to include only a given set of fields (data) to be processed in the update operation. Custom data entries provides fields that can be used in this function.</p> <p>By default, not calling the <code>include</code> function will include all fields, including custom data fields.</p> <p>For example, to specifically include only <code>HandleName</code> and <code>Gender</code> fields,</p> <pre><code>.include(HandleNameFields.all + GenderFields.all)\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"customdata/update-custom-data/#blank-data-are-deleted","title":"Blank data are deleted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are deleted by update APIs.</p> <p>For more info, read about Blank data.</p>"},{"location":"data/delete-data-sets/","title":"Delete existing sets of data","text":"<p>This library provides the <code>DataDelete</code> API that allows you to delete a list of any data kinds directly without having to delete them via Contacts/RawContacts.</p> <p>An instance of the <code>DataDelete</code> API is obtained by,</p> <pre><code>val delete = Contacts(context).data().delete()\n</code></pre> <p>\u2139\ufe0f To delete all kinds of data via Contacts/RawContacts, you may remove them from the  Contact/RawContact and then perform an update. For more info, read Update contacts.</p>"},{"location":"data/delete-data-sets/#a-basic-delete","title":"A basic delete","text":"<p>To delete a set of data,</p> <pre><code>val deleteResult = delete\n    .data()\n    .delete()\n    .data(data)\n    .commit()\n</code></pre> <p>To delete a list of emails and phones,</p> <pre><code>val deleteResult = delete\n    .data()\n    .delete()\n    .data(emails + phones)\n    .commit()\n</code></pre> <p>To delete a set of data using data IDs,</p> <pre><code>val deleteResult = delete\n    .data()\n    .delete()\n    .dataWithId(1, 2, 3)\n    .commit()\n</code></pre>"},{"location":"data/delete-data-sets/#an-advanced-delete","title":"An advanced delete","text":"<p>You may specify a matching criteria, like in queries, that will delete all matching data,</p> <pre><code>val deleteResult = delete\n    .dataWhere { Email.Address endsWith \"@yahoo.com\" }\n    .commit()\n</code></pre>"},{"location":"data/delete-data-sets/#executing-the-delete","title":"Executing the delete","text":"<p>To execute the delete,</p> <pre><code>.commit()\n</code></pre> <p>If you want to delete all specified data in a single atomic transaction,</p> <pre><code>.commitInOneTransaction()\n</code></pre> <p>The call to <code>commitInOneTransaction</code> will only succeed if ALL given data are successfully deleted. If one delete fails, the entire operation will fail and everything will be reverted prior to the  delete operation. In contrast, <code>commit</code> allows for some deletes to succeed and some to fail.</p>"},{"location":"data/delete-data-sets/#handling-the-delete-result","title":"Handling the delete result","text":"<p>The <code>commit</code> and <code>commitInOneTransaction</code> functions returns a <code>Result</code>,</p> <p>To check if all deletes succeeded,</p> <pre><code>val allDeletesSuccessful = deleteResult.isSuccessful\n</code></pre> <p>To check if a particular delete succeeded,</p> <pre><code>val dataDeleteSuccessful = deleteResult.isSuccessful(data)\nval dataDeleteSuccessful = deleteResult.isSuccessful(data.id)\n</code></pre> <p>To check if a particular advanced delete managed to delete at least one matching data,</p> <pre><code>val where = Fields.Email.Address endsWith \"@yahoo.com\"\nval deleteResult = delete.dataWhere(where).commit()\nval advancedDeleteSuccessful = deleteResult.isSuccessful(where)\n</code></pre>"},{"location":"data/delete-data-sets/#performing-the-delete-and-result-processing-asynchronously","title":"Performing the delete and result processing asynchronously","text":"<p>Deletes are executed when the <code>commit</code> or <code>commitInOneTransaction</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"data/delete-data-sets/#performing-the-delete-with-permission","title":"Performing the delete with permission","text":"<p>Deletes require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the delete will do nothing and return a failed result.</p> <p>To perform the delete with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"data/delete-data-sets/#profile-data","title":"Profile data","text":"<p>The <code>DataDelete</code> API also supports deleting the Profile (device owner) contact data. To get an instance of this API for Profile data deletes,</p> <pre><code>val profileDataDelete = Contacts(context).profile().data().delete()\n</code></pre> <p>All deletes will be limited to the Profile, whether it exists or not.</p>"},{"location":"data/delete-data-sets/#custom-data-support","title":"Custom data support","text":"<p>The <code>DataDelete</code> API supports custom data. For more info, read Delete custom data.</p>"},{"location":"data/insert-data-sets/","title":"Insert data into new or existing contacts","text":"<p>Data can only be created/inserted into the database whenever inserting or updating new or existing  contacts.</p> <p>When using insert and update APIs such as <code>Insert</code>, <code>ProfileInsert</code>, <code>Update</code>, and <code>ProfileUpdate</code>, you are able to create/insert data into new or existing RawContacts respectively.</p> <p>For example, to insert an email into a new contact using the <code>Insert</code> API,</p> <pre><code>Contacts(context)\n    .insert()\n    .rawContact {\n        addEmail(email)\n    }\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Insert contacts.</p> <p>To insert an email into a new Profile contact using the <code>ProfileInsert</code> API,</p> <pre><code>Contacts(context)\n    .profile()\n    .insert()\n    .rawContact {\n        addEmail(email)\n    }\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Insert device owner Contact profile.</p> <p>To insert an email into an existing contact using the <code>Update</code> API,</p> <pre><code>Contacts(context)\n    .update()\n    .contacts(existingContact.mutableCopy {\n        addEmail(email)\n    })\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Update contacts.</p> <p>To insert an email into an the existing Profile Contact using the <code>ProfileUpdate</code> API,</p> <pre><code>Contacts(context)\n    .profile()\n    .update()\n    .contact(existingProfileContact.mutableCopy {\n        addEmail(email)\n    })\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info, read Update device owner Contact profile.</p>"},{"location":"data/insert-data-sets/#blank-data-are-not-inserted","title":"Blank data are not inserted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are  ignored and are not inserted by insert APIs.</p> <p>For more info, read about Blank data.</p>"},{"location":"data/query-data-sets/","title":"Query specific data kinds","text":"<p>This library provides the <code>DataQueryFactory</code> API that allows you to get a list of specific data kinds  directly without having to get them from Contacts/RawContacts.</p> <p>An instance of the <code>DataQueryFactory</code> API is obtained by,</p> <pre><code>val query = Contacts(context).data().query()\n</code></pre> <p>\u2139\ufe0f To retrieve all kinds of data via Contacts/RawContacts, read  Query contacts, Query contacts (advanced), Query contacts by phone or SIP, Query RawContacts.</p>"},{"location":"data/query-data-sets/#data-queries","title":"Data queries","text":"<p>The <code>DataQueryFactory</code> API provides instances of <code>DataQuery</code> for every data kind in the library.</p> <p>The full list of queries are defined in the <code>DataQueryFactory</code> interface. Here it is for reference,</p> <pre><code>val dataQueryFactory = Contacts(context).data().query()\n\nval addressesQuery = dataQueryFactory.addresses()\nval emailsQuery = dataQueryFactory.emails()\nval eventsQuery = dataQueryFactory.events()\nval groupMembershipsQuery = dataQueryFactory.groupMemberships()\nval imsQuery = dataQueryFactory.ims()\nval namesQuery = dataQueryFactory.names()\nval nicknamesQuery = dataQueryFactory.nicknames()\nval notesQuery = dataQueryFactory.notes()\nval organizationsQuery = dataQueryFactory.organizations()\nval phonesQuery = dataQueryFactory.phones()\nval relationsQuery = dataQueryFactory.relations()\nval sipAddressesQuery = dataQueryFactory.sipAddresses()\nval websitesQuery = dataQueryFactory.websites()\n\n// Photos are intentionally left out as it is internal to the library.\n</code></pre> <p>These query instances will allow you to query only specific data kinds from all contacts.</p> <p>For example, to get all emails from all contacts,</p> <pre><code>val emails = Contacts(context).data().query().emails().find()\n</code></pre> <p>To get all websites with a \".net\" extension from contacts with the given IDs,</p> <pre><code>val websites = Contacts(this)\n    .data()\n    .query()\n    .websites()\n    .where { (Website.Url endsWith \".net\") and (Contact.Id `in` contactIds) }\n    .find()\n</code></pre>"},{"location":"data/query-data-sets/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those data associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to limit the search to data belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all data are included in the search.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included in the search. RawContacts without an associated account are considered local contacts or device-only contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"data/query-data-sets/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields in each of the matching data ,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include the given name and family name in a names query,</p> <pre><code>.include(Fields.Name.GivenName, Fields.Name.FamilyName)\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"data/query-data-sets/#ordering","title":"Ordering","text":"<p>To order resulting data using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order emails by type first and then email address,</p> <pre><code>.orderBy(Fields.Email.Type.asc(), Fields.Email.Address.asc())\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use the corresponding fields in <code>Fields</code> to construct the orderBys.</p>"},{"location":"data/query-data-sets/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of data returned and/or offset (skip) a specified number of data, use the  <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"data/query-data-sets/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"data/query-data-sets/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val data = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"data/query-data-sets/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"data/query-data-sets/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"data/query-data-sets/#profile-data","title":"Profile data","text":"<p>The <code>DataQueryFactory</code> API (and its <code>DataQuery</code> instances) also supports querying the Profile  (device owner) contact data. To get an instance of this API for Profile data queries,</p> <pre><code>val profileDataQueryFactory = Contacts(context).profile().data().query()\n</code></pre> <p>All queries will be limited to the Profile, whether it exists or not.</p>"},{"location":"data/query-data-sets/#custom-data-support","title":"Custom data support","text":"<p>The <code>DataQueryFactory</code> API (and its <code>DataQuery</code> instances) supports custom data. For more info,  read Query custom data.</p>"},{"location":"data/query-data-sets/#using-the-where-function-to-specify-matching-criteria","title":"Using the <code>where</code> function to specify matching criteria","text":"<p>Use the corresponding <code>contacts.core.Fields</code> combined with the extensions from <code>contacts.core.Where</code>  to form WHERE clauses. </p> <p>\u2139\ufe0f This docs page will not provide a tutorial on database where clauses. It assumes that you know  the basics. If you don't know the basics, then search for sqlite where clause. </p> <p>For example, to get all nicknames from all contacts,</p> <pre><code>val nicknames = Contacts(context).data().query().nicknames().find()\n</code></pre> <p>To get all birthday events from all contacts,</p> <pre><code>val birthdayEvents = Contacts(this)\n    .data()\n    .query()\n    .events()\n    .where { Event.Type equalTo EventEntity.Type.BIRTHDAY }\n    .find()\n</code></pre>"},{"location":"data/query-data-sets/#limitations","title":"Limitations","text":"<p>This library only provides basic WHERE functions. It does not cover the entirety of SQLite, though  the community may add more over time &lt;3</p> <p>Furthermore, this library is constrained by rules and limitations set by the Contacts Provider and the behavior of the AOSP Contacts app. One such rule/limitation has resulted in this library not providing WHERE functions such as <code>isNull</code> or <code>isNullOrEmpty</code> to prevent making misleading queries.</p> <p>Removing a piece of existing data results in the deletion of the row in the Data table if that row  no longer contains any meaningful data. This is the behavior of the AOSP Contacts app. Therefore,  querying for null fields is not possible. For example, there may be no Data rows that exist where  the email address is null. Thus, a query to search for all emails where the address is null may always return no results.</p>"},{"location":"data/update-data-sets/","title":"Update existing sets of data","text":"<p>This library provides the <code>DataUpdate</code> API that allows you to update a list of any data kinds in the Contacts Provider database directly without having to update them via Contacts/RawContacts. This ensures that the Contacts Provider database contains the same data you have in memory.</p> <p>An instance of the <code>DataUpdate</code> API is obtained by,</p> <pre><code>val update = Contacts(context).data().update()\n</code></pre> <p>\u2139\ufe0f To update all kinds of data via Contacts/RawContacts, read Update contacts.</p>"},{"location":"data/update-data-sets/#a-basic-update","title":"A basic update","text":"<p>To update a set of data,</p> <pre><code>val updateResult = Contacts(context)\n    .data()\n    .update()\n    .data(data)\n    .commit()\n</code></pre> <p>If you want to update a list of mutable emails and phones,</p> <pre><code>val updateResult = Contacts(context)\n    .data()\n    .update()\n    .data(mutableEmails + mutablePhones)\n    .commit()\n</code></pre>"},{"location":"data/update-data-sets/#blank-data-are-deleted","title":"Blank data are deleted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are  deleted by update APIs, unless the corresponding fields are not included in the operation.</p> <p>For more info, read about Blank data.</p>"},{"location":"data/update-data-sets/#including-only-specific-data","title":"Including only specific data","text":"<p>To perform update operations only the given set of fields (data),</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to perform updates on only email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"data/update-data-sets/#executing-the-update","title":"Executing the update","text":"<p>To execute the update,</p> <pre><code>.commit()\n</code></pre>"},{"location":"data/update-data-sets/#handling-the-update-result","title":"Handling the update result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <pre><code>val contactsApi =  Contacts(context)\nval mutableEmail = email.mutableCopy { ... }\nval mutablePhone = phone.mutableCopy { ... }\n\nval updateResult = contactsApi\n    .date()\n    .update()\n    .data(mutableEmail, mutablePhone)\n    .commit()\n</code></pre> <p>To check if all updates succeeded,</p> <pre><code>val allUpdatesSuccessful = updateResult.isSuccessful\n</code></pre> <p>To check if a particular update succeeded,</p> <pre><code>val emailUpdateSuccessful = updateResult.isSuccessful(mutableEmail)\n</code></pre> <p>Once you have performed the updates, you can retrieve the updated data references via the  <code>DataQuery</code> APIs,</p> <pre><code>val updatedEmail = contactsApi\n    .data()\n    .query()\n    .emails()\n    .where { Email.Id equalTo emailId }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query specific data kinds.</p> <p>Alternatively, you may use the extensions provided in <code>DataRefresh</code>.</p> <p>To get the updated phone,</p> <pre><code>val updatedPhone = phone.refresh(contactsApi)\n</code></pre>"},{"location":"data/update-data-sets/#cancelling-the-update","title":"Cancelling the update","text":"<p>To cancel an update amid execution,</p> <pre><code>.commit { returnTrueIfUpdateShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel update processing as soon as possible. The function is called numerous times during update processing to check if processing should stop or continue. This gives you the option to cancel the update.</p> <p>For example, to automatically cancel the update inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val updateResult = update.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"data/update-data-sets/#performing-the-update-and-result-processing-asynchronously","title":"Performing the update and result processing asynchronously","text":"<p>Updates are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"data/update-data-sets/#performing-the-update-with-permission","title":"Performing the update with permission","text":"<p>Updates require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the update  will do nothing and return a failed result.</p> <p>To perform the update with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"data/update-data-sets/#profile-data","title":"Profile data","text":"<p>The <code>DataUpdate</code> API also supports updating the Profile (device owner) contact data. To get an  instance of this API for Profile data updates,</p> <pre><code>val profileDataUpdate = Contacts(context).profile().data().update()\n</code></pre> <p>All updates will be limited to the Profile, whether it exists or not.</p>"},{"location":"data/update-data-sets/#custom-data-support","title":"Custom data support","text":"<p>The <code>DataUpdate</code> API supports custom data. For more info, read Update custom data.</p>"},{"location":"debug/debug-blockednumber-provider-tables/","title":"Debug the Blocked Number Provider tables","text":"<p>If you want to take a look at the contents of Blocked Number Provider database tables that this library uses, then use the <code>debug</code> module functions to print relevant columns and all rows of a particular table to the Logcat.</p> <p>This is useful if you are experiencing an issue and are trying to figure out if it is this library's fault or not. This is most useful for contributors of this library. It allows us to verify that the work we are doing is correct. Consumers may also use it, especially if they are building their own full-fledged contacts application.</p> <pre><code>Context.logBlockedNumbersTable()\n</code></pre>"},{"location":"debug/debug-blockednumber-provider-tables/#this-is-not-meant-to-be-used-in-production-code","title":"This is not meant to be used in production code!","text":"<p>DO NOT include usages of the <code>debug</code> module in your production code! It is only meant to be used as a debugging tool during development!</p>"},{"location":"debug/debug-blockednumber-provider-tables/#debug-functions-do-not-depend-on-the-core-library","title":"Debug functions do not depend on the core library","text":"<p>Notice that the <code>debug</code> module does not depend on the <code>core</code> module, or any other modules in this project. This is done to ensure that whatever is being logged is independent of the core API implementation! This is important for debugging the core APIs during development. We wouldn't exactly want to debug the core APIs using the core APIs. That's just a recipe for disaster!</p>"},{"location":"debug/debug-blockednumber-provider-tables/#debug-functions-assume-that-privileges-are-acquired","title":"Debug functions assume that privileges are acquired","text":"<p>There are no permissions required for blocked numbers. However, there are privileges that must be acquired. For more info, read about Blocked numbers.</p> <p>If privileges are not acquired, the debug functions will not print any table rows.</p>"},{"location":"debug/debug-contacts-provider-tables/","title":"Debug the Contacts Provider tables","text":"<p>If you want to take a look at the contents of Contacts Provider database tables that this library  uses, then use the <code>debug</code> module functions to print relevant columns and all rows of a particular  table to the Logcat.</p> <p>This is useful if you are experiencing an issue and are trying to figure out if it is this library's fault or not. This is most useful for contributors of this library. It allows us to verify that the work we are doing is correct. Consumers may also use it, especially if they are building their own full-fledged contacts application.</p> Table Function <code>Groups</code> <code>Context.logGroupsTable()</code> <code>AggregationExceptions</code> <code>Context.logAggregationExceptionsTable()</code> <code>Profile</code> <code>Context.logProfile()</code> <code>Contacts</code> <code>Context.logContactsTable()</code> <code>RawContacts</code> <code>Context.logRawContactsTable()</code> <code>Data</code> <code>Context.logDataTable()</code> <p>To log all of the above tables in a single call,</p> <pre><code>Context.logContactsProviderTables()\n</code></pre>"},{"location":"debug/debug-contacts-provider-tables/#this-is-not-meant-to-be-used-in-production-code","title":"This is not meant to be used in production code!","text":"<p>DO NOT include usages of the <code>debug</code> module in your production code! It is only meant to be used as a debugging tool during development!</p> <p>There are several reasons why you should only use this for debugging.</p> <p>First, Contacts database tables may be very lengthy. Imagine trying to print thousands of contact data! It would slow down your app significantly if you log in the UI thread.</p> <p>Second, Contacts database tables will most likely contain sensitive, private information about your users. If you are working on a contacts app and you are logging your user's Contacts database table rows into remote tracking services for analytics or crash reporting, you could be violating GDPR depending on how you use that information. Be careful. This is why logging functions in the <code>debug</code> module are not customizable and are not part of the core API.</p> <p>Other forms of logging outside of the <code>debug</code> module implemented by this library allows consumers to uphold privacy laws.</p> <p>The <code>debug</code> module is a power tool that should only be used for local debugging purposes!</p>"},{"location":"debug/debug-contacts-provider-tables/#debug-functions-do-not-depend-on-the-core-library","title":"Debug functions do not depend on the core library","text":"<p>Notice that the <code>debug</code> module does not depend on the <code>core</code> module, or any other modules in this project. This is done to ensure that whatever is being logged is independent of the core API implementation! This is important for debugging the core APIs during development. We wouldn't exactly want to debug the core APIs using the core APIs. That's just a recipe for disaster!</p>"},{"location":"debug/debug-contacts-provider-tables/#debug-functions-assume-that-permissions-have-been-granted","title":"Debug functions assume that permissions have been granted","text":"<p>If the read permission <code>android.permission.READ_CONTACTS</code> is not granted, the debug functions will not print any table rows.</p>"},{"location":"debug/debug-contacts-provider-tables/#debugging-other-tables","title":"Debugging other tables","text":"<p>To debug Blocked Number Provider tables, read Debug the Blocked Number Provider tables.</p> <p>To debug SIM Contacts table, read Debug the Sim Contacts table.</p>"},{"location":"debug/debug-sim-contacts-tables/","title":"Debug the Sim Contacts table","text":"<p>If you want to take a look at the contents of Sim Contact database tables that this library uses,  then use the <code>debug</code> module functions to print relevant columns and all rows of a particular table  to the Logcat.</p> <p>This is useful if you are experiencing an issue and are trying to figure out if it is this library's fault or not. This is most useful for contributors of this library. It allows us to verify that the work we are doing is correct. Consumers may also use it, especially if they are building their own full-fledged contacts application.</p> <pre><code>Context.logSimContactsTable()\n</code></pre>"},{"location":"debug/debug-sim-contacts-tables/#this-is-not-meant-to-be-used-in-production-code","title":"This is not meant to be used in production code!","text":"<p>DO NOT include usages of the <code>debug</code> module in your production code! It is only meant to be used as a debugging tool during development!</p>"},{"location":"debug/debug-sim-contacts-tables/#debug-functions-do-not-depend-on-the-core-library","title":"Debug functions do not depend on the core library","text":"<p>Notice that the <code>debug</code> module does not depend on the <code>core</code> module, or any other modules in this project. This is done to ensure that whatever is being logged is independent of the core API implementation! This is important for debugging the core APIs during development. We wouldn't exactly want to debug the core APIs using the core APIs. That's just a recipe for disaster!</p>"},{"location":"debug/debug-sim-contacts-tables/#debug-functions-assume-that-permissions-have-been-granted","title":"Debug functions assume that permissions have been granted","text":"<p>If the read permission <code>android.permission.READ_CONTACTS</code> is not granted, the debug functions will not print any table rows.</p>"},{"location":"entities/about-api-entities/","title":"API Entities","text":"<p>First, it's important to understand the most basic concept of the Android Contacts Provider / ContactsContract. Afterwards, everything in this library should just make sense.</p> <p>There is only one thing you need to know outside of this library. The library handles the rest of the details so you don't have to!</p>"},{"location":"entities/about-api-entities/#contacts-provider-contactscontract-basic-concept","title":"Contacts Provider / ContactsContract Basic Concept","text":"<p>There are 3 main database tables used in dealing with contacts. These tables are all connected.</p> <ol> <li>Contacts<ul> <li>Rows representing different people.</li> <li>E.G. John Doe</li> </ul> </li> <li>RawContacts<ul> <li>Rows that link Contacts rows to specific Accounts.</li> <li>E.G. John Doe from john.doe@gmail.com, John Doe from john.dow@hotmail.com</li> </ul> </li> <li>Data<ul> <li>Rows containing data (e.g. name, email) for a RawContacts row.</li> <li>E.G. John Doe from Gmail's name and email, John Doe from Hotmail's phone and address</li> </ul> </li> </ol> <p>\u2139\ufe0f There are more tables but it won't be covered in this docs for brevity. </p> <p>In the example given (E.G.) above,</p> <ul> <li>there is one row in the Contacts table for the person John Doe</li> <li>there are 2 rows in the RawContacts table that make up the Contact John Doe</li> <li>there are 4 rows in the Data table belonging to the Contact John Doe.<ul> <li>2 of these rows belong to John Doe from Gmail and the other 2 belong to John Doe from Hotmail</li> </ul> </li> </ul> <p>In the background, the Contacts Provider automatically performs the RawContacts linking/aggregation into a single Contact. To forcefully link or unlink sets of RawContacts, read Link unlink Contacts.</p> <p>In the background, the Contacts Provider syncs all data from the local database to the remote database and vice versa (depending on system contact sync settings). Read more in Sync contact data across devices.</p> <p>That's all you need to know! Hopefully it wasn't too much. I know it was difficult for me to grasp in the beginning =P.</p> <p>Once you internalize this one to many relationship between Contacts -&gt; RawContacts -&gt; Data, you have unlocked the full potential of this library and the world is at the palm of your hands!</p>"},{"location":"entities/about-api-entities/#contacts-api-entities","title":"Contacts API Entities","text":"<p>This library provides entities that model everything in the Contacts Provider database.</p> <ul> <li><code>Contact</code><ul> <li>Primarily contains a list of RawContacts that are associated with this contact.</li> </ul> </li> <li><code>RawContact</code><ul> <li>Contains contact data that belong to an account.</li> <li>There may be more than one RawContact per Contact.</li> </ul> </li> <li><code>DataEntity</code><ul> <li>A specific kind of data of a RawContact. These entities model the common data kinds that are   provided by the Contacts Provider.</li> <li><code>Address</code></li> <li><code>Email</code></li> <li><code>Event</code></li> <li><code>GroupMembership</code></li> <li><code>Im</code></li> <li><code>Name</code></li> <li><code>Nickname</code></li> <li><code>Note</code></li> <li><code>Organization</code></li> <li><code>Phone</code></li> <li><code>Photo</code></li> <li><code>Relation</code></li> <li><code>SipAddress</code></li> <li><code>Website</code></li> </ul> </li> </ul> <p>You can find all of the above in the <code>contacts.core.entities</code> package. Note that there are other entities that are not mentioned in this docs for brevity.</p> <p>All entities are <code>Parcelable</code> to support state retention during app/activity/fragment/view recreation.</p> <p>Each entity has an immutable version (typically returned by queries) and a mutable version (typically used by insert, update, and delete functions). Most immutable entities have a  <code>mutableCopy</code> function that returns a mutable copy (typically to be used for inserts and updates  and other mutating API functions).</p> <p>\u2139\ufe0f Custom data kinds may also be integrated into the contacts database (though not synced across  devices). For more info, read Integrate custom data.</p> <p>\u2139\ufe0f Default native and custom data may be retrieved, set, or cleared. For more info, read  Get set clear default Contact data.</p>"},{"location":"entities/about-api-entities/#contacts-api-fields","title":"Contacts API Fields","text":"<p>The fields defined in <code>contacts.core.Fields.kt</code> specify what properties of entities to include in read and write operations. For example, to include only the contact display name, organization  company, and all phone number fields in a query/insert/update operation,</p> <pre><code>queryInsertUpdate.include(mutableSetOf&lt;AbstractDataField&gt;().apply {\n    add(Fields.Contact.DisplayNamePrimary)\n    add(Fields.Organization.Company)\n    addAll(Fields.Phone.all)\n})\n</code></pre> <p>The following entity properties are used in the read/write operation,</p> <pre><code>Contact {\n    displayNamePrimary\n\n    RawContact {\n        organization {\n            company\n        }\n        phones {\n            number\n            normalizedNumber\n            type\n            label\n        }\n    }\n}\n</code></pre> <p>\u2139\ufe0f For more info, read Include only certain fields for read and write operations.</p>"},{"location":"entities/about-api-entities/#data-kinds-count-restrictions","title":"Data kinds count restrictions","text":"<p>A <code>RawContact</code> may have at most one OR no limits of certain kinds of data.</p> <p>A RawContact may have 0 or 1 of each of these data kinds;</p> <ul> <li><code>Name</code></li> <li><code>Nickname</code></li> <li><code>Note</code></li> <li><code>Organization</code></li> <li><code>Photo</code></li> <li><code>SipAddress</code></li> </ul> <p>A RawContact may have 0, 1, or more of each of these data kinds;</p> <ul> <li><code>Address</code></li> <li><code>Email</code></li> <li><code>Event</code></li> <li><code>GroupMembership</code></li> <li><code>Im</code></li> <li><code>Phone</code></li> <li><code>Relation</code></li> <li><code>Website</code></li> </ul> <p>The Contacts Provider may or may not enforce these count restrictions. However, the native Contacts app imposes these restrictions. Therefore, this library also imposes these restrictions and disables consumers from violating them.</p> <p>The core library does not explicitly expose count restrictions to consumers. However, it is exposed when integrating custom data via the <code>CustomDataCountRestriction</code>.</p>"},{"location":"entities/about-api-entities/#read-only-data","title":"Read-only data","text":"<p>Any data kind may be set as read-only during insertion of new RawContacts. This is not for general application usage and should really only be used by sync adapters. For example,</p> <pre><code>NewEmail(address = \"read.only@read.com\", isReadOnly = true)\n</code></pre> <p>\u2139\ufe0f For more info, read the in-code documentation of <code>NewDataEntity.isReadOnly</code>.</p> <p>To set the read-only property of all data of a <code>NewRawContact</code> in one function call,</p> <pre><code>newRawContact.setDataAsReadOnly(true)\n</code></pre> <p>Checking if an <code>ExistingDataEntity</code> is read-only requires a separate query. You can use extension functions defined in <code>DataIsReadOnly.kt</code> for this purpose.</p> <p>\u2139\ufe0f For more info, read Convenience functions | Get/set Data read-only.</p> <p>Modifying read-only data locally as a sync adapter is possible by using an instance of  <code>contacts.core.Contacts</code> with the <code>callerIsSyncAdapter</code> flag set to true.</p> <p>\u2139\ufe0f For more info, read Contacts API Setup | Sync adapter operations.</p>"},{"location":"entities/about-api-entities/#data-integrity","title":"Data integrity","text":"<p>There is a section in the official Contacts Provider documentation about \"Data Integrity\"; https://developer.android.com/guide/topics/providers/contacts-provider#DataIntegrity</p> <p>It enumerates four general rules to follow to retain the \"integrity of data\" :D Paraphrasing in terms  of this library, the rules are as follows; </p> <ol> <li>Always add a <code>Name</code> for every <code>RawContact</code>.</li> <li>Always link new Data to their parent <code>RawContact</code>.</li> <li>Change data only for those raw contacts that you own.</li> <li>Always use the constants defined in <code>ContactsContract</code> and its subclasses for authorities,     content URIs, URI paths, column names, MIME types, and TYPE values.</li> </ol> <p>This library follows rules 2 and 4. </p> <p>Rule 1 is ignored because the native Contacts app also ignores that rule. Enforcing this rule means  that a name has to be provided for every <code>RawContact</code>, which is not practical at all. Users should  be able to create contacts with just an email or phone number, without a name. This library follows  the native Contacts app behavior, which also disregards this rule =P</p> <p>Rule 3 is intentionally ignored. There are two kinds of data; </p> <p>a. those that are defined in the Contacts Provider (e.g. name, email, phone number, etc) b. those that are defined by other apps (e.g. custom data from other apps)</p> <p>This library allows modification of native data kinds and custom data kinds. Native data kinds should  obviously be modifiable as it is the entire reason why the Contacts Provider exposes these data kinds to us in the first place. The question is, should this library provide functions for modifying  (insert, update, delete) custom data defined by other apps/services  (e.g. Google Contacts, WhatsApp, etc)? The answer to that will be determined when the time comes to  support custom data from other apps in the future... Probably, yes!</p> <p>For more info, read Integrate custom data from other apps.</p>"},{"location":"entities/about-api-entities/#accessing-contact-data","title":"Accessing contact data","text":"<p>When you have an instance of <code>Contact</code>, you have complete access to data stored in it.</p> <p>To access data of a Contact with only one RawContact,</p> <pre><code>val contact: Contact\nval rawContact: RawContact = contact.rawContacts.first()\nLog.d(\n    \"Contact\",\n    \"\"\"\n        ID: ${contact.id}\n        Lookup Key: ${contact.lookupKey}\n\n        Display name: ${contact.displayNamePrimary}\n        Display name alt: ${contact.displayNameAlt}\n\n        Photo Uri: ${contact.photoUri}\n        Thumbnail Uri: ${contact.photoThumbnailUri}\n\n        Last updated: ${contact.lastUpdatedTimestamp}\n\n        Starred?: ${contact.options?.starred}\n        Send to voicemail?: ${contact.options?.sendToVoicemail}\n        Ringtone: ${contact.options?.customRingtone}\n\n        Addresses: ${rawContact.addresses}\n        Emails: ${rawContact.emails}\n        Events: ${rawContact.events}\n        Group memberships: ${rawContact.groupMemberships}\n        IMs: ${rawContact.ims}\n        Name: ${rawContact.name}\n        Nickname: ${rawContact.nickname}\n        Note: ${rawContact.note}\n        Organization: ${rawContact.organization}\n        Phones: ${rawContact.phones}\n        Relations: ${rawContact.relations}\n        SipAddress: ${rawContact.sipAddress}\n        Websites: ${rawContact.websites}\n    \"\"\".trimIndent()\n    // Photo require separate blocking function calls.\n)\n</code></pre> <p>To access data of a Contact with possibly more than one RawContact, we can use <code>ContactData.kt</code> extensions to make our life easier,</p> <pre><code>val contact: Contact\nLog.d(\n    \"Contact\",\n    \"\"\"\n        ID: ${contact.id}\n        Lookup Key: ${contact.lookupKey}\n\n        Display name: ${contact.displayNamePrimary}\n        Display name alt: ${contact.displayNameAlt}\n\n        Photo Uri: ${contact.photoUri}\n        Thumbnail Uri: ${contact.photoThumbnailUri}\n\n        Last updated: ${contact.lastUpdatedTimestamp}\n\n        Starred?: ${contact.options?.starred}\n        Send to voicemail?: ${contact.options?.sendToVoicemail}\n        Ringtone: ${contact.options?.customRingtone}\n\n        Aggregate data from all RawContacts of the contact\n        -----------------------------------\n        Addresses: ${contact.addressList()}\n        Emails: ${contact.emailList()}\n        Events: ${contact.eventList()}\n        Group memberships: ${contact.groupMembershipList()}\n        IMs: ${contact.imList()}\n        Names: ${contact.nameList()}\n        Nicknames: ${contact.nicknameList()}\n        Notes: ${contact.noteList()}\n        Organizations: ${contact.organizationList()}\n        Phones: ${contact.phoneList()}\n        Relations: ${contact.relationList()}\n        SipAddresses: ${contact.sipAddressList()}\n        Websites: ${contact.websiteList()}\n        -----------------------------------\n    \"\"\".trimIndent()\n    // There are also aggregate data functions that return a sequence instead of a list.\n)\n</code></pre> <p>Each Contact may have more than one of the following data if the Contact is made up of 2 or more RawContacts; name, nickname, note, organization, sip address.</p> <p>To get the list of all data kinds of a particular Contact or RawContact,</p> <pre><code>contact.dataList()\nrawContact.dataList()\n</code></pre> <p>\u2139\ufe0f For more info on how to easily aggregate data from all RawContacts in a Contact, read Convenience functions.</p> <p>\u2139\ufe0f To learn more about the Contact lookup key, read about Contact lookup key vs ID.</p> <p>\u2139\ufe0f To look into the actual Contacts Provider tables, read Debug the Contacts Provider tables.</p>"},{"location":"entities/about-api-entities/#redacting-entities","title":"Redacting entities","text":"<p>All <code>Entity</code> in this library are <code>Redactable</code>, which indicates that there could be sensitive private  user data that could be redacted, for legal purposes. If you are logging contact data in production  to remote data centers for analytics or crash reporting, then it is important to redact certain  parts of every contact's data.</p> <p>For more info, read Redact entities and API input and output in production.</p>"},{"location":"entities/about-api-entities/#syncing-contact-data","title":"Syncing contact data","text":"<p>Syncing contact data, including groups, are done automatically by the Contacts Provider depending on the account sync settings.</p> <p>For more info, read Sync contact data across devices.</p>"},{"location":"entities/about-api-entities/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":""},{"location":"entities/about-api-entities/#automatic-data-kinds-creation","title":"Automatic data kinds creation","text":"<p>An entry of each of the following data kinds are automatically created for all contacts, if not provided;</p> <ul> <li><code>GroupMembership</code>, underlying value defaults to the account's default system group</li> <li><code>Name</code>, underlying value defaults to null</li> <li><code>Nickname</code>, underlying value defaults to null</li> <li><code>Note</code>, underlying value defaults to null</li> </ul> <p>This automatic creation occur automatically in the background (typically after creation) only for RawContacts that are associated with an Account. If a valid account is provided, membership to the (auto add) system group is automatically created immediately by the Contacts Provider at the time of creation. The name, nickname, and note are automatically created at a later time.</p> <p>\u2139\ufe0f Query APIs in this library do not return blanks in results. In this case, the <code>Name</code>, <code>Nickname</code>, and <code>Note</code> will not be included in the RawContact because their primary values are all null. Blanks are also ignored on insert and deleted on update. For more info, read about Blank data.</p> <p>If a valid account is not provided, no entries of the above are automatically created.</p>"},{"location":"entities/about-blank-contacts/","title":"Blank contacts","text":"<p>Blank RawContacts and blank Contacts do not have any rows in the Data table. These do not have any  non-blank data.</p> <p>An entity is blank if the concrete implementation of <code>Entity.isBlank</code> returns true.</p> <p>The Contacts Providers allows for RawContacts that have no rows in the Data table (let's call them \"blanks\") to exist. The native Contacts app does not allow insertion of new RawContacts without at least one data row. It also deletes blanks on update. Despite seemingly not allowing blanks, the native Contacts app shows them. </p> <p>\u2139\ufe0f This library provides APIs that follows the native (AOSP) Contacts app behavior by default but  also allows you to override the default behavior.</p> <p>There are two scenarios where blanks may exist.</p> <ol> <li>Contact with RawContact(s) with no Data row(s).<ul> <li>In this case, the Contact is blank as well as its RawContact(s).</li> </ul> </li> <li>Contact that has RawContact with Data row(s) and a RawContact with no Data row.<ul> <li>In this case, the Contact and the RawContact with Data row(s) are not blank but the RawContact with no Data row is blank.</li> </ul> </li> </ol>"},{"location":"entities/about-blank-contacts/#blanks-in-queries","title":"Blanks in queries","text":"<p>A <code>where</code> clause that uses any fields from the Data table <code>Fields</code> may exclude blanks in the result. There are some joined fields that can be used to match blanks as long as no other fields are in the  where clause...</p> <ul> <li> <p><code>Fields.Contact</code> enables matching blank Contacts. The result will include all RawContact(s)   belonging to the Contact(s), including blank(s). Examples;</p> </li> <li> <p><code>Fields.Contact.Id equalTo 5</code></p> </li> <li><code>Fields.Contact.Id in listOf(1,2,3) and Fields.Contact.DisplayNamePrimary contains \"a\"</code></li> <li> <p><code>Fields.Contact.Options.Starred equalTo true</code></p> </li> <li> <p><code>Fields.RawContact</code> enables matching blank RawContacts. The result will include all Contact(s)    these belong to, including sibling RawContacts (blank and not blank). Examples;</p> </li> <li> <p><code>Fields.RawContact.Id equalTo 5</code></p> </li> <li><code>Fields.RawContact.Id notIn listOf(1,2,3)</code></li> </ul> <p>Blanks will not be included in the results even if they technically should if joined fields  from other tables are in the <code>where</code>. In the below example, matching the <code>Contact.Id</code> to an  existing blank Contact with Id of 5 will yield no results because it is joined by <code>Fields.Email</code>,  which is not a part of <code>Fields.Contact</code>. It should technically return the blank Contact with Id of  5 because the OR operator is used. However, because we internally need to query the Contacts table  to match the blanks, a DB exception will be thrown by the Contacts Provider because  <code>Fields.Email.Address</code> (\"data1\" and \"mimetype\") are columns from the Data table that do not exist  in the Contacts table. The same applies to the <code>Fields.RawContact</code>.</p> <ul> <li><code>Fields.Contact.Id equalTo 5 OR (Fields.Email.Address.isNotNull())</code></li> <li>`Fields.RawContact.Id ... OR (Fields.Phone.Number...)</li> </ul>"},{"location":"entities/about-blank-contacts/#blank-contactsrawcontacts-vs-blank-data","title":"Blank Contacts/RawContacts vs blank Data","text":"<p>Blank RawContacts and blank Contacts do not have any rows in the Data table. These do not have any  non-blank data.</p> <p>Blank data are data entities that have only null, empty, or blank primary value(s).</p> <p>\u2139\ufe0f For more info, read about Blank data.</p>"},{"location":"entities/about-blank-data/","title":"Blank data","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). </p> <p>An entity is blank if the concrete implementation of <code>Entity.isBlank</code> returns true.</p> <p>For example, <code>Email</code> only has one primary value, which is the <code>address</code>...</p> <pre><code>val blankEmail1 = NewEmail()\nval blankEmail2 = NewEmail(\n    address = null\n)\nval blankEmail3 = NewEmail(\n    address = \"\"\n)\nval blankEmail4 = NewEmail(\n    address = \"   \"\n)\nval blankEmail5 = NewEmail(\n    type = EmailEntity.Type.HOME\n)\n\nval emailThatIsNotBlank = NewEmail(\n    address = \"john.doe@gmail.com\"\n)\n</code></pre> <p>Query APIs in this library do not return null, empty, or blank data in results if they somehow  exist in the Contacts Provider database. Insert APIs also ignore blanks and are not inserted. Update APIs deletes blanks.</p> <p>This is the same behavior as the native Contacts app. </p>"},{"location":"entities/about-blank-data/#blank-data-vs-blank-contactsrawcontacts","title":"Blank Data vs blank Contacts/RawContacts","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s).</p> <p>Blank RawContacts and blank Contacts do not have any rows in the Data table. These do not have any  non-blank data.</p> <p>\u2139\ufe0f For more info, read about Blank contacts.</p>"},{"location":"entities/about-contact-lookup-key/","title":"Contact lookup key vs ID","text":"<p>The Contact ID is a number in the Contacts table that serves as the unique identifier for a row in the local Contacts table. These look like any number used as an ID in a database table. For example; <code>4</code>, <code>8</code>, <code>15</code>, <code>16</code>, <code>23</code>, <code>42</code>, ...</p> <p>The Contact lookup key is a string that serves as the unique identifier for an aggregate contact  in the local and remote databases. These look like randomly generated or hashed strings.  For example; <code>2059i4a27289d88a0a4e7</code>, <code>0r62-2A2C2E</code>, ...</p> <p>The official documentation for the Contact lookup key is,</p> <p>\u2139\ufe0f An opaque value that contains hints on how to find the contact if its row id changed as a result of a sync or aggregation.</p> <p>Let's dissect the documentation,</p> <ul> <li>\"if its row id changed\".<ul> <li>This means that a Person's row ID can change!</li> </ul> </li> <li>\"as a result of a sync\".<ul> <li>The Contacts Provider allows sync adapters to modify the local and remote Contacts databases   to ensure that Contact data is synced per user account.</li> </ul> </li> <li>\"as a result of...aggregation\".<ul> <li>Two or more Contacts (along with their constituent RawContacts) can be linked into a single   Contact. When this happens, those Contacts will be consolidated into a single (existing)   Contact row. Unlinking will result in the original Contacts prior to linking to have different   IDs in the Contacts table because the previously deleted row IDs cannot be reused.</li> </ul> </li> </ul> <p>Unlike the Contact ID, the lookup key's components (it can be more than one if there are more than one constituent RawContact) is the same across devices (for contacts that are associated with an Account and are synced). The lookup key points to a person entity rather than just a row  in a table. It is the unique identifier used by local and remote sync adapters to identify an  aggregate contact.</p> <p>\u2139\ufe0f RawContacts do not have a lookup key. It is exclusive to Contacts. However, RawContacts  associated with an Account that have a SyncAdapter typically have a non-null value in the  <code>ContactsContract.SyncColumns.SOURCE_ID</code> column, which is typically used as part of the  parent Contact's lookup key. For example, a RawContact that has a sourceId of 6f5de8460f7f227e  belongs to a Contact that has a lookup key of 2059i6f5de8460f7f227e. Notice that the value of the sourceId is not exactly the same as the value of the lookup key!</p> <p>\u26a0\ufe0f Setting the RawContact's <code>SOURCE_ID</code> to a different value will change the lookup key of the parent Contact, which may break existing shortcuts!</p>"},{"location":"entities/about-contact-lookup-key/#when-to-use-contact-lookup-key-vs-contact-id","title":"When to use Contact lookup key vs Contact ID?","text":"<p>Use the Contact lookup key when you need to save a reference to a Contact and fetch after some period of time.</p> <ul> <li>Creating and loading shortcuts.</li> <li>Saving/restoring activity/fragment instance state.</li> <li>Saving to an external database, preferences, or files.</li> </ul> <p>Use the Contact ID for everything else.</p> <ul> <li>Performing read/write operations in the same function call or session in your app.</li> <li>Performing read/write operations that require ID (e.g. Contact photo and options).</li> </ul> <p>The reason why lookup keys are used as long-term links to contacts is because Contact IDs and the lookup keys themselves may change over time due to linking/unlinking, local contact updates, and syncing adapter operations. Lookup keys provide the ability to retrieve contacts even when its ID or lookup key itself changes. </p>"},{"location":"entities/about-contact-lookup-key/#how-to-get-the-contact-lookup-key","title":"How to get the Contact lookup key?","text":"<p>Lookup keys are included in queries by default but are not required. This means that if you use do not invoke the <code>include</code> function in query APIs, then it will be included in the returned Contacts. However, if you do specify fields to include by invoking the <code>include</code> function, then you must  explicitly specify the lookup key,</p> <pre><code>.include(Fields.Contact.LookupKey)\n</code></pre> <p><code>Contact</code>s instances returned by the query will contain a value in the <code>Contact.lookupKey</code> property.</p> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"entities/about-contact-lookup-key/#how-to-get-contacts-using-lookup-keys","title":"How to get Contacts using lookup keys?","text":"<p>There are several ways to do this...</p>"},{"location":"entities/about-contact-lookup-key/#using-the-lookupquery","title":"Using the <code>LookupQuery</code>","text":"<p>Using this API allows you to get contacts even if their ID or lookup key itself changes.</p> <p>To get a contact using a lookup key,</p> <pre><code>val contacts = lookupQuery.whereLookupKeyMatches(lookupKey).find()\n</code></pre> <p>For optimization purposes, include the last known ID,</p> <pre><code>val contacts = lookupQuery.whereLookupKeyWithIdMatches(LookupQuery.LookupKeyWithId(lookupKey, contactId)).find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts by lookup key.</p>"},{"location":"entities/about-contact-lookup-key/#using-the-query-api","title":"Using the <code>Query</code> API","text":"<p>You may also use the <code>Query</code> API to achieve a similar result. However, in this case, using the  Contact ID is necessary in order to ensure the lookup succeeds (in case the lookup key changes).</p> <p>Use the <code>decomposedLookupKeys</code> functions in <code>contacts.core.util.ContactLookupKey.kt</code> to get contacts  by lookup key and id,</p> <pre><code>val contacts = query.where { (decomposedLookupKeys(lookupKey) whereOr { Contact.LookupKey contains it })?.or(Contact.Id equalTo id) }.find()\n</code></pre> <p>Or use the <code>lookupKeyIn</code> extensions in <code>contacts.core.util.ContactLookupKey.kt</code> to get contacts by lookup key and id,</p> <pre><code>val contacts = query.where { Contact.lookupKeyIn(lookupKeys)?.or(Contact.Id equalTo id) }.find()\n</code></pre> <p>\u2139\ufe0f For an explanation on why you should use those functions instead of the lookup key directly, read the function documentation.</p> <p>\u26a0\ufe0f Queries that only use the lookup key may fail to get a contact whose lookup key has changed. On the other hand, queries that only use the Contact ID may fail to get a contact whose ID has changed. You must use both lookup key and ID when using the <code>Query</code> API. If you only have the  lookup key, use the <code>LookupQuery</code> API.</p> <p>\u2139\ufe0f Note that if the lookup key or id is a reference to a linked Contact (a Contact with two or more constituent RawContacts), and the linked Contact is unlinked, then the query will return multiple Contacts.</p> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p>"},{"location":"entities/about-contact-lookup-key/#updating-local-device-only-contacts-and-the-lookup-key","title":"Updating local, device-only contacts and the lookup key","text":"<p>The ContactsProvider may assign a different value to the Contact lookup key if it's constituent RawContacts that are not associated with an Account (local, unsynced, source id is null) gets its primary display name source updated. Display name sources are specified in <code>ContactsContract.DisplayNameSources</code>. In order of increasing priority; email, phone, organization, nickname, and name.</p> <p>However, the IDs remain the same.</p> <p>Therefore, it is still possible to get the contacts after updating using IDs.</p>"},{"location":"entities/about-contact-lookup-key/#linkingunlinking-contacts-and-the-lookup-key","title":"Linking/unlinking contacts and the lookup key","text":"<p>Linking and unlinking RawContacts will cause the lookup key to change as the RawContact's source ids get combined and separated respectively. However, the intrinsic values contained within the lookup  key remains the same. The Contact IDs may also change as Contacts get deleted and created when  linking and unlinking respectively.</p> <p>Therefore, it is still possible to get the contacts after linking/unlinking using the lookup key.</p> <p>For example, using the default AOSP Contacts app or the Google Contacts app...</p> <ol> <li>View a contact's details.</li> <li>Create a shortcut to it in the home screen (launcher).<ul> <li>This shortcut uses the Contact lookup key (not the ID) to form a lookup URI.</li> </ul> </li> <li>Link the contact to another contact.</li> <li>Tap the shortcut in the home screen (launcher).</li> <li>Unlink the contact.</li> <li>Tap the shortcut in the home screen (launcher).</li> </ol> <p>In both cases, the shortcut successfully opens the correct aggregate Contact.</p> <p>\u2139\ufe0f For more info on linking/unlinking, read Link unlink Contacts.</p>"},{"location":"entities/about-contact-lookup-key/#moving-rawcontacts-between-accounts-and-the-lookup-key","title":"Moving RawContacts between accounts and the lookup key","text":"<p>Moving a RawContact to a different Account will cause the lookup key and IDs to change.</p> <p>\u2139\ufe0f Note that in these cases, the changes to the lookup key will only be applied after the Contacts Provider and sync adapters sync the changes. This means that the local changes are not immediately applied. For more info, read Sync contact data across devices.</p> <p>Therefore, it is no longer possible to get the contacts after moving using the lookup key or IDs.</p> <p>For example, using the default AOSP Contacts app or the Google Contacts app...</p> <ol> <li>View a contact's details.</li> <li>Create a shortcut to it in the home screen (launcher).<ul> <li>This shortcut uses the Contact lookup key (not the ID) to form a lookup URI.</li> </ul> </li> <li>Move the RawContact to a different Account.</li> <li>Tap the shortcut in the home screen (launcher).</li> </ol> <p>Both Contacts apps will say that the Contact no longer exist or has been removed. This is not a bug. It is expected behavior due to the way the Contacts Provider works.</p> <p>\u2139\ufe0f For more info, read Move RawContacts across Accounts.</p>"},{"location":"entities/about-contact-lookup-key/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":"<p>\u2139\ufe0f The following section are note from developers of this library for other developers. It is copied from the DEV_NOTES. You may still read the following as a consumer of the library in case you need deeper insight.</p> <p>The <code>Contacts._ID</code> is the unique identifier for the row in the Contacts table. The <code>Contacts.LOOKUP_KEY</code> is the unique identifier for an aggregate Contact (a person). The <code>_ID</code> may change due to aggregation and sync. The same goes for the <code>LOOKUP_KEY</code> but unlike the <code>ID</code> it may  still be used to find the aggregate contact.</p> <p>Unlike the Contact ID, the lookup key is the same across devices (for contacts that are associated  with an Account and are synced).</p> <p>\u2139\ufe0f The following investigation was done with a much larger data set. I has been simplified here  for brevity.</p> <p>Let's take a look at the following Contacts and RawContacts table rows,</p> <pre><code>#### Contacts table\nContact id: 55, lookupKey: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50, displayNamePrimary: Contact With Local RawContact\nContact id: 56, lookupKey: 2059i6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n#### RawContacts table\nRawContact id: 55, contactId: 55, sourceId: null, displayNamePrimary: Contact With Local RawContact\nRawContact id: 56, contactId: 56, sourceId: 6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n</code></pre> <p>There are two Contacts each having one RawContact.</p> <p>Notice that the lookup keys are a bit different.</p> <ul> <li>Contact With Local RawContact: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50</li> <li>Contact With Synced RawContact: 2059i6f5de8460f7f227e</li> </ul> <p>The Contact with synced RawContact uses the RawContact's <code>SOURCE_ID</code> as part of its lookup key. Notice that the <code>sourceId</code> value (i.e. 6f5de8460f7f227e) is NOT exactly the same as the <code>lookupKey</code> (i.e. 2059i6f5de8460f7f227e)!</p> <p>The Contact with unsynced, device-only, local RawContact has a much longer (or shorter e.g. 0r62-2A2C2E) lookup key and starts with \"0r-\" and all characters after it are in uppercase. The other thing to notice is that the \"55\" in \"0r55-\" seems to be the same as the RawContact ID (I did a bit more experiments than what is written in these notes to confirm that it is indeed the RawContact ID and not the Contact ID). We probably don't need to worry about these details though the Contacts Provider probably uses these things internally. We also should not rely on it. <p>In any case, it is safe to assume that the Contact lookup key is a reference to a RawContact (or reference to more than one constituent RawContact when multiple RawContacts are linked). Again, an internal Contacts Provider detail we should not rely on BUT is probably relevant when implementing sync adapters.</p> <p>When we link the two, we get...</p> <pre><code>Contact id: 55, lookupKey: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50.2059i6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n#### RawContacts table\nRawContact id: 55, contactId: 55, sorceId: null, displayNamePrimary: Contact With Local RawContact\nRawContact id: 56, contactId: 55, sourceId: 6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n</code></pre> <p>Notice,</p> <ul> <li>Contact with ID 56 has been deleted.</li> <li>Contact with ID 55 still exist with the lookup keys of both Contact 55 and 56 combined separated by a \".\".<ul> <li>This holds true in cases where two or more local-only or non-local-only RawContacts are linked.</li> </ul> </li> <li>RawContacts remain unchanged except reference to Contact 56 has been replaced with 55.</li> <li>The primary display name of Contact 55 came from RawContact 55 prior to the link and now comes   from RawContact 56 after the link.<ul> <li>This primary name resolution is probably irrelevant so pay no attention to it.</li> </ul> </li> </ul> <p>The most important part to notice is that the lookup keys get combined.</p> <p>Given that the lookup key of the deleted Contact 56 still lives on, it is possible to get the linked Contact 55 using the lookup key of Contact 56 using our standard query APIs!</p> <pre><code>.where { Contact.LookupKey contains lookupKey }\n</code></pre> <p>The above is correct as long as these assumptions hold true;</p> <ul> <li>the lookup key is unique</li> <li>there is no lookup key that can contain a shorter lookup key<ul> <li>the Contact ID fails this test because a smaller number is contained in a larger number</li> <li>synced contacts have shorter lookup keys than local contacts. However, local contacts'   lookup keys are capitalized whereas synced contact are not. Also, there seems to be other   differences in pattern between long and short lookup keys. It should be safe to make this   assumption.</li> </ul> </li> </ul> <p>Until the community finds that this assumption is flawed, we'll assume that it is true! </p> <p>When we unlink, we get...</p> <pre><code>#### Contacts table\nContact id: 55, lookupKey: 2059i6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\nContact id: 58, lookupKey: 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50, displayNamePrimary: Contact With Local RawContact\n#### RawContacts table\nRawContact id: 55, contactId: 58, sourceId: null, displayNamePrimary: Contact With Local RawContact\nRawContact id: 56, contactId: 55, sourceId: 6f5de8460f7f227e, displayNamePrimary: Contact With Synced RawContact\n</code></pre> <p>Notice,</p> <ul> <li>A new Contact row with ID of 58 is created.</li> <li>The lookup keys are separated and distributed between Contact 55 and 58.</li> <li>RawContact 55 Contact reference has been set to Contact 58.</li> </ul> <p>Let's compare the Contact-RawContact relationship before and after linking and then unlinking.</p> Contact ID Lookup Key RawContact.Contact ID Before 55,56 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50,2059i6f5de8460f7f227e 55,56 After 55,58 2059i6f5de8460f7f227e,0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50 58,55 <p>Notice,</p> <ul> <li>Contact ID 55 swapped lookup keys with the former Contact 56 (now 58).</li> <li>RawContact ID 55 swapped Contact reference with RawContact 56.</li> </ul> <p>The Contact IDs and lookup keys got shuffled BUT the Contact-RawContact relationship remains the same if using the lookup keys as point of reference! Here is another way to look at the table, using the lookup key as the constant...</p> Lookup Key Before After 0r55-2E4644502A2E50563A503840462E2A404C2A562E4644502A2E50 Contact 55,RawContact 55 Contact 58,RawContact 55 2059i6f5de8460f7f227e Contact 56,RawContact 56 Contact 55,RawContact 56 <p>Notice that the indirect relationship between the lookup key and RawContacts remains the same before and after the link-unlink even though the Contact IDs changed.</p> <p>\u2139\ufe0f As mentioned earlier in this section, the \"55\" in \"0r55-\" seems to be referencing the  RawContact ID. In other words, since local RawContacts are not synced or tracked in a remote  database where Contacts -&gt; RawContacts mappings exist, the Contacts Provider most likely uses this \"0r-\" pattern to make the connection. This is not really relevant for us as we are not relying on this mechanism. I'm just pointing out my observations, which could be incorrect. <p>This means that...</p> <ul> <li>If users of this library saved a reference Contact ID 55, then a link-unlink (or sync adapter   functions) occur.<ul> <li>Getting Contact by ID 55 will result in the RawContact-Data of the former Contact 56 to be   returned. This is a bug! Same goes if users saved a reference to Contact ID 56.</li> </ul> </li> <li>If users of this library saved a reference to the lookup keys, then a link-unlink (or sync adapter   functions) occur.<ul> <li>Getting Contact by lookup key will result in the correct RawContact-Data to be returned.</li> </ul> </li> </ul> <p>So when to use Contact ID vs lookup key?</p> <ul> <li>Lookup key: for a reference to a Contact that needs to be loaded after some period of time.<ul> <li>Creating and loading shortcuts.</li> <li>Saving/restoring activity/fragment instance state.</li> <li>Saving to an external database, preferences, or files.</li> </ul> </li> <li>ID: for everything else.<ul> <li>Performing read/write operations in the same function call or session in your app.</li> <li>Performing read/write operations that require ID (e.g. Contact photo and options).</li> </ul> </li> </ul> <p>Another thing to check is what happens when associating a local RawContact to an Account (move from device to Account) and vice versa. Is the lookup key of the Contact affected? Yes. The Contact, RawContacts, and Data rows have been deleted and new rows have been created to replace them! This means that all IDs have changed. The Contact lookup key and the RawContacts source ID also changed.</p> <p>Local contact's lookup key may change but row ID remain the same!</p> <p>The ContactsProvider may assign a different value to the Contact lookup key if it's constituent RawContacts that are not associated with an Account (local, unsynced, source id is null) gets its primary display name source updated. Display name sources are specified in <code>ContactsContract.DisplayNameSources</code>. In order of increasing priority; email, phone, organization, nickname, and name.</p> <p>This suggests that the lookup key for local contacts depends on the primary display name. It  probably uses its hashed value as the value of the lookup key or something like that.</p> <p>To account for this scenario, ContactsContract provides <code>Contacts.CONTENT_LOOKUP_URI</code> and  <code>getLookupUri</code>...</p> <pre><code>/**\n * A content:// style URI for this table that should be used to create\n * shortcuts or otherwise create long-term links to contacts. This URI\n * should always be followed by a \"/\" and the contact's {@link #LOOKUP_KEY}.\n * It can optionally also have a \"/\" and last known contact ID appended after\n * that. This \"complete\" format is an important optimization and is highly recommended.\n * &lt;p&gt;\n * As long as the contact's row ID remains the same, this URI is\n * equivalent to {@link #CONTENT_URI}. If the contact's row ID changes\n * as a result of a sync or aggregation, this URI will look up the\n * contact using indirect information (sync IDs or constituent raw\n * contacts).\n * &lt;p&gt;\n * Lookup key should be appended unencoded - it is stored in the encoded\n * form, ready for use in a URI.\n */\npublic static final Uri CONTENT_LOOKUP_URI = Uri.withAppendedPath(CONTENT_URI, \"lookup\");\n\n/**\n * Build a {@link #CONTENT_LOOKUP_URI} lookup {@link Uri} using the\n * given {@link ContactsContract.Contacts#_ID} and {@link #LOOKUP_KEY}.\n * &lt;p&gt;\n * Returns null if unable to construct a valid lookup URI from the\n * provided parameters.\n */\npublic static Uri getLookupUri(long contactId, String lookupKey) {\n    if (TextUtils.isEmpty(lookupKey)) {\n        return null;\n    }\n    return ContentUris.withAppendedId(Uri.withAppendedPath(Contacts.CONTENT_LOOKUP_URI, lookupKey), contactId);\n}\n</code></pre>"},{"location":"entities/about-local-contacts/","title":"Local (device-only) contacts","text":"<p>Contacts, or more specifically RawContacts, that are not associated with an <code>android.accounts.Account</code> are local to each device and will not be synced across devices.</p> <p>This means that local RawContacts inserted, updated, or deleted will NOT be synced on any device or remote service as it is not associated with any account.</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p>"},{"location":"entities/about-local-contacts/#moving-a-local-rawcontact-to-an-account","title":"Moving a local RawContact to an Account","text":"<p>Local RawContacts (no Account) can be moved to an Account to enable syncing.</p> <p>For more info, read Move RawContacts across Accounts.</p>"},{"location":"entities/about-local-contacts/#adding-an-account-to-the-device","title":"Adding an Account to the device","text":"<p>Depending on the API level, the Contacts Provider behaves differently when the user adds an account to the device.</p> <p>Lollipop (API 22) and below</p> <p>When an Account is added, from a state where no accounts have yet been added to the system, the Contacts Provider automatically sets all of the null <code>accountName</code> and <code>accountType</code> in the RawContacts table to that Account's name and type.</p> <p>RawContacts inserted without an associated account will automatically get assigned to an account if there are any available. This may take a few seconds, whenever the Contacts Provider decides to do it. Dissociating RawContacts from Accounts will result in the Contacts Provider associating those back to an Account.</p> <p>Marshmallow (API 23) and above</p> <p>The Contacts Provider no longer associates local RawContacts to an account when an account is or becomes available. Local contacts remain local.</p> <p>Account removal</p> <p>Removing the Account will remove all of the associated rows in the RawContact, Data, and Groups  tables locally. This includes user Profile data in those tables.</p> <p>\u2139\ufe0f When all RawContacts of a Contact is removed, the Contact is also automatically removed by the  Contacts Provider.</p>"},{"location":"entities/about-local-contacts/#data-kinds-account-restrictions","title":"Data kinds Account restrictions","text":"<p>The AOSP Contacts app hides the following UI fields when inserting or updating local raw contacts,</p> <ul> <li><code>GroupMembership</code></li> <li><code>Event</code></li> <li><code>Relation</code></li> </ul> <p>\u26a0\ufe0f Prior to version 0.3.0, the  above data kinds were ignored during insert and update operations. Subsequent versions no longer  enforces this behavior for the following reasons;</p> <ul> <li>Google Contacts app allows these data kinds for local RawContacts</li> <li>The Contacts Provider does not enforce these Account restrictions. </li> </ul> <p>It is up to applications to impose such restrictions if so desired.</p>"},{"location":"entities/about-local-contacts/#samsung-and-xiaomi-phone-contacts","title":"Samsung and Xiaomi Phone contacts","text":"<p>In most flavors of Android, a local (device-only) RawContact have null Account name and type in the RawContacts table. However, Samsung phones running OneUI use <code>vnd.sec.contact.phone</code> to fill the Account name and type in the RawContacts table for local RawContacts (referred to as \"Phone\" in the  Samsung Contacts app),</p> <pre><code>accountName: vnd.sec.contact.phone, accountType: vnd.sec.contact.phone\n</code></pre> <p>The <code>vnd.sec.contact.phone</code> does NOT refer to an actual <code>android.accounts.Account</code>. It is not  returned by the <code>android.accounts.AccountManager</code>. </p> <p>In short, Samsung devices use <code>vnd.sec.contact.phone</code> instead of null for local RawContacts.</p> <p>In Samsung devices, RawContacts that are inserted with a null account will, immediately or at a  later time, be automatically associated with the <code>vnd.sec.contact.phone</code>.</p> <p>In order to query for local RawContacts on Samsung devices, you do not have to do anything  different. Just pass in null as usual;</p> <pre><code>query.accounts(null)\n</code></pre> <p>When a null is provided, all query APIs will internally additionally add  <code>Account(\"vnd.sec.contact.phone\", \"vnd.sec.contact.phone\")</code>.</p> <p>\u26a0\ufe0f This internal fix is available as of version 0.2.4. Prior versions will require you to pass in <code>Account(\"vnd.sec.contact.phone\", \"vnd.sec.contact.phone\")</code> in addition to <code>null</code> when using <code>accounts</code> for matching local contacts.</p> <p>As for Xiaomi phones running MIUI, the same thing applies as discussed above with Samsung phones. The only difference is that for Xiaomi phones the account name and type have the following values,</p> <pre><code>accountName: default, accountType: com.android.contacts.default\n</code></pre> <p>In order to query for local RawContacts on Xiaomi devices, you do not have to do anything different. Just pass in null as usual;</p> <pre><code>query.accounts(null)\n</code></pre> <p>When a null is provided, all query APIs will internally additionally add <code>Account(\"default\", \"com.android.contacts.default\")</code>.</p> <p>\u26a0\ufe0f This internal fix is available as of version 0.3.1. Prior versions will require you to pass in <code>Account(\"default\", \"com.android.contacts.default\")</code> in addition to <code>null</code> when using <code>accounts</code> for matching local contacts.</p>"},{"location":"entities/redact-apis-and-entities/","title":"Redact entities and API input and output in production","text":"<p>All of the entities and Create (Query), Read (Query), Update, and Delete APIs  (a.k.a CRUD APIs) provided in this library are <code>Redactable</code>.</p> <p>Redactables indicates that there could be sensitive private user data that could be redacted, for  legal purposes such as upholding GDPR guidelines. If you are logging  contact data in production to remote data centers for analytics or crash reporting, then it is  important to redact certain parts of every contact's data.</p> <p>\u2139\ufe0f For more info on logging, read Log API input and output.</p>"},{"location":"entities/redact-apis-and-entities/#disclaimer-this-is-not-legal-advice","title":"DISCLAIMER: This is NOT legal advice!","text":"<p>This library is written and maintained purely by software developers with no official education or certifications in any facet of law. Please review the redacted outputs of the APIs and entities within this library with your legal team! This library will not be held liable for any privacy violations!</p> <p>With that out of the way, let's move on to the good stuff =)</p>"},{"location":"entities/redact-apis-and-entities/#redactable-entities","title":"Redactable entities","text":"<p>All <code>Entity</code> in this library are <code>Redactable</code>.</p> <p>For example,</p> <pre><code>Contact: id=1, email { address=\"vestrel00@gmail.com\" }, phone { number=\"(555) 555-5555\" }, etc\n</code></pre> <p>when redacted,</p> <pre><code>Contact: id=1, email { address=\"*******************\" }, phone { number=\"************\" }, etc\n</code></pre> <p>Notice that all characters in private user data are replaced with \"*\". Redacted strings are not as useful as the non-redacted counterpart. However, we still have the following valuable information;</p> <ul> <li>is the string null or not?</li> <li>how long is the string?</li> </ul> <p>Database row IDs (and typically non-string properties) do not have to be redacted unless they  contain sensitive information.</p> <p>The <code>redactedCopy</code> function will return an actual copy of the entity, except with sensitive data redacted. In addition to logging, this will allow consumers to do cool things like implementing a redacted contact view! Imagine a button that the user can press to redact everything in their contact form. Cool? Yes! Useful? Maybe?</p> <p>Redacted copies have <code>isRedacted</code> set to true to indicate that data has already been redacted.</p>"},{"location":"entities/redact-apis-and-entities/#redactable-apis","title":"Redactable APIs","text":"<p>All Create (Query), Read (Query), Update, and Delete APIs (a.k.a CRUD APIs) provided in this library are <code>Redactable</code>.</p> <p>For example,</p> <pre><code>Query {\n    rawContactsWhere: (account_name LIKE 'test@gmail.com' ESCAPE '\\') AND (account_type LIKE 'com.google' ESCAPE '\\')\n    where: data1 LIKE '%@gmail.com%' ESCAPE '\\' AND mimetype = 'vnd.android.cursor.item/email_v2'\n    isRedacted: false\n    // the rest is omitted for brevity\n}\nQuery.Result {\n    Number of contacts found: 2\n    First contact: Contact(\n        id=46, \n        rawContacts=[\n            RawContact(\n                id=45, \n                contactId=46, \n                addresses=[Address(id=329, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=WORK, label=null, formattedAddress=1200 Park Ave, street=1200 Park Ave, poBox=null, neighborhood=null, city=null, region=null, postcode=null, country=null, isRedacted=false)], \n                emails=[\n                    Email(id=318, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=WORK, label=null, address=buzz.lightyear@pixar.com, isRedacted=false), \n                    Email(id=319, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=HOME, label=null, address=buzz@lightyear.net, isRedacted=false)\n                ], \n                events=[\n                    Event(id=317, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=BIRTHDAY, label=null, date=EventDate(year=1995, month=10, dayOfMonth=22, isRedacted=false), isRedacted=false), \n                    Event(id=320, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=ANNIVERSARY, label=null, date=EventDate(year=2022, month=0, dayOfMonth=1, isRedacted=false), isRedacted=false)\n                ], \n                // the rest is omitted for brevity\n            )\n        ]\n    )\n    isRedacted: false\n}\n</code></pre> <p>when redacted,</p> <pre><code>Query {\n    rawContactsWhere: (account_name LIKE '*******************' ESCAPE '\\') AND (account_type LIKE '**********' ESCAPE '\\')\n    where: data1 LIKE '%**********%' ESCAPE '\\' AND mimetype = 'vnd.android.cursor.item/email_v2'\n    isRedacted: true\n    // the rest is omitted for brevity\n}\nQuery.Result {\n    Number of contacts found: 2\n    First contact: Contact(\n        id=46, \n        rawContacts=[\n            RawContact(\n                id=45, \n                contactId=46, \n                addresses=[Address(id=329, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=WORK, label=null, formattedAddress=*************, street=*************, poBox=null, neighborhood=null, city=null, region=null, postcode=null, country=null, isRedacted=true)], \n                emails=[\n                    Email(id=318, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=WORK, label=null, address=************************, isRedacted=true), \n                    Email(id=319, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=HOME, label=null, address=******************, isRedacted=true)\n                ], \n                events=[\n                    Event(id=317, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=BIRTHDAY, label=null, date=EventDate(year=null, month=0, dayOfMonth=1, isRedacted=true), isRedacted=true), \n                    Event(id=320, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=ANNIVERSARY, label=null, date=EventDate(year=null, month=0, dayOfMonth=1, isRedacted=true), isRedacted=true)], \n                ],\n                // the rest is omitted for brevity\n            )\n        ]\n    )\n    isRedacted: true\n}\n</code></pre>"},{"location":"entities/redact-apis-and-entities/#insert-and-update-operations-on-redacted-entities","title":"Insert and update operations on redacted entities","text":"<p>This library will not stop you from using redacted copies in insert and update APIs. You could build some cool stuff using it. I'll let your imagination take over from here =)</p>"},{"location":"entities/redact-apis-and-entities/#logging-api-input-and-output","title":"Logging API input and output","text":"<p>All terminal API functions such as <code>find</code> and <code>commit</code> can be automatically logged prior and post  execution to get visibility on input and output. All log outputs are also redactable!</p> <p>For more info on logging, read Log API input and output.</p>"},{"location":"entities/redact-apis-and-entities/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":"<p>We cannot prevent users of this API from violating privacy laws if they really want to. BUT, the  library should provide consumers an easy way to be GDPR-compliant! This is not necessary for all  libraries to implement but this library deals with sensitive, private user data. Therefore, we need  to be extra careful and provide consumers a GDPR-compliant way to log everything in this library!</p>"},{"location":"entities/sync-contact-data/","title":"Sync contact data across devices","text":"<p>Syncing contact data, including groups, are done automatically by the Contacts Provider depending on the account sync settings. You can typically find these account sync settings via Settings -&gt; Accounts -&gt;  -&gt; Account sync -&gt; \"Contacts\". Of course, in addition to having Contacts syncing enabled in settings, you must also have network connection to sync between the device and remote servers. <p></p> <p>When you have Contacts syncing enabled, as long as the <code>android.accounts.Account</code> has active sync adapters and remote services and you have network connection, data belonging to that account (e.g. \"vestrel00@gmail.com\" is a Google account) are synced across devices and online. This means that any contacts you create, update, or delete will be synced on all devices and services associated with that account.</p> <p>\u2139\ufe0f Besides Google Accounts, there is also Samsung, Xiaomi, Yahoo, MSN/Hotmail, etc.</p> <p>Syncing contacts across devices is possible with sync adapters and Contacts' lookup key, more  specifically the RawContact's source ID.</p> <p>\u2139\ufe0f For more info, read about Contact lookup key vs ID.</p>"},{"location":"entities/sync-contact-data/#adding-or-removing-accounts","title":"Adding or removing Accounts","text":"<p>When an Account is added to the system and Contacts syncing is enabled and there is network  connection, the Contacts Provider will automatically fetch all Contacts, RawContacts, Data, and Groups that belong to that Account.</p> <p>Similarly, when an Account is removed from the system though regardless of Contacts syncing enabled or network availability, the Contacts Provider will automatically remove Contacts, RawContacts,  Data, and Groups that belong to that Account.</p>"},{"location":"entities/sync-contact-data/#only-contacts-that-are-associated-with-an-account-are-synced","title":"Only contacts that are associated with an Account are synced","text":"<p>More specifically, RawContacts that are not associated with an Account (local, device-only) are not synced. </p> <p>\u2139\ufe0f For more info, read about Local (device-only) contacts.</p> <p>Syncing is account specific (and therefore specific to RawContacts as a Contact may have one or more constituent RawContacts from different Accounts), which is why you must turn on Contact syncing in the system settings.</p> <p>For example, data belonging to a RawContact that is associated with a Google account (e.g. Gmail) will be available anywhere the Google account is used; in any Android or iOS device, a web browser, etc... Data is synced by Google\u2019s sync adapters between devices and their remote servers. Syncing depends on the account sync settings, which can be configured in the system settings app and possibly through some remote configuration.</p> <p>Here is an example of a newly created RawContact associated with a <code>com.google</code> Account prior  to syncing,</p> <pre><code>#### Contacts table\nContact id: 31, lookupKey: 2059r31-38462A40563E3A4436\n#### RawContacts table\nRawContact id: 31, contactId: 31, sourceId:null\n</code></pre> <p>After sync,</p> <pre><code>#### Contacts table\nContact id: 31, lookupKey: 2059i7b975d4a8fec684e\n#### RawContacts table\nRawContact id: 31, contactId: 31, sourceId:7b975d4a8fec684e\n</code></pre> <p>For a RawContact that is not associated with an Account (null),</p> <pre><code>#### Contacts table\nContact id: 32, lookupKey: 0r32-3032543A2E324644405A\n#### RawContacts table\nRawContact id: 32, contactId: 32, sourceId:null\n</code></pre>"},{"location":"entities/sync-contact-data/#when-are-changes-synced","title":"When are changes synced?","text":"<p>In general, the Contacts Provider and the registered sync adapters are responsible for triggering  sync events as long as Contacts sync is enabled for the Account in the system settings. </p> <p>You can manually trigger a sync through the system sync settings. Some events that will probably  trigger a sync are;</p> <ul> <li>Getting network connection from a state where there was no network connection (offline -&gt; online).</li> <li>Adding an Account.</li> <li>Removing an Account.</li> </ul> <p>Until changes are synced, local changes will not take effect. Some examples are;</p> <ul> <li>RawContact rows are marked for deletion but remain until synced.</li> <li>Group rows are marked for deletion but remain until synced.</li> <li>Newly created RawContacts may have a null or temporary source ID.</li> <li>New lookup key is not assigned after associating a local RawContact to an Account.</li> </ul>"},{"location":"entities/sync-contact-data/#some-custom-data-provided-in-this-library-are-not-synced","title":"Some custom data provided in this library are not synced","text":"<p>The <code>Gender</code>, <code>HandleName</code>, <code>Pokemon</code>, <code>RpgStats</code>, and <code>RpgProfession</code> custom data will not be  synced because they are not account specific and they have no sync adapters and no remote service  to interface with.</p> <p>\u2139\ufe0f For more info, read Integrate custom data.</p>"},{"location":"entities/sync-contact-data/#custom-data-from-other-apps-may-be-synced","title":"Custom data from other apps may be synced","text":"<p>This library does not sync contact data that belongs to other apps and services. For example,  Google Contacts, WhatsApp, and other apps define their own set of custom data  that their own sync adapters sync with their own remote services, which requires authentication.</p> <p>\u2139\ufe0f For more info, read Integrate custom data from other apps.</p>"},{"location":"entities/sync-contact-data/#this-library-does-not-provide-sync-adapters","title":"This library does not provide sync adapters","text":"<p>This library does not have any APIs related to syncing. It is considered out of scope of this library as it requires access to remote databases and account-specific data. Let's talk about it though since it is good to know how it works if you just want more insight.</p> <p>https://developer.android.com/guide/topics/providers/contacts-provider#SyncAdapters</p> <p>The Contacts Provider is specifically designed for handling synchronization of contacts data between a device and an online service. This allows users to download existing data to a new device and upload existing data to a new account. Synchronization also ensures that users have the latest data at hand, regardless of the source of additions and changes. Another advantage of synchronization is that it makes contacts data available even when the device is not connected to the network.</p> <p>Although you can implement synchronization in a variety of ways, the Android system provides a plug-in synchronization framework that automates the following tasks:</p> <ul> <li>Checking network availability.</li> <li>Scheduling and executing synchronization, based on user preferences.</li> <li>Restarting synchronizations that have stopped.</li> </ul> <p>To use this framework, you supply a sync adapter plug-in. Each sync adapter is unique to a service and content provider, but can handle multiple account names for the same service. The framework also allows multiple sync adapters for the same service and provider.</p> <p>This library does not provide any sync adapters. Instead, it relies on existing sync adapters to do the syncing. Sync adapters and syncing are really out of scope of this library. Syncing is its own thing that typically happens outside of an application UI. This library is focused on Create, Read, Update, and Delete (CRUD) operations on native and custom data to and from the local database. Syncing the local database to and from a remote database in the background is a totally different story altogether.</p> <p>\u2139\ufe0f For more info, read Integrate custom data.</p>"},{"location":"groups/delete-groups/","title":"Delete groups","text":"<p>This library provides the <code>GroupsDelete</code> API that allows you to delete existing Groups.</p> <p>An instance of the <code>GroupsDelete</code> API is obtained by,</p> <pre><code>val delete = Contacts(context).groups().delete()\n</code></pre>"},{"location":"groups/delete-groups/#a-basic-delete","title":"A basic delete","text":"<p>To delete a set of existing groups,</p> <pre><code>val deleteResult = Contacts(context)\n    .groups()\n    .delete()\n    .groups(existingGroups)\n    .commit()\n</code></pre> <p>To delete a set of existing groups using IDs,</p> <pre><code>val deleteResult = Contacts(context)\n    .groups()\n    .delete()\n    .groupsWithId(1, 2, 3)\n    .commit()\n</code></pre>"},{"location":"groups/delete-groups/#an-advanced-delete","title":"An advanced delete","text":"<p>You may specify a matching criteria, like in queries, that will delete all matching groups,</p> <pre><code>val deleteResult = delete\n    .groupsWhere { AccountType equalTo \"com.google\" }\n    .commit()\n</code></pre>"},{"location":"groups/delete-groups/#executing-the-delete","title":"Executing the delete","text":"<p>To execute the delete,</p> <pre><code>.commit()\n</code></pre> <p>To delete all given groups in a single atomic transaction,</p> <pre><code>.commitInOneTransaction()\n</code></pre> <p>The call to <code>commitInOneTransaction</code> will only succeed if ALL given groups are successfully deleted. If one delete fails, the entire operation will fail and everything will be reverted prior to the delete operation. In contrast, <code>commit</code> allows for some deletes to succeed and some to fail.</p>"},{"location":"groups/delete-groups/#handling-the-delete-result","title":"Handling the delete result","text":"<p>The <code>commit</code> and <code>commitInOneTransaction</code> functions returns a <code>Result</code>,</p> <p>To check if all deletes succeeded,</p> <pre><code>val allDeletesSuccessful = deleteResult.isSuccessful\n</code></pre> <p>To check if a particular delete succeeded,</p> <pre><code>val deleteSuccessful = deleteResult.isSuccessful(group)\nval deleteSuccessful = deleteResult.isSuccessful(group.id)\n</code></pre> <p>To check if a particular advanced delete managed to delete at least one matching group,</p> <pre><code>val where = GroupsFields.AccountType equalTo \"com.google\"\nval deleteResult = delete.groupsWhere(where).commit()\nval advancedDeleteSuccessful = deleteResult.isSuccessful(where)\n</code></pre>"},{"location":"groups/delete-groups/#performing-the-delete-and-result-processing-asynchronously","title":"Performing the delete and result processing asynchronously","text":"<p>Deletes are executed when the <code>commit</code> or <code>commitInOneTransaction</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"groups/delete-groups/#performing-the-delete-with-permission","title":"Performing the delete with permission","text":"<p>Deletes require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the delete will do nothing and return a failed result.</p> <p>To perform the delete with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"groups/delete-groups/#read-only-groups","title":"Read-only Groups","text":"<p>Groups created by the system are typically read-only. You cannot delete them, even if you try! The Contacts Provider typically have the following system groups (for standard Google Accounts),</p> <ul> <li>systemId: Contacts, title: My Contacts</li> <li>systemId: null, title: Starred in Android</li> <li>systemId: Friends, title: Friends</li> <li>systemId: Family, title: Family</li> <li>systemId: Coworkers, title: Coworkers</li> </ul> <p>The above list may vary per Account and/or flavor of Android.</p> <p>If you are implementing a sync adapter, you may be able to delete read-only groups associated with the Account that your sync adapter works with. For more info, read  Contacts API Setup | Sync adapter operations.</p>"},{"location":"groups/delete-groups/#group-memberships-are-automatically-deleted","title":"Group memberships are automatically deleted","text":"<p>When a group is deleted, any memberships to that group are deleted automatically by the Contacts Provider.</p>"},{"location":"groups/delete-groups/#deletion-is-not-guaranteed-to-be-immediate","title":"Deletion is not guaranteed to be immediate","text":"<p>Groups may not immediately be deleted. They are marked for deletion and get deleted in the  background by the Contacts Provider depending on sync settings and network availability.</p> <p>Group memberships to those groups marked for deletion are immediately deleted!</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p>"},{"location":"groups/insert-groups/","title":"Insert groups","text":"<p>This library provides the <code>GroupsInsert</code> API that allows you to create/insert groups associated to an <code>Account</code> or no account.</p> <p>An instance of the <code>GroupsInsert</code> API is obtained by,</p> <pre><code>val insert = Contacts(context).groups().insert()\n</code></pre>"},{"location":"groups/insert-groups/#a-basic-insert","title":"A basic insert","text":"<p>To create/insert a new group for an Account,</p> <pre><code>val insertResult = Contacts(context)\n    .groups()\n    .insert()\n    .group(\n        title = \"Besties\",\n        account = Account(\"john.doe@gmail.com\", \"com.google\")\n    )\n    .commit()\n</code></pre> <p>If you need to insert multiple groups,</p> <pre><code>val newGroup1 = NewGroup(\"Goodies\", Account(\"john.doe@gmail.com\", \"com.google\"))\nval newGroup2 = NewGroup(\"Baddies\", Account(\"john.doe@gmail.com\", \"com.google\"))\n\nval insertResult = Contacts(context)\n    .groups()\n    .insert()\n    .groups(newGroup1, newGroup2)\n    .commit()\n</code></pre>"},{"location":"groups/insert-groups/#groups-and-accounts","title":"Groups and Accounts","text":"<p>A set of groups exist for each Account. The \"null\" account (representing the local/device-only  account) may also have a set of groups.</p> <p>\u2139\ufe0f Prior to version 0.3.0, this API did not allow insertion of groups with null accounts.</p> <p>The get accounts permission is required here because this API retrieves all available accounts, if any, and does the following;</p> <ul> <li>if the account specified is found in the list of accounts returned by the system, then the account   is used</li> <li>if the account specified is not found in the list of accounts returned by the system, then the    insertion fails for that group</li> <li>if a null is specified, then the group will be inserted without association to an account</li> </ul> <p>\u2139\ufe0f For more info on the relationship of Groups and Accounts, read Query groups.</p>"},{"location":"groups/insert-groups/#groups-and-duplicate-titles","title":"Groups and duplicate titles","text":"<p>The Contacts Provider allows multiple groups with the same title (case-sensitive comparison)  belonging to the same nullable account to exist. In older versions of Android, the AOSP Contacts app  allows the creation of new groups with existing titles. In newer versions, duplicate titles are not  allowed. Therefore, this library does not allow for duplicate titles.</p>"},{"location":"groups/insert-groups/#executing-the-insert","title":"Executing the insert","text":"<p>To execute the insert,</p> <pre><code>.commit()\n</code></pre>"},{"location":"groups/insert-groups/#handling-the-insert-result","title":"Handling the insert result","text":"<p>The <code>commit</code> function returns a <code>Result</code>.</p> <p>To check if all inserts succeeded,</p> <pre><code>val allInsertsSuccessful = insertResult.isSuccessful\n</code></pre> <p>To check if a particular insert succeeded,</p> <pre><code>val firstInsertSuccessful = insertResult.isSuccessful(newGroup1)\n</code></pre> <p>To get the Group IDs of all the newly created Groups,</p> <pre><code>val allGroupIds = insertResult.groupIds\n</code></pre> <p>To get the Group ID of a particular Group,</p> <pre><code>val secondGroupId = insertResult.groupId(newGroup2)\n</code></pre> <p>Once you have the Group IDs, you can retrieve the newly created Groups via the <code>GroupsQuery</code> API,</p> <pre><code>val groups = contactsApi\n    .groups()\n    .query()\n    .where { Id `in` allGroupIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query groups.</p> <p>Alternatively, you may use the extensions provided in <code>GroupsInsertResult</code>. To get all newly created Groups,</p> <pre><code>val groups = insertResult.groups(contactsApi)\n</code></pre> <p>To get a particular group,</p> <pre><code>val group = insertResult.group(contactsApi, newGroup1)\n</code></pre>"},{"location":"groups/insert-groups/#handling-insert-failure","title":"Handling insert failure","text":"<p>The insert may fail for a particular group for various reasons,</p> <pre><code>insertResult.failureReason(newGroup1)?.let {\n    when (it) {\n        TITLE_ALREADY_EXIST -&gt; promptUserToPickDifferentTitle()\n        INVALID_ACCOUNT -&gt; promptUserToPickDifferentAccount()\n        UNKNOWN -&gt; showGenericErrorMessage()\n    }   \n}\n</code></pre>"},{"location":"groups/insert-groups/#cancelling-the-insert","title":"Cancelling the insert","text":"<p>To cancel an insert amid execution,</p> <pre><code>.commit { returnTrueIfInsertShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel insert processing as soon as possible. The function is called numerous times during insert processing to check if processing should stop or continue. This gives you the option to cancel the insert.</p> <p>For example, to automatically cancel the insert inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val insertResult = insert.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"groups/insert-groups/#performing-the-insert-and-result-processing-asynchronously","title":"Performing the insert and result processing asynchronously","text":"<p>Inserts are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"groups/insert-groups/#performing-the-insert-with-permission","title":"Performing the insert with permission","text":"<p>Inserts require the <code>android.permission.WRITE_CONTACTS</code> and <code>android.permission.GET_ACCOUNTS</code>  permissions. If not granted, the insert will do nothing and return a failed result.</p> <p>To perform the insert with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"groups/query-groups/","title":"Query groups","text":"<p>This library provides the <code>GroupsQuery</code> API that allows you to get groups associated with an  <code>Account</code> or no account.</p> <p>An instance of the <code>GroupsQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).groups().query()\n</code></pre>"},{"location":"groups/query-groups/#a-basic-query","title":"A basic query","text":"<p>To get all of the groups for all accounts (including no/null account),</p> <pre><code>val groupsFromAllAccounts = Contacts(context)\n    .groups()\n    .query()\n    .find()\n</code></pre> <p>\u2139\ufe0f It is recommended to get sets of groups for a single account at a time to avoid confusion.</p>"},{"location":"groups/query-groups/#specifying-accounts","title":"Specifying Accounts","text":"<p>To limit the search to only those Groups associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to limit the search to groups belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all Groups from all accounts (including the null account) are included in the search.</p>"},{"location":"groups/query-groups/#ordering","title":"Ordering","text":"<p>To order resulting Groups using one or more fields,</p> <pre><code>.orderBy(fieldOrder)\n</code></pre> <p>For example, to order groups by account name,</p> <pre><code>.orderBy(GroupsFields.AccountName.asc())\n</code></pre> <p>String comparisons ignores case by default. Each orderBys provides <code>ignoreCase</code> as an optional parameter.</p> <p>Use <code>GroupsFields</code> to construct the orderBys.</p>"},{"location":"groups/query-groups/#limiting-and-offsetting","title":"Limiting and offsetting","text":"<p>To limit the amount of groups returned and/or offset (skip) a specified number of groups, use the <code>limit</code> and <code>offset</code> functions;</p> <pre><code>.limit(limit)\n.offset(offset)\n</code></pre> <p>For more info, read Using limit and offset in queries.</p>"},{"location":"groups/query-groups/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"groups/query-groups/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val groups = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"groups/query-groups/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"groups/query-groups/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"groups/query-groups/#using-the-where-function-to-specify-matching-criteria","title":"Using the <code>where</code> function to specify matching criteria","text":"<p>Use the <code>contacts.core.GroupsFields</code> combined with the extensions from <code>contacts.core.Where</code> to form WHERE clauses. </p> <p>\u2139\ufe0f This docs page will not provide a tutorial on database where clauses. It assumes that you know  the basics. If you don't know the basics, then search for sqlite where clause. </p> <p>For example, to find groups with a specific title,</p> <pre><code>.where { Title equalToIgnoreCase \"friends\" }\n</code></pre> <p>To get a list of groups by IDs,</p> <pre><code>.where { Id `in` groupIds }\n</code></pre>"},{"location":"groups/query-groups/#different-groups-with-the-same-titles","title":"Different groups with the same titles","text":"<p>Each account will have its own set of system and user-created groups. This means that there may be multiple groups with the same title belonging to different accounts. This is not a bug. This is why it is recommended to only get sets of groups per account, especially if there is more than one account in the system.</p>"},{"location":"groups/query-groups/#groups-from-more-than-one-account-in-the-same-list","title":"Groups from more than one account in the same list","text":"<p>When you perform a query that returns groups from more than one account, you will get everything in the same <code>GroupsList</code>. This list is just like any other <code>List</code> except it also provides an extra function that allows you to get a sublist with groups belonging only to a particular account.</p> <pre><code>val groupsFromAccount = groupsList.from(account)\n</code></pre> <p>This is equivalent to,</p> <pre><code>val groupsFromAccount = groupsList.filter { it.account == account }\n</code></pre> <p>It serves more as documentation and hint that you should really not be mixing groups from different accounts in the same list as it could cause confusion. However, if you know what you are doing and you are not confused, then do what you like :D </p> <p>This is also nice for Java users to not have to perform the filtering themselves.</p>"},{"location":"groups/update-groups/","title":"Update groups","text":"<p>This library provides the <code>GroupsUpdate</code> API that allows you to update existing Groups.</p> <p>An instance of the <code>GroupsUpdate</code> API is obtained by,</p> <pre><code>val update = Contacts(context).groups().update()\n</code></pre>"},{"location":"groups/update-groups/#a-basic-update","title":"A basic update","text":"<p>To update an existing group,</p> <pre><code>val updateResult = Contacts(context)\n    .groups()\n    .update()\n    .groups(existingGroup?.mutableCopy {\n        title = \"Best Friends\"\n    })\n    .commit()\n</code></pre> <p>If you need to update multiple groups,</p> <pre><code>val mutableGroup1 = group1.mutableCopy { ... }\nval mutableGroup2 = group2.mutableCopy { ... }\n\nval updateResult = Contacts(context)\n    .groups()\n    .update()\n    .groups(mutableGroup1, mutableGroup2)\n    .commit()\n</code></pre>"},{"location":"groups/update-groups/#read-only-groups","title":"Read-only Groups","text":"<p>Groups created by the system are typically read-only. You cannot modify them, even if you try! The  Contacts Provider typically have the following system groups (for standard Google Accounts),</p> <ul> <li>systemId: Contacts, title: My Contacts</li> <li>systemId: null, title: Starred in Android</li> <li>systemId: Friends, title: Friends</li> <li>systemId: Family, title: Family</li> <li>systemId: Coworkers, title: Coworkers</li> </ul> <p>The above list may vary per Account and/or flavor of Android.</p> <p>If you are implementing a sync adapter, you may be able to update read-only groups associated with the Account that your sync adapter works with. For more info, read Contacts API Setup | Sync adapter operations.</p>"},{"location":"groups/update-groups/#groups-and-duplicate-titles","title":"Groups and duplicate titles","text":"<p>The Contacts Provider allows multiple groups with the same title (case-sensitive comparison)  belonging to the same (nullable) account to exist. In older versions of Android, the AOSP Contacts  app allows the creation of new groups with existing titles. In newer versions, duplicate titles are  not allowed. Therefore, this library does not allow for duplicate titles.</p>"},{"location":"groups/update-groups/#executing-the-update","title":"Executing the update","text":"<p>To execute the update,</p> <pre><code>.commit()\n</code></pre>"},{"location":"groups/update-groups/#handling-the-update-result","title":"Handling the update result","text":"<p>The <code>commit</code> function returns a <code>Result</code>.</p> <p>To check if all updates succeeded,</p> <pre><code>val allUpdatesSuccessful = updateResult.isSuccessful\n</code></pre> <p>To check if a particular update succeeded,</p> <pre><code>val firstUpdateSuccessful = updateResult.isSuccessful(mutableGroup1)\n</code></pre>"},{"location":"groups/update-groups/#handling-update-failure","title":"Handling update failure","text":"<p>The update may fail for a particular group for various reasons,</p> <pre><code>updateResult.failureReason(mutableGroup1)?.let {\n    when (it) {\n        TITLE_ALREADY_EXIST -&gt; promptUserToPickDifferentTitle()\n        GROUP_IS_READ_ONLY -&gt; informUserThatReadOnlyGroupsCannotBeModified()\n        UNKNOWN -&gt; showGenericErrorMessage()\n    }   \n}\n</code></pre>"},{"location":"groups/update-groups/#cancelling-the-update","title":"Cancelling the update","text":"<p>To cancel an update amid execution,</p> <pre><code>.commit { returnTrueIfUpdateShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel update processing as soon as possible. The function is called numerous times during update processing to check if processing should stop or continue. This gives you the option to cancel the update.</p> <p>For example, to automatically cancel the update inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val updateResult = update.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"groups/update-groups/#performing-the-update-and-result-processing-asynchronously","title":"Performing the update and result processing asynchronously","text":"<p>Updates are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"groups/update-groups/#performing-the-update-with-permission","title":"Performing the update with permission","text":"<p>Updates require the <code>android.permission.WRITE_CONTACTS</code>. If not granted, the update will do nothing  and return a failed result.</p> <p>To perform the update with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"logging/log-api-input-output/","title":"Log API input and output","text":"<p>By default the all APIs provided in this library does not log anything at all. To enable logging all API input/output using the <code>android.util.Log</code>, specify the <code>Logger</code> when constructing an instance of <code>Contacts</code>;</p> <pre><code>val contactsApi = Contacts(\n    context,\n    logger = AndroidLogger()\n)\n</code></pre> <p>\u2139\ufe0f For more info on <code>Contacts</code> API setup, read Contacts API Setup.</p> <p>Invoking the <code>find</code> or <code>commit</code> functions in query, insert, update, and delete APIs will result in the following output in the Logcat,</p> <pre><code>Query {\n    rawContactsWhere: (account_name LIKE 'test@gmail.com' ESCAPE '\\') AND (account_type LIKE 'com.google' ESCAPE '\\')\n    where: data1 LIKE '%@gmail.com%' ESCAPE '\\' AND mimetype = 'vnd.android.cursor.item/email_v2'\n    isRedacted: false\n    // the rest is omitted for brevity\n}\nQuery.Result {\n    Number of contacts found: 2\n    First contact: Contact(\n        id=46, \n        rawContacts=[\n            RawContact(\n                id=45, \n                contactId=46, \n                addresses=[Address(id=329, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=WORK, label=null, formattedAddress=1200 Park Ave, street=1200 Park Ave, poBox=null, neighborhood=null, city=null, region=null, postcode=null, country=null, isRedacted=false)], \n                emails=[\n                    Email(id=318, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=WORK, label=null, address=buzz.lightyear@pixar.com, isRedacted=false), \n                    Email(id=319, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=HOME, label=null, address=buzz@lightyear.net, isRedacted=false)\n                ], \n                events=[\n                    Event(id=317, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=BIRTHDAY, label=null, date=EventDate(year=1995, month=10, dayOfMonth=22, isRedacted=false), isRedacted=false), \n                    Event(id=320, rawContactId=45, contactId=46, isPrimary=false, isSuperPrimary=false, type=ANNIVERSARY, label=null, date=EventDate(year=2022, month=0, dayOfMonth=1, isRedacted=false), isRedacted=false)\n                ], \n                // the rest is omitted for brevity\n            )\n        ]\n    )\n    isLimitBreached: false\n    isRedacted: false\n} (10 milliseconds)\n</code></pre> <p>This is very useful during development. If you have any issues with the library, maintainers will most likely ask you for these logs to help debug your issues.</p> <p>\u2139\ufe0f Notice that at the end, in parenthesis, the execution time of the <code>find</code> or <code>commit</code> operation is provided \ud83d\ude42</p>"},{"location":"logging/log-api-input-output/#custom-loggers","title":"Custom loggers","text":"<p>The library provides the <code>AndroidLogger</code>. However, if you want to use your own logging/tracking functions, you may create your own logger by providing an implementation of <code>Logger</code>.</p> <p>For example, to use <code>Timber</code> instead of <code>android.util.Log</code>,</p> <pre><code>class TimberLogger : Logger {\n\n    override val redactMessages: Boolean = true\n\n    override fun log(message: String) {\n        Timber.d(message)\n    }\n}\n\nval contactsApi = Contacts(\n    context,\n    logger = TimberLogger()\n)\n</code></pre>"},{"location":"logging/log-api-input-output/#redacting-log-messages","title":"Redacting log messages","text":"<p>The messages that are logged may contain private user data (contact data). Depending on how you log these messages in production, you may end up violating privacy laws such as GDPR guidelines.</p> <p>To ensure that you are not violating any privacy laws in your production apps when using this library, make sure to set <code>Logger.redactMessages</code> to <code>true</code>.</p> <pre><code>val contactsApi = Contacts(\n    context,\n    logger = AndroidLogger(redactMessages = true)\n)\n</code></pre> <p>Redacted messages are not as useful when debugging so you should set it to <code>false</code> during development. A common way to redact messages in release builds but not debug builds is to,</p> <pre><code>AndroidLogger(redactMessages = !BuildConfig.DEBUG)\n</code></pre> <p>For more info on redaction, read Redact entities and API input and output in production.</p>"},{"location":"other/convenience-functions/","title":"Convenience functions","text":"<p>This library provides some nice-to-have extensions in the <code>contacts.core.utils</code> package. I will be  going over some of them in this page.</p> <p>\u2139\ufe0f Functions in the util package that are used directly by other APIs such as result APIs are not  discussed here.</p>"},{"location":"other/convenience-functions/#contact-data-getter-and-setters","title":"Contact data getter and setters","text":"<p>Contacts can be made up of one or more RawContacts. In the case that a Contact has two or more RawContacts, getting/setting RawContact data may be a bit of a hassle, requiring loops or iterators,</p> <pre><code>// get all emails from all RawContacts belonging to the Contact\nval contactEmails = contact.rawContacts.flatMap { it.emails }\n// add an email to the first RawContact belonging to the Contact\ncontact.mutableCopy().rawContacts.first().emails.add(NewEmail())\n</code></pre> <p>\u2139\ufe0f For more info, read about API Entities.</p> <p>To simplify things, getter/setter extensions are provided in the <code>ContactData.kt</code> file,</p> <pre><code>// get all emails from all RawContacts belonging to the Contact\nval contactEmailSequence = contact.emails()\nval contactEmailList = contact.emailList()\n// add an email to the first RawContact belonging to the Contact\ncontact.mutableCopy().addEmail {\n    address = \"test@email.com\"\n}\n</code></pre> <p>\u2139\ufe0f Newer versions of the Android Open Source Project Contacts app and the Google Contacts app  shows data coming from all RawContacts in a Contact details screen. However, they only allow  editing a single RawContact and not the aggregate Contact in a single screen to avoid confusion.  With this in mind, feel free to use the getter extensions but be very careful with using the setters!</p>"},{"location":"other/convenience-functions/#mutable-and-new-rawcontact-data-setters","title":"Mutable and New RawContact data setters","text":"<p>Getting data from RawContacts is straightforward. You have direct access to their properties. The same goes for setting data. </p> <pre><code>val rawContactEmails = rawContact.emails\nrawContact.mutableCopy().addEmail(\n    NewEmail().apply{\n        address = \"abc@alphabet.com\"\n        type = EmailEntity.Type.WORK\n    }\n)\n</code></pre> <p>Still, there are some setter extensions provided in <code>MutableRawContactData.kt</code> and  <code>NewRawContactData.kt</code> that can add some sugar to your syntax.</p> <pre><code>rawContact.mutableCopy().addEmail {\n    address = \"abc@alphabet.com\"\n    type = EmailEntity.Type.WORK\n}\n</code></pre> <p>The setter functions in this section and in the \"Contact data getter and setters\" section also  uphold the redacted state of the mutable Contact/RawContact. We setting or adding a property using these extensions, the property being passed will be redacted if the Contact/RawContact it is being added to is redacted.</p> <p>\u2139\ufe0f For more info, read Redact entities and API input and output in production.</p>"},{"location":"other/convenience-functions/#getting-all-data-of-a-contact-or-rawcontact","title":"Getting all data of a Contact or RawContact","text":"<p>There may be instances where you want to get all available data of a Contact or RawContact instance. In such cases, you can use extensions in <code>ExistingContactData.kt</code>, <code>ExistingRawContactData.kt</code>, and <code>NewRawContactData.kt</code>.</p> <p>To get a sequence of all data kinds of a Contact or RawContact,</p> <pre><code>contact.data()\nrawContact.data()\n</code></pre> <p>To get it as a list,</p> <pre><code>contact.dataList()\nrawContact.dataList()\n</code></pre>"},{"location":"other/convenience-functions/#getting-the-parent-contact-of-a-rawcontact-or-data","title":"Getting the parent Contact of a RawContact or Data","text":"<p>Using the <code>Query</code> API, it is easy to get the parent Contact of a RawContact or Data,</p> <pre><code>val contactOfRawContact = contactsApi.query().where { Contact.Id equalTo rawContact.contactId }.find().firstOrNull()\nval contactOfData = contactsApi.query().where { Contact.Id equalTo data.contactId }.find().firstOrNull()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>To shorten things, you can use the extensions in <code>RawContactContact.kt</code> and <code>DataContact.kt</code>,</p> <pre><code>val contactOfRawContact = rawContact.contact(contactsApi)\nval contactOfData = data.contact(contactsApi)\n</code></pre> <p>On a similar note, to get the parent RawContact of a Data using the extensions in <code>DataRawContact.kt</code>,</p> <pre><code>val rawContactOfData = data.rawContact(contactsApi)\n</code></pre> <p>These are blocking calls so you might want to do them outside the UI thread.</p> <p>\u2139\ufe0f For more info, read Execute work outside of the UI thread using coroutines.</p>"},{"location":"other/convenience-functions/#refresh-contact-rawcontact-and-data-references","title":"Refresh Contact, RawContact, and Data references","text":"<p>In-memory references to these entities could become inaccurate due to changes in the database that could occur in your app, other apps, or by the Contacts Provider. If you need to get the most up-to-date reference of an entity from the database, you could do it using the <code>Query</code> and  <code>DataQuery</code> APIs,</p> <pre><code>val contactFromDb = contactsApi.query().where { Contact.Id equalTo contactInMemory.id }.find().firstOrNull()\nval rawContactFromDb = contactsApi.query().where { RawContact.Id equalTo rawContactInMemory.id }.find()\n    .firstOrNull()\n    ?.rawContacts\n    ?.find { it.id == rawContactInMemory.id }\nval dataFromDb = contactsApi.data().query().where { DataId equalTo dataInMemory.id }.find().firstOrNull()\n</code></pre> <p>To shorten things, you can use extensions in <code>ContactRefresh.kt</code>, <code>RawContactRefresh.kt</code>, and <code>DataRefresh.kt</code>,</p> <pre><code>val contactFromDb = contactInMemory.refresh(contactsApi)\nval rawContactFromDb = rawContactInMemory.refresh(contactsApi)\nval dataFromDb = dataInMemory.refresh(contactsApi)\n</code></pre> <p>These are blocking calls so you might want to do them outside the UI thread.</p> <p>\u2139\ufe0f For more info, read Execute work outside of the UI thread using coroutines.</p>"},{"location":"other/convenience-functions/#getset-data-read-only","title":"Get/set Data read-only","text":"<p>To set the read-only property of all data of a <code>NewRawContact</code> in one function call, you can use  extensions in <code>NewRawContactData.kt</code>,</p> <pre><code>newRawContact.setDataAsReadOnly(true)\n</code></pre> <p>To check if any <code>ExistingDataEntity</code> is read-only you can use extensions in <code>DataIsReadOnly.kt</code>,</p> <pre><code>val isReadOnly = existingDataEntity.isReadOnly(contactsApi)\n</code></pre> <p>To check if multiple <code>ExistingDataEntity</code>s are read-only,</p> <pre><code>val isReadOnlyMap = existingDataEntities.isReadOnlyMap(contactsApi)\n</code></pre> <p>These are blocking calls so you might want to do them outside the UI thread.</p> <p>\u2139\ufe0f For more info, read Execute work outside of the UI thread using coroutines.</p> <p>The value of <code>android.provider.ContactsContract.DataColumns.IS_READ_ONLY</code> is not a property of <code>ExistingDataEntity</code> because including that particular column in the query projection array causes  an exception. However, it is still possible to use the column in selection/WHERE clauses. Thus,  allowing us to create this extension function =)</p> <p>\u2139\ufe0f For more info, read API Entities | Read-only data.</p>"},{"location":"other/convenience-functions/#sort-contacts-by-data-fields","title":"Sort Contacts by data fields","text":"<p>The <code>Query</code> and <code>BroadQuery</code> APIs allows you to sort Contacts based on fields in the Contacts table such as <code>Id</code> and <code>DisplayNamePrimary</code>, </p> <pre><code>val sortedContacts = query.orderBy(ContactsFields.DisplayNamePrimary.desc(ignoreCase = true))\n</code></pre> <p>If you want to sort Contacts based on Data fields (e.g. email), you are unable to use the query  APIs provided in this library to do so. However, if you have a list of Contacts in memory, you can use the extensions in <code>ContactsComparator.kt</code> to build a <code>Comparator</code> to use for sorting,</p> <pre><code>val sortedContacts = unsortedContacts.sortedWith(\n    Fields.Email.Address.desc(ignoreCase = true).contactsComparator()\n)\n</code></pre> <p>You can also specify multiple fields for sorting,</p> <pre><code>val sortedContacts = unsortedContacts.sortedWith(\n    setOf(\n        Fields.Contact.Options.Starred.desc(),\n        Fields.Contact.DisplayNamePrimary.asc(ignoreCase = false),\n        Fields.Email.Address.asc()\n    ).contactsComparator()\n)\n</code></pre>"},{"location":"other/convenience-functions/#get-the-group-of-a-groupmembership","title":"Get the Group of a GroupMembership","text":"<p>The <code>GroupsQuery</code> allows you to get groups from a set of group Ids,</p> <pre><code>val group = contactsApi.groups().query().where { Id equalTo groupMembership.groupId }.find().firstOrNull()\nval groups = contactsApi.groups().query().where { Id `in` groupMemberships.map { it.groupId } }.find()\n</code></pre> <p>To shorten things, you can use the extensions in <code>GroupMembershipGroup.kt</code>,</p> <pre><code>val group = groupMembership.group(contactsApi)\nval groups = groupMemberships.groups(contactsApi)\n</code></pre> <p>These are blocking calls so you might want to do them outside the UI thread.</p> <p>\u2139\ufe0f For more info, read Execute work outside of the UI thread using coroutines.</p>"},{"location":"other/get-set-clear-contact-raw-contact-options/","title":"Get set contact options","text":"<p>This library provides several functions to interact with Contact and RawContact options; starred, send to voicemail, and ringtone.</p> <p>\u26a0\ufe0f The APIs for this have changed significantly since version 0.3.0. For documentation for version 0.2.4 and below, visit this page (click me).</p>"},{"location":"other/get-set-clear-contact-raw-contact-options/#getting-contact-options","title":"Getting contact options","text":"<p>To get Contact and RawContact options using query APIs provided in this library,</p> <pre><code>val contacts = Contacts(context)\n    .query() // or broadQuery() and other query APIs\n    // if you only want to include only options in the returned Contacts and RawContacts\n    .include(Fields.Contact.Options.all)\n    .includeRawContactsFields(RawContactsFields.Options.all)\n    .find()\n\nfor (contact in contacts) {\n    Log.d(\"Contact\", \"${contact.options}\")\n    for (rawContact in contacts.rawContacts) {\n        Log.d(\"RawContact\", \"${rawContact.options}\")\n    }\n}\n</code></pre> <p>\u2139\ufe0f For more info on query APIs, read Query contacts and Query contacts (advanced).</p>"},{"location":"other/get-set-clear-contact-raw-contact-options/#setting-contact-options","title":"Setting Contact options","text":"<p>To update Contact options using update APIs,</p> <pre><code>Contacts(context)\n    .update()\n    .contacts(\n        contact.mutableCopy {\n            setOptions {\n                starred = true\n                customRingtone = null\n                sendToVoicemail = false\n            }\n        }\n    )\n    .commit()\n</code></pre> <p>To insert a new RawContact with options using insert APIs,</p> <pre><code>Contacts(context)\n    .insert()\n    .rawContact(\n        setOptions {\n            starred = true\n            customRingtone = null\n            sendToVoicemail = false\n        }\n    )\n    .commit()\n</code></pre> <p>The inserted RawContact and parent Contact will contain the specified options.</p> <p>\u2139\ufe0f For more info on insert and APIs, read Insert contacts and Update contacts.</p>"},{"location":"other/get-set-clear-contact-raw-contact-options/#contact-and-rawcontact-options-affect-each-other","title":"Contact and RawContact options affect each other","text":"<p>Changes to the options of the parent Contact will be propagated to all child RawContact options. Changes to the options of a RawContact may or may not affect the options of the parent Contact. This propagation is done automatically by the Contacts Provider at the time the insert or update APIs provided in this library are committed.</p> <p>Typically, you should only read/write Contact options. Don't mind RawContact options, unless you really want to. For example,</p> <ul> <li>the AOSP Contacts app only allows reading and writing Contact options.</li> <li>the Google Contacts app allows reading and writing Contact and RawContact options.</li> </ul>"},{"location":"other/get-set-clear-contact-raw-contact-options/#setting-rawcontact-options","title":"Setting RawContact options","text":"<p>Due to the aforementioned relationship of Contact and RawContact options, the update APIs provided in this library will prioritize Contact options over RawContact options. This means that any changes you make to RawContact options will be overshadowed by Contact options.</p> <p>If you want to set RawContact options, then you should pass in the RawContact directly using the <code>rawContacts</code> function instead of passing in the Contact using the <code>contacts</code> function,</p> <pre><code>Contacts(context)\n    .update()\n    .rawContacts(\n        rawContact.mutableCopy {\n            setOptions {\n                starred = true\n                customRingtone = null\n                sendToVoicemail = false\n            }\n        }\n    )\n    .commit()\n</code></pre> <p>If you must pass Contacts instead of RawContacts and still want to prioritize RawContact options over Contact options, then you must exclude Contact options fields from the update operation,</p> <pre><code>Contacts(context)\n    .update()\n    // Include all fields except for Contact options.\n    .include(Fields.all.minus(Fields.Contact.Options.all))\n    .contacts(contacts)\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info on field includes, read Include only certain fields for read and write operations.</p>"},{"location":"other/get-set-clear-contact-raw-contact-options/#starred-in-android-favorites-group-membership","title":"Starred in Android &amp; Favorites Group Membership","text":"<p>When a Contact is starred, the Contacts Provider automatically adds a group membership to the favorites group for all RawContacts linked to the Contact. Setting the Contact starred to false removes all group memberships to the favorites group.</p> <p>The Contact's \"starred\" value is interdependent with memberships to the favorites group. Adding a membership to the favorites group results in starred being set to true. Removing the membership sets it to false. This behavior can cause bugs and increased code complexity for API users. </p> <p>Thus, the update APIs provided in this library overshadows membership changes to the favorites group with the value of <code>Options.starred</code>. In other words, the only way to star/favorite Contacts and RawContacts is to set the value of <code>Options.starred</code>. If you really want to star/favorite Contacts/RawContacts via membership to the favorites group (not recommended), then you must  include <code>Fields.GroupMembership.GroupId</code> and also exclude <code>Fields.Contact.Options.Starred</code> and  <code>RawContactsFields.Options.Starred</code> from the insert/update operations.</p>"},{"location":"other/get-set-clear-contact-raw-contact-options/#using-the-ui-ringtonepicker-extensions","title":"Using the ui RingtonePicker extensions","text":"<p>The <code>contacts.ui.util.RingtonePicker.kt</code> in the <code>ui</code> module` provides extension functions to make selecting existing ringtones easier. It provides you the same UX as the AOSP Contacts app.</p> <p>To use it,</p> <pre><code>Activity {\n    fun onSelectRingtoneClicked() {\n        selectRingtone(contact.options?.customRingtone)\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        onRingtoneSelected(requestCode, resultCode, data) { ringtoneUri -&gt;\n            // set contact options customRingtone = ringtoneUri\n        }\n    }\n}\n</code></pre> <p>Starting with Android 11 (API 30), you must include the following to your manifest in order to successfully use the above functions.</p> <pre><code>&lt;queries&gt;\n    &lt;intent&gt;\n        &lt;action android:name=\"android.intent.action.RINGTONE_PICKER\" /&gt;\n    &lt;/intent&gt;\n&lt;/queries&gt;\n</code></pre>"},{"location":"other/get-set-clear-default-data/","title":"Get set clear default Contact data","text":"<p>Default contact data are instances of common data kinds that are marked as the default.</p> <p>The two most common data kinds that use this mechanism are emails and phones. In the AOSP  Contacts app Contact details activity, long pressing an email or phone shows a popup menu with an  option to set it as default. When a particular email or phone is set as default, sending an email and making a phone call to that contact will use that default email and phone respectively.</p> <p>\u2139\ufe0f For more info on the common data kinds, read about API Entities.</p>"},{"location":"other/get-set-clear-default-data/#getting-default-data","title":"Getting default data","text":"<p>To get the default Contact email and phone from all RawContacts,</p> <pre><code>val defaultContactEmail: Email? = contact.emails().default()\nval defaultContactPhone: Phone? = contact.phones().default()\n</code></pre> <p>To get the default RawContact email and phone,</p> <pre><code>val defaultRawContactEmail: Email? = rawContact.emails.default()\nval defaultRawContactPhone: Phone? = rawContact.phones.default()\n</code></pre> <p>To get the first default data out of a generic list of data,</p> <pre><code>val defaultData = dataList.default()\n</code></pre> <p>Note that the most common use of defaults is with Contacts, not RawContacts. You typically do not  need to worry about defaults at a RawContact level.</p>"},{"location":"other/get-set-clear-default-data/#setting-default-data","title":"Setting default data","text":"<p>To set a particular data as the default for the set of data of the same type (e.g. email) for the  aggregate Contact,</p> <pre><code>email.setAsDefault(contactsApi)\n</code></pre> <p>If a default data of the same type for the aggregate Contact already exist before this call, then  it will no longer be the default.</p> <p>For example, these emails belong to the same aggregate Contact;</p> <ul> <li>x@x.com (default)</li> <li>y@y.com</li> <li>z@z.com</li> </ul> <p>Calling this function on a non-default data (e.g. y@y.com) will remove the default status for data that was previously set as the default. This data will then be set as the default. This results in;</p> <ul> <li>x@x.com</li> <li>y@y.com (default)</li> <li>z@z.com</li> </ul>"},{"location":"other/get-set-clear-default-data/#clearing-default-data","title":"Clearing default data","text":"<p>To remove the default status of any data of the same type (e.g. email), if any, for the aggregate  Contact,</p> <pre><code>email.clearDefault(contactsApi)\n</code></pre> <p>For example, these emails belong to the same aggregate Contact;</p> <ul> <li>x@x.com</li> <li>y@y.com (default)</li> <li>z@z.com</li> </ul> <p>Calling this function on any data of the same kind for the aggregate contact (default or not) will  remove the default status on all data of the same kind for the aggregate Contact. This results in;</p> <ul> <li>x@x.com</li> <li>y@y.com</li> <li>z@z.com</li> </ul>"},{"location":"other/get-set-clear-default-data/#changes-are-immediate-and-are-not-applied-to-the-receiver","title":"Changes are immediate and are not applied to the receiver","text":"<p>These apply to set and clear functions.</p> <ol> <li>Changes are immediate.<ul> <li>These functions will make the changes to the Contacts Provider database immediately. You do   not need to use update APIs to commit the changes.</li> </ul> </li> <li>Changes are not applied to the receiver.<ul> <li>This function call does NOT mutate immutable or mutable receivers. Therefore, you should use   query APIs or refresh extensions or process the result of this function call to get the most   up-to-date reference to mutable or immutable entity that contains the changes in the Contacts   Provider database.</li> </ul> </li> </ol>"},{"location":"other/get-set-clear-default-data/#performing-default-data-management-asynchronously","title":"Performing default data management asynchronously","text":"<p>Setting or clearing default data is done in the same thread as the call-site. This may result in a  choppy UI. </p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"other/get-set-clear-default-data/#performing-default-data-management-with-permission","title":"Performing default data management with permission","text":"<p>Getting and setting/clearing default data require the <code>android.permission.READ_CONTACTS</code> and <code>android.permission.WRITE_CONTACTS</code> permissions respectively. If not granted, getting and  setting/clearing default data will fail.</p>"},{"location":"other/get-set-clear-default-data/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":"<p>As per documentation, for a set of data rows with the same mimetype (e.g. a set of emails), there should only be one primary data row (e.g. email) per RawContact and one super primary data row per Contact. Furthermore, a data row that is super primary must also be primary.</p> <p>Unfortunately, the Contacts Provider does not do any data set validation for the Data columns <code>IS_PRIMARY</code> and <code>IS_SUPER_PRIMARY</code>. This means that it is possible to set more than one data row of the same mimetype as primary for the same RawContact and super primary for the same aggregate Contact. It is also possible to set a data row as super primary but not primary. Upholding the the contract is left to the us (the library).</p> <p>For example, given this relationship;</p> <ul> <li>Contact<ul> <li>RawContact X<ul> <li>Email A</li> <li>Email B</li> </ul> </li> <li>RawContact Y<ul> <li>Email C</li> <li>Email D</li> </ul> </li> </ul> </li> </ul> <p>When Emails A, B, C, and D are inserted with the RawContacts or after the RawContacts have been created, we get the following state;</p> Email Primary Super Primary A 0 0 B 0 0 C 0 0 D 0 0 <p>The state does not change when RawContact X is linked with RawContact Y.</p> <p>After setting Email A as the \"default\" email, it becomes primary and super primary;</p> Email Primary Super Primary A 1 1 B 0 0 C 0 0 D 0 0 <p>Then setting Email B as the default email, it becomes primary and super primary. Email A is no longer primary or super primary.</p> Email Primary Super Primary A 0 0 B 1 1 C 0 0 D 0 0 <p>Then setting Email C as the default email, it becomes primary and super primary. Email B is still primary because it belongs to a different RawContact than Email C. However, Email B is no longer the super primary as there can only be one per aggregate Contact.</p> Email Primary Super Primary A 0 0 B 1 0 C 1 1 D 0 0 <p>Then setting Email D as the default email, it becomes primary and super primary. Email C is no longer primary or super primary.</p> Email Primary Super Primary A 0 0 B 1 0 C 0 0 D 1 1 <p>Then clearing the default email D, removes its primary and super primary status. However, email B remains a primary but not a super primary.</p> Email Primary Super Primary A 0 0 B 1 0 C 0 0 D 0 0 <p>The above behavior is observed from the AOSP Contacts app. The \"super primary\" data of an aggregate Contact is referred to as the \"default\".</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/","title":"Get set remove full-sized and thumbnail contact photos","text":"<p>This library provides several functions to interact with Contact and RawContact full-sized and  thumbnail photos.</p> <p>\u26a0\ufe0f The APIs for this have changed significantly since version 0.3.0. For documentation for version 0.2.4  and below, visit this page (click me).</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#contact-and-rawcontact-photos","title":"Contact and RawContact photos","text":"<p>The photo assigned to a Contact is just a reference to a photo assigned to a RawContact. If a  Contact consists of more than one RawContact, only the photo from one of the RawContacts will be  used by the Contact. </p> <p>Setting/removing the (main) RawContact's photo will in turn change the Contact photo because the  Contact photo is just a reference to the RawContact photo. The inverse is also true.</p> <p>RawContact photos are retained when linking and unlinking.</p> <p>\u2139\ufe0f For more info, read Link unlink Contacts.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#full-sized-photos-and-thumbnails","title":"Full-sized photos and thumbnails","text":"<p>Each RawContact may be assigned one photo. The thumbnail is just a downsized version of the  full-sized photo. The full-sized photo is typically displayed in a large view, such as in a contact detail screen. The thumbnail is typically displayed in small views, such as in a contacts list view.</p> <p>Setting the full-sized photo will automatically set the thumbnail. The Contacts Provider  automatically creates a downsized version of the full-sized photo.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#getting-contact-photo","title":"Getting contact photo","text":"<p>There are several ways to do this.</p> <p>Using query APIs to get a list of <code>Contact</code>s with photo uris,</p> <pre><code>val contacts = Contacts(context)\n    .query()\n    // if you only want to include photo data in the returned Contacts\n    .include(\n        Fields.Contact.PhotoUri,\n        Fields.Contact.PhotoThumbnailUri\n    ) \n    .find()\n\nfor (contact in contacts) {\n    Log.d(\n        \"Contact\",\n        \"\"\"\n            Photo Uri: ${contact.photoUri}\n            Thumbnail Uri: ${contact.photoThumbnailUri}\n        \"\"\".trimIndent()\n    )\n}\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts and Query contacts (advanced).</p> <p>Using one of the extension functions in <code>contacts.core.util.ContactPhoto.kt</code> to get photo data,</p> <pre><code>val photoInputStream = contact.photoInputStream(contactsApi)\nval photoBytes = contact.photoBytes(contactsApi)\nval photoBitmap = contact.photoBitmap(contactsApi)\nval photoBitmapDrawable = contact.photoBitmapDrawable(contactsApi)\n\nval photoThumbnailInputStream = contact.photoThumbnailInputStream(contactsApi)\nval photoThumbnailBytes = contact.photoThumbnailBytes(contactsApi)\nval photoThumbnailBitmap = contact.photoThumbnailBitmap(contactsApi)\nval photoThumbnailBitmapDrawable = contact.photoThumbnailBitmapDrawable(contactsApi)\n</code></pre> <p>To get RawContact photos directly, use one of the extension functions in <code>contacts.core.util.RawContactPhoto.kt</code>,</p> <pre><code>val photoInputStream = rawContact.photoInputStream(contactsApi)\nval photoBytes = rawContact.photoBytes(contactsApi)\nval photoBitmap = rawContact.photoBitmap(contactsApi)\nval photoBitmapDrawable = rawContact.photoBitmapDrawable(contactsApi)\n\nval photoThumbnailInputStream = rawContact.photoThumbnailInputStream(contactsApi)\nval photoThumbnailBytes = rawContact.photoThumbnailBytes(contactsApi)\nval photoThumbnailBitmap = rawContact.photoThumbnailBitmap(contactsApi)\nval photoThumbnailBitmapDrawable = rawContact.photoThumbnailBitmapDrawable(contactsApi)\n</code></pre> <p>\u2139\ufe0f The Contact photo is just a reference to one of its RawContact's photo.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#setting-contact-photo","title":"Setting contact photo","text":"<p>There are two ways to set Contact or RawContact photo.</p> <p>\u26a0\ufe0f Make sure that the Contact instances you are performing these operations on came from a query that included all fields from <code>Fields.PrimaryPhotoHolder</code>. Otherwise, the incorrect child RawContact's photo may be set (in case the Contact has more than one child RawContact).  </p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#using-extension-functions","title":"Using extension functions","text":"<p>This can only be done for existing Contacts/RawContacts.</p> <p>To set the Contact photo, use one of the extension functions in <code>contacts.core.util.ContactPhoto.kt</code>,</p> <pre><code>contact.setPhotoDirect(contactsApi, PhotoData.from(inputStream))\ncontact.setPhotoDirect(contactsApi, PhotoData.from(byteArray))\ncontact.setPhotoDirect(contactsApi, PhotoData.from(bitmap))\ncontact.setPhotoDirect(contactsApi, PhotoData.from(bitmapDrawable))\n</code></pre> <p>Setting the full-sized photo will automatically set the thumbnail. The Contacts Provider  automatically creates a downsized version of the full-sized photo.</p> <p>To set a RawContact photo, use one of the extension functions in <code>contacts.core.util.RawContactPhoto.kt</code>,</p> <pre><code>rawContact.setPhotoDirect(contactsApi, PhotoData.from(inputStream))\nrawContact.setPhotoDirect(contactsApi, PhotoData.from(byteArray))\nrawContact.setPhotoDirect(contactsApi, PhotoData.from(bitmap))\nrawContact.setPhotoDirect(contactsApi, PhotoData.from(bitmapDrawable))\n</code></pre> <p>\u2139\ufe0f Prior to version 0.3.0, these functions were named <code>setPhoto</code>.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#as-part-of-an-insert-or-update-api-call","title":"As part of an insert or update API call","text":"<p>\u2139\ufe0f Setting photo as part of insert or update API calls was not possible prior to version 0.3.0.</p> <p>To insert a new RawContact with a photo,</p> <pre><code>Contacts(this)\n    .insert()\n    .rawContact {\n        setPhoto(PhotoData.from(...))\n    }\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info on insert APIs, read Insert contacts.</p> <p>To update an existing Contact or RawContact with a photo,</p> <pre><code>Contacts(this)\n    .update()\n    .contacts(\n        contact.mutableCopy {\n            setPhoto(PhotoData.from(...))\n        }\n    )\n    .rawContacts(\n        rawContact.mutableCopy {\n            setPhoto(PhotoData.from(...))\n        }\n    )\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info on update APIs, read Update contacts.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#removing-contact-photo","title":"Removing contact photo","text":"<p>There are two ways to remove Contact or RawContact photo.</p> <p>\u26a0\ufe0f Make sure that the Contact instances you are performing these operations on came from a query that included all fields from <code>Fields.PrimaryPhotoHolder</code>. Otherwise, the incorrect child RawContact's photo may be removed (in case the Contact has more than one child RawContact).</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#using-extension-functions_1","title":"Using extension functions","text":"<p>This can only be done for existing Contacts/RawContacts.</p> <p>To remove the Contact (and corresponding RawContact) photo (full-sized and thumbnail),</p> <pre><code>contact.removePhotoDirect(contactsApi)\n</code></pre> <p>To remove a specific RawContact's photo (full-sized and thumbnail),</p> <pre><code>rawContact.removePhotoDirect(contactsApi)\n</code></pre> <p>\u2139\ufe0f Prior to version 0.3.0,  these functions were named <code>removePhoto</code>.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#as-part-of-an-update-api-call","title":"As part of an update API call","text":"<p>\u2139\ufe0f Removing photo as part of insert or update API calls was not possible prior to version 0.3.0.</p> <p>To update an existing Contact or RawContact without a photo,</p> <pre><code>Contacts(this)\n    .update()\n    .contacts(\n        contact.mutableCopy {\n            removePhoto()\n        }\n    )\n    .rawContacts(\n        rawContact.mutableCopy {\n            removePhoto()\n        }\n    )\n    .commit()\n</code></pre> <p>\u2139\ufe0f For more info on update APIs, read Update contacts.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#using-the-ui-photopicker-extensions","title":"Using the ui PhotoPicker extensions","text":"<p>The <code>contacts.ui.util.PhotoPicker.kt</code> in the <code>ui</code> module` provides extension functions to make  selecting existing photos, taking new photos, and removing photos easier. It provides you the same UX as the AOSP Contacts app. To use it,</p> <pre><code>Activity {\n    fun onPhotoViewClicked() {\n        showPhotoPickerDialog(\n            withRemovePhotoOption = true,\n            removePhoto = {\n                // remove contact photo\n            }\n        )\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        onPhotoPicked(requestCode, resultCode, data,\n            photoBitmapPicked = { photoBitmap -&gt;\n                // set contact photo\n            },\n            photoUriPicked = { uri -&gt;\n                // Note that bitmap decoding should be done in a non-UI thread. Threading has been\n                // left out of this example for brevity.\n                val photoBitmap = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) {\n                    ImageDecoder.decodeBitmap(ImageDecoder.createSource(context.contentResolver, uri))\n                } else {\n                    MediaStore.Images.Media.getBitmap(context.contentResolver, uri)\n                }\n\n                // set contact photo\n            }\n        )\n    }\n}\n</code></pre> <p>Starting with Android 11 (API 30), you must include the following to your manifest in order to successfully use the above functions.</p> <pre><code>&lt;queries&gt;\n   &lt;intent&gt;\n      &lt;action android:name=\"android.media.action.IMAGE_CAPTURE\" /&gt;\n   &lt;/intent&gt;\n   &lt;intent&gt;\n      &lt;action android:name=\"android.intent.action.PICK\" /&gt;\n   &lt;/intent&gt;\n&lt;/queries&gt;\n</code></pre>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#performing-photo-management-asynchronously","title":"Performing photo management asynchronously","text":"<p>All of the code shown in this guide are done in the same thread as the call-site. This may result  in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"other/get-set-remove-contact-raw-contact-photo/#performing-photo-management-with-permission","title":"Performing photo management with permission","text":"<p>Getting and setting photos require the <code>android.permission.READ_CONTACTS</code> and  <code>android.permission.WRITE_CONTACTS</code> permissions respectively. If not granted, getting/setting photos will fail.</p> <p>To perform the get/set photo with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"other/link-unlink-contacts/","title":"Link unlink Contacts","text":"<p>The Contacts Provider automatically aggregates similar RawContacts into a single Contact when it determines that they reference the same person. </p> <p>However, the Contacts Provider's aggregation algorithms are only as accurate as the Data belonging  to these RawContacts. Sometimes, they are not enough to determine if they indeed are the same  person. With this in mind, the Contacts Provider allows us to explicitly and forcefully specify  whether two or more RawContacts reference the same person (Contact) or not.</p> <p>\u26a0\ufe0f The APIs for this have changed significantly since version 0.3.0. For documentation for version 0.2.4 and below, visit this page (click me).</p>"},{"location":"other/link-unlink-contacts/#linking","title":"Linking","text":"<p>There are two ways to link Contacts.</p>"},{"location":"other/link-unlink-contacts/#using-extension-functions","title":"Using extension functions","text":"<p>To link three Contacts and all of their constituent RawContacts into a single Contact using  extensions from <code>contacts.core.util.ContactLinks.kt</code>,</p> <pre><code>val linkResult = contact1.linkDirect(contactsApi, contact2, contact3)\n</code></pre> <p>\u2139\ufe0f Prior to version 0.3.0,  this function was named <code>link</code>.</p>"},{"location":"other/link-unlink-contacts/#using-the-contactlink-api","title":"Using the <code>ContactLink</code> API","text":"<p>To link three Contacts and all of their constituent RawContacts into a single Contact using the <code>ContactLink</code> API,</p> <pre><code>val linkResult = contactsApi\n  .aggregationExceptions()\n  .link()\n  .contacts(contact1, contact2, contact3)\n  .commit()\n</code></pre> <p>\u2139\ufe0f The <code>ContactLink</code> API was not available prior to  version 0.3.0.</p> <p>The above examples links (keep together) all RawContacts belonging to <code>contact1</code>, <code>contact2</code>, and  <code>contact3</code> into a single Contact.</p> <p>Aggregation is done by the Contacts Provider. For example,</p> <ul> <li>Contact (id: 1, display name: A)<ul> <li>RawContact A</li> </ul> </li> <li>Contact (id: 2, display name: B)<ul> <li>RawContact B</li> <li>RawContact C</li> </ul> </li> </ul> <p>Linking Contact 1 with Contact 2 results in;</p> <ul> <li>Contact (id: 1, display name: A)<ul> <li>RawContact A</li> <li>RawContact B</li> <li>RawContact C</li> </ul> </li> </ul> <p>Contact 2 no longer exists and all of the Data belonging to RawContact B and C are now associated with Contact 1.</p> <p>If instead Contact 2 is linked with Contact 1;</p> <ul> <li>Contact (id: 1, display name: B)<ul> <li>RawContact A</li> <li>RawContact B</li> <li>RawContact C</li> </ul> </li> </ul> <p>The same thing occurs except the display name has been set to the display name of RawContact B.</p> <p>This function only instructs the Contacts Provider which RawContacts should be aggregated to a single Contact. Details on how RawContacts are aggregated into a single Contact are left to the Contacts Provider.</p> <p>\u2139\ufe0f Profile Contact/RawContacts are not supported! This operation will fail if given any profile Contact/RawContacts .</p>"},{"location":"other/link-unlink-contacts/#handling-the-link-result","title":"Handling the link result","text":"<p>To check if the link succeeded,</p> <pre><code>val linkSuccessful = linkResult.isSuccessful\n</code></pre> <p>To get the ID of the parent Contact of all linked RawContacts,</p> <pre><code>val contactId: Long? = linkResult.contactId\n</code></pre> <p>\u2139\ufe0f The <code>contactId</code> will belong to one of the linked Contacts.</p> <p>Once you have the Contact ID, you can retrieve the Contact via the <code>Query</code> API,</p> <pre><code>val contact = contactsApi\n    .query()\n    .where { Contact.Id equalTo contactId }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Alternatively, you may use the extensions provided in <code>contact.core.util.ContactLinkResult.kt</code>.  To get the parent Contact of all linked RawContacts,</p> <pre><code>val contact = linkResult.contact(contactsApi)\n</code></pre>"},{"location":"other/link-unlink-contacts/#unlinking","title":"Unlinking","text":"<p>There are two ways to unlink a Contact.</p>"},{"location":"other/link-unlink-contacts/#using-extension-functions_1","title":"Using extension functions","text":"<p>To unlink a Contacts with more than one RawContact into a separate Contacts using extensions from  <code>contacts.core.util.ContactLinks.kt</code>,</p> <pre><code>val unlinkResult = contact.unlinkDirect(contactsApi)\n</code></pre> <p>\u2139\ufe0f Prior to version 0.3.0,  this function was named <code>unlink</code>.</p>"},{"location":"other/link-unlink-contacts/#using-the-contactunlink-api","title":"Using the <code>ContactUnlink</code> API","text":"<p>To unlink a Contacts with more than one RawContact into a separate Contacts using the  <code>ContactUnlink</code> API,</p> <pre><code>val unlinkResult = contactsApi\n  .aggregationExceptions()\n  .unlink()\n  .contact(contact)\n  .commit()\n</code></pre> <p>\u2139\ufe0f The <code>ContactUnlink</code> API was not available prior to version 0.3.0.</p> <p>The above unlinks (keep separate) all RawContacts belonging to the <code>contact</code> into separate Contacts.</p> <p>The above does nothing and will fail if the Contact only has one constituent RawContact.</p> <p>\u2139\ufe0f Profile Contact/RawContacts are not supported! This operation will fail if given any profile  Contact/RawContacts .</p>"},{"location":"other/link-unlink-contacts/#handling-the-unlink-result","title":"Handling the unlink result","text":"<p>To check if the unlink succeeded,</p> <pre><code>val unlinkSuccessful = unlinkResult.isSuccessful\n</code></pre> <p>To get the IDs of the constituent RawContact of of the Contact that has been unlinked,</p> <pre><code>val rawContactIds = unlinkResult.rawContactIds\n</code></pre> <p>Once you have the RawContact IDs, you can retrieve the corresponding Contacts via the <code>Query</code> API,</p> <pre><code>val contacts = contactsApi\n    .query()\n    .where { RawContact.Id `in` rawContactIds }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Alternatively, you may use the extensions provided in <code>contact.core.util.ContactUnlinkResult.kt</code>.  To get the Contacts of all unlinked RawContacts,</p> <pre><code>val contacts = unlinkResult.contacts(contactsApi)\n</code></pre>"},{"location":"other/link-unlink-contacts/#performing-linkingunlinking-asynchronously","title":"Performing linking/unlinking asynchronously","text":"<p>Linking or unlinking contacts is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"other/link-unlink-contacts/#performing-linkingunlinking-with-permission","title":"Performing linking/unlinking with permission","text":"<p>Linking/unlinking requires the <code>android.permission.WRITE_CONTACTS</code> permission. If not granted,  linking/unlinking data will fail.</p> <p>To perform the link/unlink with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"other/link-unlink-contacts/#syncing-is-done-at-the-rawcontact-level","title":"Syncing is done at the RawContact level","text":"<p>You may link Contacts with RawContacts that belong to different Accounts. Any RawContact Data modifications are synced per Account sync settings.</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p> <p>RawContacts that are not associated with an Account are local to the device and therefore will not be synced even if it is linked to a Contact with a RawContact that is associated with an Account.</p> <p>\u2139\ufe0f For more info, read about Local (device-only) contacts.</p>"},{"location":"other/link-unlink-contacts/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":""},{"location":"other/link-unlink-contacts/#behavior-of-linkingmergingjoining-contacts-aggregationexceptions","title":"Behavior of linking/merging/joining contacts (AggregationExceptions)","text":"<p>The AOSP Contacts app terminology has changed over time;</p> <ul> <li>API 22 and below; join / separate</li> <li>API 23; merge / unmerge</li> <li>API 24 and above; link / unlink</li> </ul> <p>However, the internals have not changed; <code>KEEP_TOGETHER</code> / <code>KEEP_SEPARATE</code>. These operations are supported by the <code>ContactsContract.AggregationExceptions</code>.</p> <p>For example, given the following tables,</p> <pre><code>### Contacts table\nContact id: 32, displayName: X, starred: 0, timesContacted: 1, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\nContact id: 33, displayName: Y, starred: 1, timesContacted: 2, lastTimeContacted: 1573071750624, customRingtone: content://media/internal/audio/media/115, sendToVoicemail: 1\n\n### RawContacts table\nRawContact id: 30, contactId: 32, displayName: X, accountName: x@x.com, accountType: com.google, starred: 0, timesContacted: 1, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\nRawContact id: 31, contactId: 33, displayName: Y, accountName: y@y.com, accountType: com.google, starred: 1, timesContacted: 2, lastTimeContacted: 1573071750624, customRingtone: content://media/internal/audio/media/115, sendToVoicemail: 1\n\n### Data table\nData id: 57, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/group_membership, data1: 18\nData id: 58, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/name, data1: X, isPrimary: 1, isSuperPrimary: 1\nData id: 59, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: x@x.com\nData id: 60, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: xx@x.com, isPrimary: 1, isSuperPrimary: 1\nData id: 63, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/group_membership, data1: 6\nData id: 64, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/name, data1: Y, isPrimary: 1, isSuperPrimary: 1\nData id: 65, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/email_v2, data1: y@y.com\nData id: 66, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/email_v2, data1: yy@y.com, isPrimary: 1, isSuperPrimary: 1\n</code></pre> <p>When Contact X links/merges/joins Contact Y, the tables becomes;</p> <pre><code>### Contacts table\nContact id: 32, displayName: X, starred: 1, timesContacted: 2, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\n\n### RawContacts table\nRawContact id: 30, contactId: 32, displayName: X, accountName: x@x.com, accountType: com.google, starred: 0, timesContacted: 1, lastTimeContacted: 1573071785456, customRingtone: content://media/internal/audio/media/109, sendToVoicemail: 0\nRawContact id: 31, contactId: 32, displayName: Y, accountName: y@y.com, accountType: com.google, starred: 1, timesContacted: 2, lastTimeContacted: 1573071750624, customRingtone: content://media/internal/audio/media/115, sendToVoicemail: 1\n\n### Data table\nData id: 57, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/group_membership, data1: 18\nData id: 58, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/name, data1: X, isPrimary: 1, isSuperPrimary: 1\nData id: 59, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: x@x.com\nData id: 60, rawContactId: 30, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: xx@x.com, isPrimary: 1, isSuperPrimary: 0\nData id: 63, rawContactId: 31, contactId: 32, mimeType: vnd.android.cursor.item/group_membership, data1: 6\nData id: 64, rawContactId: 31, contactId: 32, mimeType: vnd.android.cursor.item/name, data1: Y, isPrimary: 1, isSuperPrimary: 0\nData id: 65, rawContactId: 31, contactId: 32, mimeType: vnd.android.cursor.item/email_v2, data1: y@y.com\nData id: 66, rawContactId: 31, contactId: 33, mimeType: vnd.android.cursor.item/email_v2, data1: yy@y.com, isPrimary: 1, isSuperPrimary: 0\n</code></pre> <p>What changed?</p> <p>Contact Y's row has been deleted and its column values have been merged into Contact X row. If the reverse occurred (Contact Y merged with Contact X), Contact Y's row would still be deleted. The difference is that Contact X's display name will be set to Contact Y's display name, which is done by the AOSP Contacts app manually by setting Contact Y's Data name row to be the \"default\" (isPrimary and isSuperPrimary both set to 1).</p> <p>\u2139\ufe0f The AggregationExceptions table records the linked RawContacts IDs in ascending order  regardless of the order used in RAW_CONTACT_ID1 and RAW_CONTACT_ID2 at the time of merging.</p> <p>The RawContacts and Data table remains the same except the joined contactId column values have now been changed to the id of Contact X. All Data rows' isSuperPrimary value has been set to 0 though the isPrimary columns remain the same. In other words, this clears any \"default\" set before the link. These are done automatically by the Contacts Provider during the link operation.</p> <p>What is not done automatically by the Contacts Provider is that the name row of former Contact X is set as the default. The AOSP Contacts app does this manually. The Contacts Providers automatically sets the Contact display name to whatever the default name row is for the Contact, if available. For more info on Contact display name resolution, read the Contact Display Name and Default Name Rows section.</p> <p>\u2139\ufe0f Display name resolution is different for APIs below 21 (pre-lollipop).</p> <p>The display name of the RawContacts remain the same.</p> <p>The Groups table remains unmodified.</p> <p>Options updates</p> <p>Changes to the options (starred, timesContacted, lastTimeContacted, customRingtone, and sendToVoicemail) of a RawContact may affect the options of the parent Contact. On the other hand, changes to the options of the parent Contact will be propagated to all child RawContact options.</p> <p>Photo updates</p> <p>A RawContact may have a full-sized photo saved as a file and a thumbnail version of that saved in the Data table in a photo mimetype row. A Contact's full-sized photo and thumbnail are simply references to the \"chosen\" RawContact's full-sized photo and thumbnail (though the URIs may differ).</p> <p>\u2139\ufe0f When removing the photo in the AOSP contacts app, the photo data row is not immediately  deleted, though the <code>PHOTO_FILE_ID</code> is immediately set to null. This may result in the <code>PHOTO_URI</code> and <code>PHOTO_THUMBNAIL_URI</code> to still have a valid image uri even though the photo has been  \"removed\". This library immediately deletes the photo data row, which seems to work perfectly.</p> <p>Data inserts</p> <p>In the AOSP Contacts app, Data inserted in combined (raw) contacts mode will be associated to the first RawContact in the list sorted by the RawContact ID.</p> <p>\u2139\ufe0f This may not be the same as the RawContact referenced by <code>ContactsColumns.NAME_RAW_CONTACT_ID</code>.</p> <p>UI changes?</p> <p>The AOSP Contacts App does not display the groups field when displaying / editing Contacts that have multiple RawContacts (linked/merged/joined) in combined mode. However, it does allow editing individual RawContact Data rows in which case the groups field is displayed and editable.</p> <p>In the AOSP Contacts app, the name attribute used comes from the name row with IS_SUPER_PRIMARY set to true. This and all other \"unique\" mimetypes (organization) and non-unique mimetypes (email) per RawContact are shown only if they are not blank.</p> <p>Showing multiple RawContact's data in the same edit screen (combined mode)</p> <p>In older version of the AOSP, Android Open Source Project (AOSP) Contacts app, data from multiple RawContacts was being shown in the same edit screen. This caused a lot of confusion about which data belonged to which RawContact. Newer versions of AOSP Contacts only allow editing one RawContact at a time to avoid confusion. Though, several RawContacts' data are still shown (not-editable) in the same screen.</p>"},{"location":"other/link-unlink-contacts/#aggregationexceptions-table","title":"AggregationExceptions table","text":"<p>Given the following Contacts and their RawContacts;</p> <ul> <li>Contact A<ul> <li>RawContact 1</li> </ul> </li> <li>Contact B<ul> <li>RawContact 2</li> </ul> </li> <li>Contact C<ul> <li>RawContact 3</li> </ul> </li> <li>Contact D<ul> <li>RawContact 4</li> </ul> </li> </ul> <p>Linking one by one in this order;</p> <ul> <li>Contact B link Contact A</li> <li>Contact C link Contact D</li> <li>Contact C link Contact B</li> </ul> <p>Results in the following AggregationExceptions rows respectively;</p> <pre><code>Aggregation exception id: 430, type: 1, rawContactId1: 1, rawContactId2: 2\n</code></pre> <pre><code>Aggregation exception id: 430, type: 1, rawContactId1: 1, rawContactId2: 2\nAggregation exception id: 432, type: 1, rawContactId1: 3, rawContactId2: 4\n</code></pre> <pre><code>Aggregation exception id: 436, type: 1, rawContactId1: 1, rawContactId2: 2\nAggregation exception id: 439, type: 1, rawContactId1: 1, rawContactId2: 3\nAggregation exception id: 442, type: 1, rawContactId1: 1, rawContactId2: 4\nAggregation exception id: 440, type: 1, rawContactId1: 2, rawContactId2: 3\nAggregation exception id: 443, type: 1, rawContactId1: 2, rawContactId2: 4\nAggregation exception id: 444, type: 1, rawContactId1: 3, rawContactId2: 4\n</code></pre> <p>There is a pattern here. RawContact ids are sorted in ascending order and linked from least to greatest exhaustively but no double links (1-2 is the same as 2-1).</p> <ul> <li>RawContact 1 has a row with RawContact 2, 3, and 4.</li> <li>RawContact 2 has a row with RawContact 3 and 4.</li> <li>RawContact 3 has a row with RawContact 4.</li> </ul> <p>Linking all in one go;</p> <ul> <li>Contact C link Contact A, B, D</li> </ul> <p>Results in the same AggregationExceptions rows.</p> <p>Unlinking results in the same AggregationExceptions rows except the type is 2 (<code>TYPE_KEEP_SEPARATE</code>).</p>"},{"location":"other/link-unlink-contacts/#contact-display-name-and-default-name-rows","title":"Contact Display Name and Default Name Rows","text":"<p>If available, the \"default\" (isPrimary and isSuperPrimary set to 1) name row for a Contact is automatically set as the Contact display name by the Contacts Provider. Otherwise, the Contacts Provider chooses from any of the other suitable data from the aggregate Contact.</p> <p>\u2139\ufe0f The <code>ContactsColumns.NAME_RAW_CONTACT_ID</code> is automatically updated by the Contacts Provider along with the display name.</p> <p>The default status of other sources (e.g. email) does not affect the Contact display name.</p> <p>The AOSP Contacts app also sets the most recently updated name as the default at every update. This results in the Contact display name changing to the most recently updated name from one of the associated RawContacts. The \"most recently updated name\" is the name field that was last updated by the user when editing in the Contacts app, which is irrelevant to its value. It does not matter if the user deleted the last character of the name, added the same character back, and then saved. It still counts as the most recently updated.</p> <p>All of the above only applies to API 21 and above.</p> <p>Display name resolution is different for APIs below 21 (pre-Lollipop)!</p> <p>The <code>ContactsColumns.NAME_RAW_CONTACT_ID</code> was added in API 21. It changed the way display names are resolved for Contacts with more than one constituent RawContacts, which is what has been described so far.</p> <p>Before this change (APIs 20 and below), the AOSP Contacts app is still able to set the Contact display name somehow. I'm not sure how. If someone figures it out, please let me know. I tried updating the Contact <code>DISPLAY_NAME</code> directly but it does not work. Setting a name row as default also does not affect the Contact <code>DISPLAY_NAME</code>.</p>"},{"location":"other/link-unlink-contacts/#effects-of-linkingunlinking-contacts","title":"Effects of linking/unlinking contacts","text":"<p>When two or more Contacts (along with their constituent RawContacts) are linked into a single Contact those Contacts will be merged into one of the existing Contact row. The Contacts that have been merged into the single Contact will have their entries/rows in the Contacts table deleted.</p> <p>Unlinking will result in the original Contacts prior to linking to have new rows in the Contacts table with different IDs because the previously deleted row IDs cannot be reused.</p> <p>Getting Contacts that have been linked into a single Contact or Contacts whose row IDs have change after unlinking is still possible using the Contact lookup key.</p> <p>For more info, read about Contact lookup key vs ID.</p>"},{"location":"other/share-contacts-vcard/","title":"Share contacts vCard (.VCF)","text":"<p>This library provides several functions to create <code>Intent</code>s that allow you to share contacts from  the Contacts Provider database.</p> <p>\u2139\ufe0f These APIs are available since version 0.2.1 upon implementing issue #211.</p>"},{"location":"other/share-contacts-vcard/#share-an-existing-contact","title":"Share an existing contact","text":"<p>To share a single existing contact, use the extensions in <code>contacts.core.util.ContactShare</code>,</p> <pre><code>val contact: ExistingContactEntity\nval shareIntent = contact.shareVCardIntent()\nif (shareIntent != null) {\n    activity.startActivity(Intent.createChooser(shareIntent, null))\n}\n</code></pre> <p>The above code will open up a share sheet that will allow you to send the .VCF file (a vCard)  containing the contact data. Opening this file in any OS (iOS, OSX, Windows) typically prompts the addition of the contact contained in the vCard.</p>"},{"location":"other/share-contacts-vcard/#share-multiple-existing-contacts","title":"Share multiple existing contacts","text":"<p>To share multiple existing contacts, use the extensions in <code>contacts.core.util.ContactShare</code>,</p> <pre><code>val contacts: Collection&lt;ExistingContactEntity&gt;\nval shareIntent = contacts.shareMultiVCardIntent()\nif (shareIntent != null) {\n    activity.startActivity(Intent.createChooser(shareIntent, null))\n}\n</code></pre> <p>The above code will open up a share sheet that will allow you to send the .VCF file (a vCard) containing all contacts' data. Opening this file in any OS (iOS, OSX, Windows) typically prompts the addition of all contact(s) contained in the vCard.</p> <p>\u26a0\ufe0f The <code>shareMultiVCardIntent</code> function is only supported for API 21+. A null <code>Intent</code> will be returned for lower API levels.</p>"},{"location":"other/share-contacts-vcard/#excluding-photo-data","title":"Excluding photo data","text":"<p>By default, photo (thumbnail) data are included in the vCard. To exclude photo data to minimize file size, set the <code>includePhoto</code> parameter to false,</p> <pre><code>contact.shareVCardIntent(includePhoto = false)\ncontacts.shareMultiVCardIntent(includePhoto = false)\n</code></pre> <p>\u26a0\ufe0f This optional parameter is only supported for API 23 and above. It does nothing for lower  API levels.</p> <p>\u26a0\ufe0f This optional parameter does not seem to do anything for <code>shareMultiVCardIntent</code>. Photo data is still included in the output vCard even if this is set to false. The <code>shareVCardIntent</code> does not  have this issue.</p>"},{"location":"other/share-contacts-vcard/#custom-data-support","title":"Custom data support","text":"<p>Custom data are not supported by any of these functions. Custom data will not be included in the  output vCard.</p>"},{"location":"other/share-contacts-vcard/#advance-contact-sharing-via-customizable-vcard-exports","title":"Advance contact sharing via customizable vCard exports","text":"<p>Currently, the share functions provided use the builtin vCard export functions of the Contacts  Provider. In the future, when  Read/write from/to .VCF file (issue #26) is implemented, you will be able to...</p> <ul> <li>share (export) new contacts that are not in the database</li> <li>share (export) existing contacts with changes that are not in the database</li> <li>include only specified fields to export</li> </ul> <p>Be excited for the future!</p>"},{"location":"permissions/permissions-handling-coroutines/","title":"Permissions handling using coroutines","text":"<p>This library provides extensions in the <code>permissions</code> module that allow you to prompt users for  required permissions before executing a core API function. These extensions use  Kotlin Coroutines.</p> <p>For all core API functions that requires certain permissions to be granted (e.g. query, insert, update, and deletes), there is a corresponding <code>xxxWithPermission</code> extension function.</p>"},{"location":"permissions/permissions-handling-coroutines/#using-withpermission-extensions","title":"Using <code>withPermission</code> extensions","text":"<p>To perform an query, insert, update, and delete with permission,</p> <pre><code>launch {\n    val contactsApi = Contacts(context)\n    val query = contactsApi.queryWithPermission()\n    val insert = contactsApi.insertWithPermission()\n    val update = contactsApi.updateWithPermission()\n    val delete = contactsApi.deleteWithPermission()\n}\n</code></pre> <p>For each invocation of <code>xxxWithPermission</code>, if the required permission(s) are not yet granted,  the current coroutine is suspended, user is prompted to grant permissions, and then an operation instance is returned (which may then be executed to get a result).</p> <p>If permission(s) are already granted, then an operation instance is returned immediately without suspending the coroutine and prompting the user for permission.</p> <p>If permission(s) are not granted, then the operation will immediately fail and the result you get  is incorrect (usually null or empty when it should not be).</p> <p>\u2139\ufe0f Prior to Android 6.0 Marshmallow (API level 23), users are NOT prompted for permission at runtime because users must already grant all permissions prior to app install.</p>"},{"location":"permissions/permissions-handling-coroutines/#not-compatible-with-java","title":"Not compatible with Java","text":"<p>Unlike the <code>core</code> module, the <code>permissions</code> module is not compatible with Java because it requires  Kotlin Coroutines.</p>"},{"location":"permissions/permissions-handling-coroutines/#these-extensions-are-optional","title":"These extensions are optional","text":"<p>You are free to use the core APIs however you want with whatever libraries or frameworks you want  that works with Java or use your own DIY solution.</p>"},{"location":"profile/delete-profile/","title":"Delete device owner Contact profile","text":"<p>This library provides the <code>ProfileDelete</code> API, which allows you to delete the device owner Profile  Contact or only some of its constituent RawContacts.</p> <p>\u2139\ufe0f There can be only one device owner Contact, which is either set (not null) or not yet set  (null). However, like other regular Contacts, the Profile Contact may have one or more  RawContacts.</p> <p>An instance of the <code>ProfileDelete</code> API is obtained by,</p> <pre><code>val delete = Contacts(context).profile().delete()\n</code></pre> <p>\u2139\ufe0f If you want to delete non-Profile Contacts, read Delete Contacts</p>"},{"location":"profile/delete-profile/#a-basic-delete","title":"A basic delete","text":"<p>To delete a the profile Contact (if it exist) and all of its RawContacts,</p> <pre><code>val deleteResult = delete\n     .contact()\n     .commit()\n</code></pre> <p>If you want to delete a set of RawContacts belonging to the profile Contact,</p> <pre><code>val deleteResult = delete\n     .rawContacts(contactToDelete)\n     .commit()\n</code></pre> <p>Note that the profile Contact is deleted automatically when all constituent RawContacts are deleted.</p>"},{"location":"profile/delete-profile/#executing-the-delete","title":"Executing the delete","text":"<p>To execute the delete,</p> <pre><code>.commit()\n</code></pre> <p>If you want to delete all given RawContacts in a single atomic transaction,</p> <pre><code>.commitInOneTransaction()\n</code></pre> <p>The call to <code>commitInOneTransaction</code> will only succeed if ALL given RawContacts are successfully  deleted. If one delete fails, the entire operation will fail and everything will be reverted prior  to the delete operation. In contrast, <code>commit</code> allows for some deletes to succeed and some to fail. This really only applies to when only <code>rawContacts</code> are specified.</p>"},{"location":"profile/delete-profile/#performing-the-delete-and-result-processing-asynchronously","title":"Performing the delete and result processing asynchronously","text":"<p>Deletes are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"profile/delete-profile/#performing-the-delete-with-permission","title":"Performing the delete with permission","text":"<p>Deletes require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the delete will do nothing and return a failed result.</p> <p>\u2139\ufe0f For API 22 and below, the permission \"android.permission.WRITE_PROFILE\" is also required but only at the manifest level. Prior to API 23 (Marshmallow), permissions needed to be granted prior to installation instead of at runtime.</p> <p>To perform the delete with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"profile/delete-profile/#custom-data-support","title":"Custom data support","text":"<p>The <code>ProfileDelete</code> API supports custom data. For more info, read Delete custom data.</p>"},{"location":"profile/insert-profile/","title":"Insert the device owner Contact profile","text":"<p>This library provides the <code>ProfileInsert</code> API that allows you to insert one or more RawContacts and  Data. </p> <p>\u2139\ufe0f There can be only one device owner Contact, which is either set (not null) or not yet set  (null). However, like other regular Contacts, the Profile Contact may have one or more RawContacts.</p> <p>An instance of the <code>ProfileInsert</code> API is obtained by,</p> <pre><code>val insert = Contacts(context).profile().insert()\n</code></pre> <p>\u2139\ufe0f If you want to create/insert non-Profile Contacts, read Insert contacts.</p>"},{"location":"profile/insert-profile/#a-basic-insert","title":"A basic insert","text":"<p>To create/insert a raw contact with a name of \"John Doe\" who works at Amazon with a work email of \"john.doe@amazon.com\" (in Kotlin),</p> <pre><code>val insertResult = Contacts(context)\n    .profile()\n    .insert()\n    .rawContacts(NewRawContact().apply {\n        name = NewName().apply {\n            givenName = \"John\"\n            familyName = \"Doe\"\n        }\n        organization = NewOrganization().apply {\n            company = \"Amazon\"\n            title = \"Superstar\"\n        }\n        emails.add(NewEmail().apply {\n            address = \"john.doe@amazon.com\"\n            type = EmailEntity.Type.WORK\n        })\n    })\n    .commit()\n</code></pre> <p>Or alternatively, in a more Kotlinized style using named arguments,</p> <pre><code>val insertResult = Contacts(context)\n    .profile()\n    .insert()\n    .rawContacts(NewRawContact(\n        name = NewName(\n            givenName = \"John\",\n            familyName = \"Doe\"\n        ),\n        organization = NewOrganization(\n            company = \"Amazon\",\n            title = \"Superstar\"\n        ),\n        emails = mutableListOf(NewEmail(\n            address = \"john.doe@amazon.com\",\n            type = EmailEntity.Type.WORK\n        ))\n    ))\n    .commit()\n</code></pre> <p>Or alternatively, using extension functions,</p> <pre><code>val insertResult = Contacts(context)\n    .profile()\n    .insert()\n    .rawContact {\n        setName {\n            givenName = \"John\"\n            familyName = \"Doe\"\n        }\n        setOrganization {\n            company = \"Amazon\"\n            title = \"Superstar\"\n        }\n        addEmail {\n            address = \"john.doe@amazon.com\"\n            type = EmailEntity.Type.WORK\n        }\n    }\n    .commit()\n</code></pre>"},{"location":"profile/insert-profile/#allowing-blanks","title":"Allowing blanks","text":"<p>The API allows you to specify if you want to be able to insert blank contacts or not,</p> <pre><code>.allowBlanks(true|false)\n</code></pre> <p>For more info, read about Blank contacts.</p> <p>\u2139\ufe0f This may affect performance. When this is set to false, the API executes extra lines of code to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to true.</p>"},{"location":"profile/insert-profile/#blank-data-are-not-inserted","title":"Blank data are not inserted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are  ignored and are not inserted by insert APIs.</p> <p>For more info, read about Blank data.</p>"},{"location":"profile/insert-profile/#allowing-multiple-rawcontacts-per-account","title":"Allowing multiple RawContacts per Account","text":"<p>The API allows you to insert a profile RawContact with an Account that already has a profile  RawContact,</p> <pre><code>.allowMultipleRawContactsPerAccount(true|false)\n</code></pre> <p>According to the <code>ContactsContract.Profile</code> documentation; </p> <p>... each account (including data set, if applicable) on the device may contribute a single raw  contact representing the user's personal profile data from that source.</p> <p>In other words, one account can have one profile RawContact. However, despite the documentation of  \"one profile RawContact per one Account\", the Contacts Provider allows for multiple RawContacts per Account, including multiple local RawContacts (no Account). </p> <p>\u2139\ufe0f This may affect performance. When this is set to false, the API executes extra lines of code to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to true.</p>"},{"location":"profile/insert-profile/#associating-an-account","title":"Associating an Account","text":"<p>New RawContacts can be associated with an Account in order to enable syncing,</p> <pre><code>newRawContact.account = account\n// or newRawContact.setAccount(account)\n</code></pre> <p>\u2139\ufe0f Prior to version 0.3.0, setting the account is done via the <code>ProfileInsert.forAccount</code> function.</p> <p>For example, to associated the new RawContact to an account,</p> <pre><code>newRawContact.account = Account(\"john.doe@gmail.com\", \"com.google\")\n// or newRawContact.setAccount(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p>"},{"location":"profile/insert-profile/#account-validation","title":"Account validation","text":"<p>By default, all Accounts in the system are queried in order to ensure that each <code>NewRawContact.account</code> is in the system. For Accounts that are not in the system, null is used instead. This guards against invalid accounts.</p> <p>You may explicitly enable or disable this,</p> <pre><code>.validateAccounts(true|false)\n</code></pre> <p>\u2139\ufe0f This may affect performance. When this is set to true, the API executes extra lines of code to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to false.</p>"},{"location":"profile/insert-profile/#group-memberships-validation","title":"Group memberships validation","text":"<p>By default, all Groups belonging to the <code>NewRawContact.account</code> are queried to ensure that each <code>NewRawContact.groupMemberships</code> points to a Group in that list. Group memberships that are not pointing to a group that belong to the <code>NewRawContact.account</code> are not inserted. This guards against invalid accounts.</p> <p>You may explicitly enable or disable this,</p> <pre><code>.validateGroupMemberships(true|false)\n</code></pre> <p>\u2139\ufe0f This may affect performance. When this is set to true, the API executes extra lines of code to perform the validation, which may result in a slight performance hit. You can disable this internal check, perhaps increasing insertion speed, by setting this to false.</p>"},{"location":"profile/insert-profile/#local-rawcontacts","title":"Local RawContacts","text":"<p>If no Account is provided, or null is provided, or if an incorrect account is provided, the RawContacts inserted will not be associated with an Account. RawContacts inserted without an associated account are considered local or device-only contacts, which are not synced.</p> <p>\u2139\ufe0f For more info, read Sync contact data across devices.</p>"},{"location":"profile/insert-profile/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the insert operation,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"profile/insert-profile/#executing-the-insert","title":"Executing the insert","text":"<p>To execute the insert,</p> <pre><code>.commit()\n</code></pre>"},{"location":"profile/insert-profile/#handling-the-insert-result","title":"Handling the insert result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <pre><code>val contactsApi =  Contacts(context)\nval newRawContact = NewRawContact(...)\n\nval insertResult = contactsApi\n    .profile()\n    .insert()\n    .rawContact(newRawContact)\n    .commit()\n</code></pre> <p>To check if the insert succeeded,</p> <pre><code>val insertSucess = insertResult.isSuccessful\n</code></pre> <p>To get the RawContact IDs of the newly created RawContact,</p> <pre><code>val rawContactId = insertResult.rawContactId\n</code></pre> <p>Once you have the RawContact ID, you can retrieve the newly created Contact via the <code>Query</code> API,</p> <pre><code>val contacts = contactsApi\n    .query()\n    .where { RawContact.Id equalTo rawContactId }\n    .find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query contacts (advanced).</p> <p>Alternatively, you may use the extensions provided in <code>ProfileInsertResult</code>. To get the newly created Contact,</p> <pre><code>val contact = insertResult.contact(contactsApi)\n</code></pre> <p>To instead get the RawContact directly,</p> <pre><code>val rawContacts = insertResult.rawContact(contactsApi)\n</code></pre>"},{"location":"profile/insert-profile/#cancelling-the-insert","title":"Cancelling the insert","text":"<p>To cancel an insert amid execution,</p> <pre><code>.commit { returnTrueIfInsertShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel insert processing as soon as possible. The function is called numerous times during insert processing to check if processing should stop or continue. This gives you the option to cancel the insert.</p> <p>For example, to automatically cancel the insert inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val insertResult = insert.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"profile/insert-profile/#performing-the-insert-and-result-processing-asynchronously","title":"Performing the insert and result processing asynchronously","text":"<p>Inserts are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"profile/insert-profile/#performing-the-insert-with-permission","title":"Performing the insert with permission","text":"<p>Inserts require the <code>android.permission.WRITE_CONTACTS</code> and <code>android.permission.GET_ACCOUNTS</code>  permissions. If not granted, the insert will do nothing and return a failed result.</p> <p>\u2139\ufe0f For API 22 and below, the permission \"android.permission.WRITE_PROFILE\" is also required but only at the manifest level. Prior to API 23 (Marshmallow), permissions needed to be granted prior to installation instead of at runtime.</p> <p>To perform the insert with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"profile/insert-profile/#custom-data-support","title":"Custom data support","text":"<p>The <code>ProfileInsert</code> API supports custom data. For more info, read Insert custom data into new or existing contacts.</p>"},{"location":"profile/insert-profile/#rawcontact-and-contact-aggregation","title":"RawContact and Contact aggregation","text":"<p>As per documentation in <code>android.provider.ContactsContract.Profile</code>,</p> <p>The user's profile entry cannot be created explicitly (attempting to do so will throw an exception). When a raw contact is inserted into the profile, the provider will check for the existence of a profile on the device. If one is found, the raw contact's RawContacts.CONTACT_ID column gets the _ID of the profile Contact. If no match is found, the profile Contact is created and its _ID is put into the RawContacts.CONTACT_ID column of the newly inserted raw contact.</p>"},{"location":"profile/insert-profile/#inserting-photos-and-thumbnails","title":"Inserting photos and thumbnails","text":"<p>To set full-sized photos (and by API design thumbnails), read Get set remove full-sized and thumbnail contact photos.</p>"},{"location":"profile/query-profile/","title":"Query device owner Contact profile","text":"<p>This library provides the <code>ProfileQuery</code> API that allows you to get the device owner Profile Contact.</p> <p>\u2139\ufe0f There can be only one device owner Contact, which is either set (not null) or not yet set  (null). However, like other regular Contacts, the Profile Contact may have one or more RawContacts.</p> <p>An instance of the <code>ProfileQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).profile().query()\n</code></pre> <p>\u2139\ufe0f If you want to get non-Profile Contacts, read  Query contacts and Query contacts (advanced).</p>"},{"location":"profile/query-profile/#a-basic-query","title":"A basic query","text":"<p>To get the profile Contact,</p> <pre><code>val profileContact = Contacts(context).profile().query().find().contact\n</code></pre>"},{"location":"profile/query-profile/#specifying-accounts","title":"Specifying Accounts","text":"<p>To only include RawContacts associated with one of the given accounts,</p> <pre><code>.accounts(accounts)\n</code></pre> <p>For example, to include only RawContacts belonging to only one account,</p> <pre><code>.accounts(Account(\"john.doe@gmail.com\", \"com.google\"))\n</code></pre> <p>\u2139\ufe0f For more info, read Query for Accounts.</p> <p>The RawContacts returned will only belong to the specified accounts.</p> <p>If no accounts are specified (this function is not called or called with no Accounts), then all RawContacts are included in the returned Contact.</p> <p>A null Account may be provided here, which results in RawContacts with no associated Account to be included. RawContacts without an associated account are considered local contacts or device-only  contacts, which are not synced.</p> <p>For more info, read about Local (device-only) contacts.</p> <p>\u2139\ufe0f This may affect performance. This may require one or more additional queries, internally performed in this function, which increases the time required for the search. Therefore, you should only specify this if you actually need it.</p>"},{"location":"profile/query-profile/#including-only-specific-data","title":"Including only specific data","text":"<p>To include only the given set of fields (data) in each of the Profile Contact,</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to only include email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"profile/query-profile/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val profile = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"profile/query-profile/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap, which includes APIs for listening to Contacts database changes.</p>"},{"location":"profile/query-profile/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return null.</p> <p>\u2139\ufe0f For API 22 and below, the permission \"android.permission.READ_PROFILE\" is also required but only at the manifest level. Prior to API 23 (Marshmallow), permissions needed to be granted prior to installation instead of at runtime.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"profile/query-profile/#custom-data-support","title":"Custom data support","text":"<p>The <code>ProfilQuery</code> API supports custom data. For more info, read Query custom data.</p>"},{"location":"profile/update-profile/","title":"Update device owner Contact profile","text":"<p>This library provides the <code>ProfileUpdate</code> API that allows you to update the Profile contact in the  Contacts Provider database to ensure that it contains the same data as the contact and raw contacts you have in memory.</p> <p>\u2139\ufe0f There can be only one device owner Contact, which is either set (not null) or not yet set  (null). However, like other regular Contacts, the Profile Contact may have one or more RawContacts.</p> <p>An instance of the <code>ProfileUpdate</code> API is obtained by,</p> <pre><code>val update = Contacts(context).profile().update()\n</code></pre> <p>If you want to update non-Profile Contacts, read Update contacts.</p>"},{"location":"profile/update-profile/#a-basic-update","title":"A basic update","text":"<p>To update the profile Contact and all of its RawContacts,</p> <pre><code>val updateResult = Contacts(context)\n    .profile()\n    .update()\n    .contact(profile.mutableCopy {\n        // make changes\n    })\n    .commit()\n</code></pre> <p>To update a profile RawContact directly,</p> <pre><code>val updateResult = Contacts(context)\n    .update()\n    .rawContacts(profile.rawContacts.first().mutableCopy {\n        // make changes\n    })\n    .commit()\n</code></pre>"},{"location":"profile/update-profile/#deleting-blanks","title":"Deleting blanks","text":"<p>The API allows you to specify if you want the update operation to delete blank RawContacts or not,</p> <pre><code>.deleteBlanks(true|false)\n</code></pre> <p>For more info, read about Blank contacts.</p>"},{"location":"profile/update-profile/#blank-data-are-deleted","title":"Blank data are deleted","text":"<p>Blank data are data entities that have only null, empty, or blank primary value(s). Blanks are  deleted by update APIs, unless the corresponding fields are not included in the operation.</p> <p>For more info, read about Blank data.</p>"},{"location":"profile/update-profile/#including-only-specific-data","title":"Including only specific data","text":"<p>To perform update operations only the given set of fields (data),</p> <pre><code>.include(fields)\n</code></pre> <p>For example, to perform updates on only email and name fields,</p> <pre><code>.include { Email.all + Name.all }\n</code></pre> <p>For more info, read Include only certain fields for read and write operations.</p>"},{"location":"profile/update-profile/#executing-the-update","title":"Executing the update","text":"<p>To execute the update,</p> <pre><code>.commit()\n</code></pre>"},{"location":"profile/update-profile/#handling-the-update-result","title":"Handling the update result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <pre><code>val contactsApi =  Contacts(context)\nval mutableProfile = profile.mutableCopy { ... }\n\nval updateResult = contactsApi\n    .profile()\n    .update()\n    .contact(mutableProfile)\n    .commit()\n</code></pre> <p>To check if all updates succeeded,</p> <pre><code>val allUpdatesSuccessful = updateResult.isSuccessful\n</code></pre> <p>To check if a particular update succeeded,</p> <pre><code>val firstUpdateSuccessful = updateResult.isSuccessful(mutableProfile.rawContacts.first())\n</code></pre> <p>Once you have performed the updates, you can retrieve the updated profile Contact reference via the <code>Query</code> API,</p> <pre><code>val updatedProfile = Contacts(context).profile().query().find()\n</code></pre> <p>\u2139\ufe0f For more info, read Query device owner Contact profile.</p> <p>Alternatively, you may use the extensions provided in <code>ContactRefresh</code> and <code>RawContactRefresh</code>.</p> <p>To get the updated profile Contact and all of its RawContacts and Data,</p> <pre><code>val updatedProfile = profile.refresh(contactsApi)\n</code></pre> <p>To get an updated RawContact and Data,</p> <pre><code>val updatedProfileRawContact = profile.rawContacts.first().refresh(contactsApi)\n</code></pre>"},{"location":"profile/update-profile/#cancelling-the-update","title":"Cancelling the update","text":"<p>To cancel an update amid execution,</p> <pre><code>.commit { returnTrueIfUpdateShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel update processing as soon as possible. The function is called numerous times during update processing to check if processing should stop or continue. This gives you the option to cancel the update.</p> <p>For example, to automatically cancel the update inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val updateResult = update.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"profile/update-profile/#performing-the-update-and-result-processing-asynchronously","title":"Performing the update and result processing asynchronously","text":"<p>Updates are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"profile/update-profile/#performing-the-update-with-permission","title":"Performing the update with permission","text":"<p>Updates require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the update  will do nothing and return a failed result.</p> <p>\u2139\ufe0f For API 22 and below, the permission \"android.permission.WRITE_PROFILE\" is also required but only at the manifest level. Prior to API 23 (Marshmallow), permissions needed to be granted prior to installation instead of at runtime.</p> <p>To perform the update with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"profile/update-profile/#custom-data-support","title":"Custom data support","text":"<p>The <code>ProfileUpdate</code> API supports custom data. For more info, read Update custom data.</p>"},{"location":"profile/update-profile/#modifiable-contact-fields","title":"Modifiable Contact fields","text":"<p>As per documentation in <code>android.provider.ContactsContract.Profile</code>,</p> <p>The profile Contact has the same update restrictions as Contacts in general... Only certain columns of Contact are modifiable: STARRED, CUSTOM_RINGTONE, SEND_TO_VOICEMAIL. Changing any of these columns on the Contact also changes them on all constituent raw contacts.</p>"},{"location":"profile/update-profile/#updating-photos-and-thumbnails","title":"Updating photos and thumbnails","text":"<p>To set full-sized photos (and by API design thumbnails), read Get set remove full-sized and thumbnail contact photos.</p>"},{"location":"setup/installation/","title":"Installation guide","text":"<p>\u2139\ufe0f This library is a multi-module project published with JitPack </p> <p>First, include JitPack in the repositories list,</p> <pre><code>repositories {\n    maven { url \"https://jitpack.io\" }\n}\n</code></pre> <p>To install individual modules,</p> <pre><code>dependencies {\n    implementation 'com.github.vestrel00.contacts-android:core:&lt;version&gt;'\n\n    implementation 'com.github.vestrel00.contacts-android:async:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:customdata-gender:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:customdata-googlecontacts:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:customdata-handlename:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:customdata-pokemon:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:customdata-rpg:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:debug:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:permissions:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:test:&lt;version&gt;'\n    implementation 'com.github.vestrel00.contacts-android:ui:&lt;version&gt;'\n    // Notice that when installing individual modules, the first \":\" comes after \"contacts-android\".\n}\n</code></pre> <p>The <code>core</code> module is really all you need. All other modules are optional.</p> <p>It is recommended that you install individual modules to make sure that unused code is not included in your application, which will increase your app's APK size.</p> <p>If you still want to install all modules in a single line, read the Installing all modules in one line section below.</p>"},{"location":"setup/installation/#modules","title":"Modules","text":"<p>Here is a brief description of the individual modules you can install.</p> <ul> <li><code>core</code>: All of the contacts management APIs the library has to offer.   This is the only required module. All other modules are optional.</li> <li><code>async</code>: Extension functions for executing core API functions asynchronously using    Kotlin Coroutines.</li> <li><code>permissions</code>: Extension functions for executing core API functions with permissions   granted using Kotlin Coroutines.</li> <li><code>test</code>: APIs for mocking core APIs during tests or at production runtime.</li> <li><code>debug</code>: Extension functions for logging internal database tables into the Logcat and   other debugging related stuff. This is only meant for development use.</li> <li><code>ui</code>: Rudimentary UI views and functions that are already integrated with the core APIs.   You may use these for rapid prototyping or just for reference.</li> <li><code>customdata-gender</code>: Custom data for gender.</li> <li><code>customdata-googlecontacts</code>: Custom data managed by the Google Contacts app.</li> <li><code>customdata-handlename</code>: Custom data for handle.</li> <li><code>customdata-pokemon</code>: Custom data for pokemon.</li> <li><code>customdata-rpg</code>: Custom data for role playing games (RPG).</li> </ul>"},{"location":"setup/installation/#installing-all-modules-in-one-line","title":"Installing all modules in one line","text":"<p>To install all modules in a single line,</p> <pre><code>dependencies {\n    implementation 'com.github.vestrel00:contacts-android:&lt;version&gt;'\n    // Notice that when installing all modules, the first \":\" comes after \"vestrel00\".\n}\n</code></pre> <p>Starting with version <code>0.2.0</code>, installing all modules in a single line is only supported when using the <code>dependencyResolutionManagement</code> in <code>settings.gradle</code>.</p> <p>In your <code>settings.gradle</code>,</p> <pre><code>dependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        maven { url \"https://jitpack.io\" }\n    }\n}\n</code></pre> <p>For versions <code>0.1.10</code> and below, you can still install all modules in a single line using the old common method of dependency resolution. </p> <p>In your root <code>build.gradle</code>,</p> <pre><code>allprojects {\n    repositories {\n        maven { url \"https://jitpack.io\" }\n    }\n}\n</code></pre>"},{"location":"setup/setup-contacts-api/","title":"Contacts API Setup","text":"<p>The main library functions are all accessible via the <code>contacts.core.Contacts</code> API.</p> <p>There's no setup required. Just create an instance of <code>Contacts</code> and the world of contacts is at your disposal =)</p> <p>In Kotlin,</p> <pre><code>Contacts(context)\n</code></pre> <p>in Java,</p> <pre><code>ContactsFactory.create(context);\n</code></pre> <p>\u2139\ufe0f The <code>context</code> parameter can come from anywhere; Application, Activity, Fragment, or View. It  does not matter what context you pass in. The API will only use and store the Application context, to avoid leaks.</p> <p>It's up to you if you just want to create instances on demand. Or, hold on to instances as a  singleton that is injected to your dependency graph (via something like  dagger, hilt, or koin), which will make  black box testing and white box testing a walk in the park!</p>"},{"location":"setup/setup-contacts-api/#sync-adapter-operations","title":"Sync adapter operations","text":"<p>Instances of <code>Contacts</code> may be initialized with <code>callerIsSyncAdapter: Boolean</code> to set the value of <code>ContactsContract.CALLER_IS_SYNCADAPTER</code> for all CRUD APIs provided by the instance that use  <code>android.provider.ContactsContract</code> URIs.</p> <p>For more info, read the in-code documentation of <code>contacts.core.Contacts.callerIsSyncAdapter</code>.</p>"},{"location":"setup/setup-contacts-api/#logging-support","title":"Logging support","text":"<p>Instances of <code>Contacts</code> may be initialized with <code>logger: Logger</code> for logging support.</p> <p>For more info, read Log API input and output.</p>"},{"location":"setup/setup-contacts-api/#custom-data-integration","title":"Custom data integration","text":"<p>Instances of <code>Contacts</code> may be initialized with <code>customDataRegistry: CustomDataRegistry</code> for custom  data integration.</p> <p>For more info, read Integrate custom data.</p>"},{"location":"setup/setup-contacts-api/#optional-but-recommended-setup","title":"Optional, but recommended setup","text":"<p>It is recommended to use a single instance of the <code>Contacts</code> API throughout your application using  dependency injection. This will allow you to;</p> <ol> <li>Use the same <code>Contacts</code> API instance throughout your app.<ul> <li>This especially important when integrating custom data.</li> </ul> </li> <li>Easily substitute your <code>Contacts</code> API instance with an instance of <code>TestContacts</code>.<ul> <li>This is useful in black box testing (UI instrumentation tests; <code>androidTest/</code>).</li> <li>It may also be used in your production apps \"test mode\".</li> </ul> </li> <li>Easily substitute your <code>Contacts</code> API instance with an instance of <code>MockContacts</code><ul> <li>This is useful in white box testing (unit &amp; integration tests; <code>test/</code>).</li> </ul> </li> </ol> <p>For more info, read Contacts API Testing.</p> <p>\u2139\ufe0f This library does not (and will not) force you to do things you don't want. If you don't care  about all of the above and just want to get out a quick prototype of a feature in your app or an  entire app, then go for it! </p>"},{"location":"sim/about-sim-contacts/","title":"SIM Contacts","text":"<p>This library gives you APIs that allow you to read and write Contacts stored in the SIM card.</p> <ul> <li><code>SimContactsQuery</code></li> <li><code>SimContactsInsert</code></li> <li><code>SimContactsUpdate</code></li> <li><code>SimContactsDelete</code></li> </ul>"},{"location":"sim/about-sim-contacts/#sim-card-state","title":"SIM card state","text":"<p>In order for any SIM card read or write operations to succeed, the default/active SIM card must  be in a ready state. If no SIM card is in a ready state, then read/write operations will fail immediately. </p> <p>To check if the default/active SIM card is in a ready state,</p> <pre><code>val isSimCardReady = Contacts(context).sim().cardInfo.isReady\n</code></pre>"},{"location":"sim/about-sim-contacts/#sim-contact-data","title":"SIM Contact data","text":"<p>SIM Contact data consists of the <code>name</code> and <code>number</code>.</p> <p>\u2139\ufe0f Support for <code>email</code> was recently added in Android 12. I don't think it is stable yet.  Regardless, it is too new so this library will wait a bit before adding support for it.</p>"},{"location":"sim/about-sim-contacts/#character-limits","title":"Character limits","text":"<p>The <code>name</code> and <code>number</code> are subject to the SIM card's maximum character limit, which is typically  around 20-30 characters. This may vary per SIM card. Inserts or updates will fail if the limit is  breached.</p> <p>The <code>SimContactsInsert</code> and <code>SimContactsUpdate</code> APIs provided in this library automatically  detect max character limits and returns appropriate errors when limits are breached. However, you may also access these limits yourself if you want;</p> <pre><code>val nameMaxLength = Contacts(context).sim().cardInfo.maxCharacterLimits().nameMaxLength()\nval numberMaxLength = Contacts(context).sim().cardInfo.maxCharacterLimits().numberMaxLength()\n</code></pre> <p>Character limits are cached internally in shared preferences so that calculations need not occur everytime these functions are invoked. If you want to clear the cache to ensure recalculation;</p> <pre><code>Contacts(context).sim().cardInfo.maxCharacterLimits().clearCachedNameAndNumberMaxLengths()\n</code></pre>"},{"location":"sim/about-sim-contacts/#sim-contact-row-id","title":"SIM Contact row ID","text":"<p>The SIM contact that an ID is pointing to may change if the contact is deleted in the database and another contact is inserted. The inserted contact may be assigned the ID of the deleted contact.</p> <p>DO NOT RELY ON THIS TO MATCH VALUES IN THE DATABASE! The SIM table does not support selection by ID so you can't use this for anything anyways. </p>"},{"location":"sim/about-sim-contacts/#duplicate-entries-are-allowed","title":"Duplicate entries are allowed","text":"<p>Duplicate entries, multiple entries having the same name and/or number, are allowed. This follows the behavior of other smart phone and non-smart phone applications.</p>"},{"location":"sim/about-sim-contacts/#blanks-are-not-allowed","title":"Blanks are not allowed","text":"<p>Blank contacts (name AND number are both null or blank) will NOT be inserted. The name OR number can be null or blank but not both.</p>"},{"location":"sim/about-sim-contacts/#some-oems-automatically-sync-sim-card-data-with-contacts-provider-data","title":"Some OEMs automatically sync SIM card data with Contacts Provider data","text":"<p>Samsung and Xiaomi phones import contacts from SIM into the Contacts Provider. When using the  builtin Samsung Contacts app (in Samsung phones), modifications made to the SIM contacts from the  Contacts Provider are propagated to the SIM card and vice versa. AFAIK, Xiaomi phones do not have  this feature.</p> <p>Samsung is most likely syncing the SIM contacts with the copy in the Contacts Provider via SyncAdapters. The RawContacts created in the Contacts Provider have a non-remote account name and type (pointing to the SIM card),</p> <pre><code>accountName: primary.sim.account_name, accountType: vnd.sec.contact.sim \n</code></pre> <p>Similarly, in Xiaomi phones (though not synced to/from SIM card and Contacts Provider),</p> <pre><code>accountName: USIM, accountType: com.android.contacts.usim\n</code></pre> <p>SIM contacts imported into the Contacts Provider have the same restrictions as the SIM card in that  only columns available in the SIM are editable (_id, name, number, emails). Editing SIM contacts  that appear in the Contacts Provider using 3rd party apps will fail, though it may be possible to do with builtin Contacts app such as the case with Samsung's Contacts app (depends on OEM).</p> <p>If you find any issues when using the <code>SimContacts</code> APIs, please  raise an issue if you find any bugs or start a discussion and share your thoughts or knowledge =)</p>"},{"location":"sim/about-sim-contacts/#multi-sim-card-support","title":"Multi SIM card support","text":"<p>Android 5.1 adds support for using more than one cellular carrier SIM card at a time.  This feature lets users activate and use additional SIMs on devices that have two or more SIM card slots.</p> <p>The APIs in this library have not been tested against dual SIM card configurations. It should still work, at the very least the current default/active SIM card should be accessible.</p> <p>Support for multi-SIM card configurations is in the roadmap! Here's the issue for it;</p> <p>https://github.com/vestrel00/contacts-android/issues/336</p>"},{"location":"sim/about-sim-contacts/#limitations","title":"Limitations","text":"<p>Projections, selections, and order is not supported by the <code>IccProvider</code>. Therefore, we are unable to provide <code>include</code>, <code>where</code>, <code>orderBy</code>, <code>limit</code>, and <code>offset</code> functions in our <code>SimContactsQuery</code> API.</p> <p>Due to all of these limitations, all queries will return all contacts in the SIM card. Consumers of this library can perform their own sorting and pagination if they wish.</p> <p>Depending on memory size, SIM cards can hold 200 to 500+ contacts. The most common being around 250. Most, if not all, SIM cards have less than 1mb memory (averaging 32KB to 64KB). Therefore, memory and speed should not be affected much by not being able to sort/order and paginate at the query level. </p>"},{"location":"sim/about-sim-contacts/#debugging","title":"Debugging","text":"<p>To look at all of the rows in the SIM Contacts table, use the <code>Context.logSimContactsTable</code> function in the <code>debug</code> module.</p> <p>For more info, read Debug the Sim Contacts table.</p>"},{"location":"sim/about-sim-contacts/#known-issues","title":"Known issues","text":"<p>Samsung phones (and perhaps other OEMs) support emails (in addition to name and number) data ahead  of the Android 12 release. Updating and deleting SIM contacts that have email data using the APIs provided in this library may fail. This issue does not occur when moving the SIM card to a different phone that does not support emails. </p>"},{"location":"sim/about-sim-contacts/#developer-notes-or-for-advanced-users","title":"Developer notes (or for advanced users)","text":"<p>In building the <code>SimContacts</code> APIs provided in this library, I used the following hardware to  observe the behavior of reading/writing to the SIM card.</p> Smart phones Non-smart phones SIM cards Nexus 6P (Android 8) BLU Z5 (unknown OS) Mint Mobile Samsung Galaxy A71 (Android 11) <p>For software, I used the following apps.</p> Apps Smart phones SIM Card Info v1.1.6 Nexus 6P Samsung Contacts v12.7.10.12 Samsung Galaxy A71 <p>\u2139\ufe0f The AOSP Contacts app and Google Contacts app can only import contacts from SIM card so they are not very helpful for us with this investigation.</p> <p>For Android code references, I used the internal <code>IccProvider.java</code> as reference to what the Android OS might be doing when 3rd party applications perform CRUD operations on SIM contacts.</p> <ul> <li>IccProvider @ Android 8</li> <li>IccProvider @ Android 11</li> <li>IccProvider @ Android 12</li> </ul> <p>I'm using the <code>content://icc/adn</code> URI to read/write from/to SIM card.</p> <p>\u2139\ufe0f All of the investigation that I have done here may not apply for all SIM cards and phone OEMs!  There is just way too many different SIM cards and phones out there for a single person (me) to  test. However, I think that my findings should apply to most cases.</p>"},{"location":"sim/about-sim-contacts/#figuring-out-how-to-perform-crud-operations","title":"Figuring out how to perform CRUD operations","text":"<p>First, I added 20 contacts (name and number) to the SIM contacts using the BLU Z5. The first contact is named \"a\" with number \"1\", the second is named \"ab\" with number \"12\", and so on. The last contact is named \"abcdefghijklmnopqrst\" with number \"12345678901234567890\". I did this because the BLU Z5 has determined that the maximum character limit for the name and number for my  Mint Mobile SIM card is 20.</p> <p>\u2139\ufe0f The character limits are most likely set by the SIM card and/or calculated by the OS managing  it based on how much total memory is available.</p> <p>I also added a contact named \"bro\" with no number and a nameless contact with with number \"5555555555\". For a total of 22 contacts in the SIM card.</p> <p>I loaded the SIM card to my Nexus 6P. Then, I logged all of the rows in <code>content://icc/adn</code> using the <code>Context.logSimContactsTable</code> debug function I wrote up in the <code>debug</code> module.</p> <pre><code>SIM Contact id: 0, name: A, number: 1, emails: null\nSIM Contact id: 1, name: Ab, number: 12, emails: null\nSIM Contact id: 2, name: Abc, number: 123, emails: null\nSIM Contact id: 3, name: Abcd, number: 1234, emails: null\nSIM Contact id: 4, name: Abcde, number: 12345, emails: null\nSIM Contact id: 5, name: Abcdef, number: 123456, emails: null\nSIM Contact id: 6, name: Abcdefg, number: 1234567, emails: null\nSIM Contact id: 7, name: Abcdefgh, number: 12345678, emails: null\nSIM Contact id: 8, name: Abcdefghi, number: 123456789, emails: null\nSIM Contact id: 9, name: Abcdefghij, number: 1234567890, emails: null\nSIM Contact id: 10, name: Abcdefghijk, number: 12345678901, emails: null\nSIM Contact id: 11, name: Abcdefghijkl, number: 123456789012, emails: null\nSIM Contact id: 12, name: Abcdefghijklm, number: 1234567890123, emails: null\nSIM Contact id: 13, name: Abcdefghijklmn, number: 12345678901234, emails: null\nSIM Contact id: 14, name: Abcdefghijklmno, number: 123456789012345, emails: null\nSIM Contact id: 15, name: Abcdefghijklmnop, number: 1234567890123456, emails: null\nSIM Contact id: 16, name: Abcdefghijklmnopq, number: 12345678901234567, emails: null\nSIM Contact id: 17, name: Abcdefghijklmnopqr, number: 123456789012345678, emails: null\nSIM Contact id: 18, name: Abcdefghijklmnopqrs, number: 1234567890123456789, emails: null\nSIM Contact id: 19, name: Abcdefghijklmnopqrst, number: 12345678901234567890, emails: null\nSIM Contact id: 20, name: Bro, number: , emails: null\nSIM Contact id: 21, name: , number: 5555555555, emails: null\n</code></pre> <p>Our <code>SimContactsQuery</code> also retrieves the same exact results!</p> <p>I am able to see all of the contacts in the SIM Info app except for the nameless contact with number \"5555555555\". I attempted to add a nameless contact using the SIM Info app but it does not allow reading/writing nameless contacts. </p> <p>\u2139\ufe0f This is probably a bug in the SIM Info app or a limitation that is intentionally imposed for  some reason. I wish I could see the source code of the app!</p> <p>Deleting the first contact with ID of 0 using the SIM Info app works just fine. Deleting the contact with ID of 2 using our <code>SimContactsDelete</code> works just fine too. At this point the first 5 rows in the  table are;</p> <pre><code>SIM Contact id: 1, name: Ab, number: 12, emails: null\nSIM Contact id: 3, name: Abcd, number: 1234, emails: null\nSIM Contact id: 4, name: Abcde, number: 12345, emails: null\nSIM Contact id: 5, name: Abcdef, number: 123456, emails: null\nSIM Contact id: 6, name: Abcdefg, number: 1234567, emails: null\n</code></pre> <p>Inserting a contact using the SIM Info app and our <code>SimContactsInsert</code> (in that order) works just  fine, resulting in two new rows being added. One very interesting to note is that the IDs of the  previously deleted rows (0 and 2) have been assigned to the newly inserted contacts!</p> <pre><code>SIM Contact id: 0, name: SIM Info Contact, number: 8, emails: null\nSIM Contact id: 1, name: Ab, number: 12, emails: null\nSIM Contact id: 2, name: SimContactsInsert, number: 9, emails: null\nSIM Contact id: 3, name: Abcd, number: 1234, emails: null\nSIM Contact id: 4, name: Abcde, number: 12345, emails: null\nSIM Contact id: 5, name: Abcdef, number: 123456, emails: null\nSIM Contact id: 6, name: Abcdefg, number: 1234567, emails: null\n</code></pre> <p>This means that the IDs should not be used as a reference to a particular contact because it could  \"change\" in the process of deleting and inserting.</p> <p>As for updates, let's start with this table...</p> <pre><code>SIM Contact id: 3, name: Abcd, number: 1234, emails: null\nSIM Contact id: 4, name: Abcde, number: 12345, emails: null\n</code></pre> <p>Notice that Contact ID 0, 1, and 2 are available. Using the SIM Info app to \"update\" the contact with ID 4, we get...</p> <pre><code>SIM Contact id: 3, name: Abcd, number: 1234, emails: null\nSIM Contact id: 4, name: xxx, number: 12345, emails: null\n</code></pre> <p>The ID remains 4. We get the same result using our <code>SimContactsUpdate</code> API =)</p> <p>Thus, we have implemented CRUD APIs!!!</p>"},{"location":"sim/about-sim-contacts/#figuring-out-character-limits","title":"Figuring out character limits","text":"<p>The BLU Z5 non-smartphone has determined that the maximum character limit for the name and number  for my Mint Mobile SIM card is 20. </p> <p>I inserted a contact with a name with 26 characters and another contact with a number with 21  characters using the SIM Info app. The first insert (26 char name) succeeded but the second failed (21 char number).</p> <pre><code>SIM Contact id: 0, name: abcdefghijklmnopqrstuvwxyz, number: 1, emails: null\n</code></pre> <p>I did the same using our <code>SimContactsInsert</code>... The same thing occurred. This means that the  character limit is imposed on the number but perhaps not the name OR maybe the name has not reached  the maximum. I tried inserting a name with over 100 characters and it failed. So there is a  character limit for the name. I tried inserting names of shorter and shorter lengths until I find the max. It seems to be 30 characters.</p> <p>The character limits for the name is different for my Mint Mobile SIM card is different in the BLU Z5 vs Nexus 6P.</p> BLU Z5 Nexus 6P name 20 30 number 20 20 <p>I took out the SIM card from the Nexus 6P and plugging it back into the BLU Z5 to see if it will show the contacts that go over the 20 character limit. Both contacts with names longer than 20  characters are shown in the BLU Z5 BUT the name is truncated to 20. This could mean one of two  things;</p> <ul> <li>The phones determine the character limits based on SIM card memory.</li> <li>The SIM card specifies the character limits but the BLU Z5 hard codes it to 20 regardless.</li> </ul> <p>Time to check with the Samsung Galaxy A71! The Samsung yielded the same results as the Nexus. So, perhaps it is just the self-imposed limitation of the BLU phone.</p> <p>One interesting difference between the Samsung and the Nexus is that our <code>SimContactsInsert</code> was indicating that the insert succeeded in the Samsung even though no new row was created in the SIM table (oh Samsung lol). The result Uri returned by the insert operation is null in the Nexus but not null in the Samsung.</p> <p>What this all means? </p> <ul> <li>Our <code>SimContactsInsert</code> and <code>SimContactsUpdate</code> APIs need to be able to detect the maximum    character limits for the <code>name</code> and <code>number</code> before performing the actual insert or update    operation. </li> <li>To figure out the max character limits, we can attempt to insert a string of length 30 (most     names should fit there and most SIM cards have lower limits). Keep attempting to insert until     insert succeeds (query if the row is actually created instead of just relying on the insert      result), making the string shorter each time. Delete the successful insert and record the      length of the string. <ul> <li>Do this for both <code>name</code> and <code>number</code> and store the results in shared preferences mapped to a    unique ID of the SIM card. We do not want to do this calculation everytime our APIs are used!</li> </ul> </li> <li>Max character limits should be exposed our users via a public API.</li> <li>Furthermore, we cannot rely on the result of the insert operation alone. If the result Uri is not   null, we must perform a query to sanity check that the actual name and number was inserted!</li> </ul>"},{"location":"sim/about-sim-contacts/#emails","title":"Emails","text":"<p>There is an \"emails\" column in the SIM table. CRUD operations for it was not officially supported  until recently in Android 12.</p> <ul> <li>IccProvider @ Android 11</li> <li>IccProvider @ Android 12</li> </ul> <p>Look for \"TODO\" comments in the `IccProvider``. You will see TODOs for emails in Android 11 but  not Android 12.</p> <p>On my Samsung Galaxy A71 running Android 11...</p> <p>The column name is actually \"emails\" with an \"s\" (plural). What I observed,</p> <ul> <li>no email = \",\"</li> <li>at least one email = \"email,\"</li> </ul> <p>There seems to be a trailing \",\" regardless. It seems like the emails are in CSV format  (comma separated values).</p> <p>I was not able to delete rows with emails in them. I even tried updating the where clause used in our <code>SimContactsDelete</code> to include the email but it does not work.</p> <p>The builtin Samsung Contacts app is able to insert, update, and delete rows with emails. This  probably means that we don't have access to the internal APIs that the Samsung Contacts app has. Keep in mind that my Samsung is running Android 11 and support for email was not added until  Android 12. </p> <p>\u2139\ufe0f Classic Samsung to add features farther ahead of time than vanilla Android =)</p> <p>On my Nexus 6P running Android 8...</p> <p>The contacts with emails are shown without email data (emails are null in the SIM table). These rows are able to be updated and deleted.</p> <p>On my BLU Z5...</p> <p>SIM contacts with emails are shown without the email data. These rows are able to be updated and  deleted.</p>"},{"location":"sim/about-sim-contacts/#duplicate-entries","title":"Duplicate entries","text":"<p>Duplicate entries, multiple entries having the same name and/or number, seem to be allowed by smart phone and non-smart phone applications.</p>"},{"location":"sim/about-sim-contacts/#other-considerations","title":"Other considerations","text":"<p>It seems like there are new APIs around SIM Contacts that were introduced in API 31;</p> <ul> <li>https://developer.android.com/reference/android/provider/ContactsContract.SimContacts</li> <li>https://developer.android.com/reference/android/provider/SimPhonebookContract</li> </ul> <p>Those APIs are too new to be used by this library, which supports API levels down to 19. So, we'll  stick with using the <code>content://icc/adn</code> uri to read/write to SIM card until it becomes deprecated, if ever.</p>"},{"location":"sim/delete-sim-contacts/","title":"Delete contacts from SIM card","text":"<p>This library provides the <code>SimContactsDelete</code> API that allows you to delete existing contacts from the SIM card.</p> <p>An instance of the <code>SimContactsDelete</code> API is obtained by,</p> <pre><code>val delete = Contacts(context).sim().delete()\n</code></pre> <p>Note that SIM card deletes will only work if there is a SIM card in the ready state. For more info, read SIM card state.</p>"},{"location":"sim/delete-sim-contacts/#a-basic-delete","title":"A basic delete","text":"<p>To delete a set of existing contacts from the SIM card,</p> <pre><code>val deleteResult = Contacts(context)\n    .sim()\n    .delete()\n    .simContacts(existingSimContacts)\n    .commit()\n</code></pre> <p>To delete using name and number,</p> <pre><code>val deleteResult = Contacts(context)\n    .sim()\n    .delete()\n    .simContact(name, number)\n    .commit()\n</code></pre>"},{"location":"sim/delete-sim-contacts/#executing-the-delete","title":"Executing the delete","text":"<p>To execute the delete,</p> <pre><code>.commit()\n</code></pre>"},{"location":"sim/delete-sim-contacts/#handling-the-delete-result","title":"Handling the delete result","text":"<p>The <code>commit</code> function returns a <code>Result</code>,</p> <p>To check if all deletes succeeded,</p> <pre><code>val allDeletesSuccessful = deleteResult.isSuccessful\n</code></pre> <p>To check if a particular delete succeeded,</p> <pre><code>val deleteSuccessful = deleteResult.isSuccessful(simContact)\nval deleteSuccessful = deleteResult.isSuccessful(name, number)\n</code></pre>"},{"location":"sim/delete-sim-contacts/#performing-the-delete-and-result-processing-asynchronously","title":"Performing the delete and result processing asynchronously","text":"<p>Deletes are executed when the <code>commit</code> or <code>commitInOneTransaction</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"sim/delete-sim-contacts/#performing-the-delete-with-permission","title":"Performing the delete with permission","text":"<p>Deletes require the <code>android.permission.WRITE_CONTACTS</code> permissions. If not granted, the delete will do nothing and return a failed result.</p> <p>To perform the delete with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"sim/delete-sim-contacts/#known-issues","title":"Known issues","text":"<p>Samsung phones (and perhaps other OEMs) support emails (in addition to name and number) data ahead of the Android 12 release. Updating and deleting SIM contacts that have email data using the APIs provided in this library may fail. This issue does not occur when moving the SIM card to a different phone that does not support emails. </p>"},{"location":"sim/insert-sim-contacts/","title":"Insert contacts into SIM card","text":"<p>This library provides the <code>SimContactsInsert</code> API that allows you to create/insert contacts into the SIM card.</p> <p>An instance of the <code>SimContactsInsert</code> API is obtained by,</p> <pre><code>val insert = Contacts(context).sim().insert()\n</code></pre> <p>Note that SIM card inserts will only work if there is a SIM card in the ready state. For more info, read SIM card state.</p>"},{"location":"sim/insert-sim-contacts/#a-basic-insert","title":"A basic insert","text":"<p>To create/insert a new contact into the SIM card,</p> <pre><code>val insertResult = Contacts(context)\n    .sim()\n    .insert()\n    .simContact(NewSimContact(name = \"Dude\", number = \"5555555555\"))\n    .commit()\n</code></pre> <p>If you need to insert multiple contacts,</p> <pre><code>val newContact1 = NewSimContact(name = \"Dude1\", number = \"1234567890\")\nval newContact2 = NewSimContact(name = \"Dude2\", number = \"0987654321\")\n\nval insertResult = Contacts(context)\n    .sim()\n    .insert()\n    .simContacts(newContact1, newContact2)\n    .commit()\n</code></pre>"},{"location":"sim/insert-sim-contacts/#blank-contacts-are-not-allowed","title":"Blank contacts are not allowed","text":"<p>For more info, read about SIM Contacts</p>"},{"location":"sim/insert-sim-contacts/#character-limits","title":"Character limits","text":"<p>For more info, read about SIM Contacts</p>"},{"location":"sim/insert-sim-contacts/#executing-the-insert","title":"Executing the insert","text":"<p>To execute the insert,</p> <pre><code>.commit()\n</code></pre>"},{"location":"sim/insert-sim-contacts/#handling-the-insert-result","title":"Handling the insert result","text":"<p>The <code>commit</code> function returns a <code>Result</code>.</p> <p>To check if all inserts succeeded,</p> <pre><code>val allInsertsSuccessful = insertResult.isSuccessful\n</code></pre> <p>To check if a particular insert succeeded,</p> <pre><code>val firstInsertSuccessful = insertResult.isSuccessful(newContact1)\n</code></pre> <p>To get all newly created SimContacts, you may use the extensions provided in <code>SimContactsInsertResult</code>,</p> <pre><code>val simContacts = insertResult.simContacts(contactsApi)\n</code></pre> <p>To get a particular simContact,</p> <pre><code>val simContact = insertResult.simContact(contactsApi, newSimContact1)\n</code></pre> <p>\u26a0\ufe0f The <code>IccProvider</code> does not yet return the row ID of newly inserted contacts. Look at the \"TODO\" at line 259 of Android's IccProvider. Therefore, this library's insert API can only support getting the new rows from the result with some limitations around duplicate entries (see documentation in <code>SimContactsInsertResult</code>).</p>"},{"location":"sim/insert-sim-contacts/#handling-insert-failure","title":"Handling insert failure","text":"<p>The insert may fail for a particular SIM contact for various reasons,</p> <pre><code>insertResult.failureReason(newSimContact1)?.let {\n    when (it) {\n        NAME_EXCEEDED_MAX_CHAR_LIMIT -&gt; tellUserTheNameIsTooLong()\n        NUMBER_EXCEEDED_MAX_CHAR_LIMIT -&gt; tellUserTheNumberIsTooLong()\n        NAME_AND_NUMBER_ARE_BLANK -&gt; tellUserTheNameAndNumberCannotBothBeBlank()\n        UNKNOWN -&gt; showGenericErrorMessage()\n    }\n}\n</code></pre>"},{"location":"sim/insert-sim-contacts/#cancelling-the-insert","title":"Cancelling the insert","text":"<p>To cancel an insert amid execution,</p> <pre><code>.commit { returnTrueIfInsertShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel insert processing as soon as possible. The function is called numerous times during insert processing to check if processing should stop or continue. This gives you the option to cancel the insert.</p> <p>For example, to automatically cancel the insert inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val insertResult = insert.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"sim/insert-sim-contacts/#performing-the-insert-and-result-processing-asynchronously","title":"Performing the insert and result processing asynchronously","text":"<p>Inserts are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"sim/insert-sim-contacts/#performing-the-insert-with-permission","title":"Performing the insert with permission","text":"<p>Inserts require the <code>android.permission.WRITE_CONTACTS</code> permission. If not granted, the insert will do nothing and return a failed result.</p> <p>To perform the insert with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"sim/query-sim-contacts/","title":"Query contacts in SIM card","text":"<p>This library provides the <code>SimContactsQuery</code> API that allows you to get contacts stored in the SIM card.</p> <p>An instance of the <code>SimContactsQuery</code> API is obtained by,</p> <pre><code>val query = Contacts(context).sim().query()\n</code></pre> <p>Note that SIM card queries will only work if there is a SIM card in the ready state. For more info,  read SIM card state.</p>"},{"location":"sim/query-sim-contacts/#a-basic-query","title":"A basic query","text":"<p>To get all of the contacts in the SIM card,</p> <pre><code>val simContacts = Contacts(context).sim().query().find()\n</code></pre>"},{"location":"sim/query-sim-contacts/#limitations","title":"Limitations","text":"<p>Projections, selections, and order are not supported by the <code>IccProvider</code>. Therefore, we are unable to provide <code>include</code>, <code>where</code>, <code>orderBy</code>, <code>limit</code>, and <code>offset</code> functions in our <code>SimContactsQuery</code> API.</p> <p>Due to all of these limitations, all queries will return all contacts in the SIM card. You may  perform your own sorting and pagination if you wish.</p> <p>\u2139\ufe0f Depending on memory size, SIM cards can hold 200 to 500+ contacts. The most common being around 250. Most, if not all, SIM cards have less than 1mb memory (averaging 32KB to 64KB). Therefore, memory and speed should not be affected much by not being able to sort/order and paginate at the query level. </p> <p>For more info, read about SIM Contacts</p>"},{"location":"sim/query-sim-contacts/#executing-the-query","title":"Executing the query","text":"<p>To execute the query,</p> <pre><code>.find()\n</code></pre>"},{"location":"sim/query-sim-contacts/#cancelling-the-query","title":"Cancelling the query","text":"<p>To cancel a query amid execution,</p> <pre><code>.find { returnTrueIfQueryShouldBeCancelled() }\n</code></pre> <p>The <code>find</code> function optionally takes in a function that, if it returns true, will cancel query processing as soon as possible. The function is called numerous times during query processing to check if processing should stop or continue. This gives you the option to cancel the query.</p> <p>This is useful when used in multi-threaded environments. One scenario where this would be frequently used is when performing queries as the user types a search text. You are able to cancel the current query when the user enters new text.</p> <p>For example, to automatically cancel the query inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val simContacts = query.find { !isActive }\n    }\n}\n</code></pre>"},{"location":"sim/query-sim-contacts/#performing-the-query-asynchronously","title":"Performing the query asynchronously","text":"<p>Queries are executed when the <code>find</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"sim/query-sim-contacts/#performing-the-query-with-permission","title":"Performing the query with permission","text":"<p>Queries require the <code>android.permission.READ_CONTACTS</code> permission. If not granted, the query will  do nothing and return an empty list.</p> <p>To perform the query with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"sim/update-sim-contacts/","title":"Update contacts in SIM card","text":"<p>This library provides the <code>SimContactsUpdate</code> API that allows you to update contacts in the SIM card.</p> <p>An instance of the <code>SimContactsUpdate</code> API is obtained by,</p> <pre><code>val update = Contacts(context).sim().update()\n</code></pre> <p>Note that SIM card update will only work if there is a SIM card in the ready state. For more info, read SIM card state.</p>"},{"location":"sim/update-sim-contacts/#a-basic-update","title":"A basic update","text":"<p>To update an existing contact in the SIM card,</p> <pre><code>var current: SimContact\nvar modified: MutableSimContact = current.mutableCopy {\n    // change the name and/or number\n}\n\nval updateResult = Contacts(context)\n    .sim()\n    .update()\n    .simContact(current, modified)\n    .commit()\n</code></pre>"},{"location":"sim/update-sim-contacts/#making-further-updates","title":"Making further updates","text":"<p>The current entry in the SIM table is not updated based on the ID. Instead, the name AND number are  used to look up the entry to update. Continuing the example above, if you need to make another  update, then you must use the modified copy as the current,</p> <pre><code>current = modified\nmodified = current.newCopy {\n    // change the name and/or number\n}\n\nval result = update\n     .simContact(current, modified)\n     .commit()\n</code></pre> <p>\u2139\ufe0f This limitation comes from Android, not this library.</p>"},{"location":"sim/update-sim-contacts/#updating-multiple-contacts","title":"Updating multiple contacts","text":"<p>If you need to update multiple contacts,</p> <pre><code>val update1 = SimContactsUpdate.Entry(contact1, contact1.mutableCopy { ... })\nval update2 = SimContactsUpdate.Entry(contact2, contact2.mutableCopy { ... })\n\nval updateResult = Contacts(context)\n    .sim()\n    .update()\n    .simContacts(update1, update2)\n    .commit()\n</code></pre>"},{"location":"sim/update-sim-contacts/#blank-contacts-are-not-allowed","title":"Blank contacts are not allowed","text":"<p>For more info, read about SIM Contacts</p>"},{"location":"sim/update-sim-contacts/#character-limits","title":"Character limits","text":"<p>For more info, read about SIM Contacts</p>"},{"location":"sim/update-sim-contacts/#executing-the-update","title":"Executing the update","text":"<p>To execute the update,</p> <pre><code>.commit()\n</code></pre>"},{"location":"sim/update-sim-contacts/#handling-the-update-result","title":"Handling the update result","text":"<p>The <code>commit</code> function returns a <code>Result</code>.</p> <p>To check if all updates succeeded,</p> <pre><code>val allUpdatesSuccessful = updateResult.isSuccessful\n</code></pre> <p>To check if a particular update succeeded,</p> <pre><code>val firstUpdateSuccessful = updateResult.isSuccessful(simContact)\n</code></pre>"},{"location":"sim/update-sim-contacts/#handling-update-failure","title":"Handling update failure","text":"<p>The update may fail for a particular SIM contact for various reasons,</p> <pre><code>updateResult.failureReason(simContact)?.let {\n    when (it) {\n        NAME_EXCEEDED_MAX_CHAR_LIMIT -&gt; tellUserTheNameIsTooLong()\n        NUMBER_EXCEEDED_MAX_CHAR_LIMIT -&gt; tellUserTheNumberIsTooLong()\n        NAME_AND_NUMBER_ARE_BLANK -&gt; tellUserTheNameAndNumberCannotBothBeBlank()\n        UNKNOWN -&gt; showGenericErrorMessage()\n    }\n}\n</code></pre>"},{"location":"sim/update-sim-contacts/#cancelling-the-update","title":"Cancelling the update","text":"<p>To cancel an update amid execution,</p> <pre><code>.commit { returnTrueIfUpdateShouldBeCancelled() }\n</code></pre> <p>The <code>commit</code> function optionally takes in a function that, if it returns true, will cancel update processing as soon as possible. The function is called numerous times during update processing to check if processing should stop or continue. This gives you the option to cancel the update.</p> <p>For example, to automatically cancel the update inside a Kotlin coroutine when the coroutine is cancelled,</p> <pre><code>launch {\n    withContext(coroutineContext) {\n        val updateResult = update.commit { !isActive }\n    }\n}\n</code></pre>"},{"location":"sim/update-sim-contacts/#performing-the-update-and-result-processing-asynchronously","title":"Performing the update and result processing asynchronously","text":"<p>Updates are executed when the <code>commit</code> function is invoked. The work is done in the same thread as the call-site. This may result in a choppy UI.</p> <p>To perform the work in a different thread, use the Kotlin coroutine extensions provided in the <code>async</code> module. For more info, read Execute work outside of the UI thread using coroutines.</p> <p>You may, of course, use other multi-threading libraries or just do it yourself =)</p> <p>\u2139\ufe0f Extensions for Kotlin Flow and RxJava are also in the project roadmap.</p>"},{"location":"sim/update-sim-contacts/#performing-the-update-with-permission","title":"Performing the update with permission","text":"<p>Updates require the <code>android.permission.WRITE_CONTACTS</code> permission. If not granted, the update will do nothing and return a failed result.</p> <p>To perform the update with permission, use the extensions provided in the <code>permissions</code> module. For more info, read Permissions handling using coroutines.</p> <p>You may, of course, use other permission handling libraries or just do it yourself =)</p>"},{"location":"sim/update-sim-contacts/#known-issues","title":"Known issues","text":"<p>Samsung phones (and perhaps other OEMs) support emails (in addition to name and number) data ahead of the Android 12 release. Updating and deleting SIM contacts that have email data using the APIs provided in this library may fail. This issue does not occur when moving the SIM card to a different phone that does not support emails. </p>"},{"location":"testing/test-contacts-api/","title":"Contacts API Testing","text":"<p>TODO Complete this doc in https://github.com/vestrel00/contacts-android/issues/45</p> <p>This library provides the <code>TestContacts</code> and <code>MockContacts</code>, which you can use as a substitute to  your <code>Contacts</code> API instance in;</p> <ul> <li>black box tests; UI instrumentation tests in <code>androidTest/</code></li> <li>white box tests; unit &amp; integration tests in <code>test/</code></li> </ul>"},{"location":"testing/test-contacts-api/#ui-instrumentation-tests","title":"UI instrumentation tests","text":"<p>TODO Show usage of <code>TestContacts</code></p> <p>https://github.com/vestrel00/contacts-android/issues/46</p>"},{"location":"testing/test-contacts-api/#unit-integration-tests","title":"Unit &amp; integration tests","text":"<p>TODO Show usage of <code>MockContacts</code></p> <p>https://github.com/vestrel00/contacts-android/issues/47</p>"},{"location":"testing/test-contacts-api/#production-test-mode","title":"Production test mode","text":"<p>The <code>TestContacts</code> may also be used in your production apps, not just in tests. If you want your  production app to interact (query, insert, update, delete) with only \"test contacts\", all you would need to do is substitute your <code>Contacts</code> API instance with an instance of <code>TestContacts</code>.</p> <pre><code>@Singleton\nfun provideContactsApi(context: Context): Contacts = if (test) {\n    TestContacts(context)\n} else {\n    Contacts(context)\n}\n</code></pre> <p>\u2139\ufe0f The above code block is just pseudo-code for a dependency injection setup.</p> <p>For example, if you are building a contacts app, you can add a \"test\" or \"debug\" mode such that only test contacts are;</p> <ul> <li>returned by query APIs</li> <li>updated by update APIs</li> <li>inserted by insert APIs</li> <li>deleted by delete APIs</li> </ul> <p>When turning off test/debug mode, you can easily delete all test contacts created during the session and return to normal mode.</p>"},{"location":"ui/integrate-rudimentary-contacts-integrated-ui-components/","title":"Integrate rudimentary contacts ui components","text":"<p>TODO Coming soon</p>"}]}